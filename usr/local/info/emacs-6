This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

Replace Commands and Case
-------------------------

   If the arguments to a replace command are in lower case, it preserves
case when it makes a replacement.  Thus, the command

     M-x replace-string RET foo RET bar RET

replaces a lower case `foo' with a lower case `bar', `FOO' with `BAR',
and `Foo' with `Bar'.  If upper case letters are used in the second
argument, they remain upper case every time that argument is inserted.
If upper case letters are used in the first argument, the second
argument is always substituted exactly as given, with no case
conversion.  Likewise, if the variable `case-replace' is set to `nil',
replacement is done without case conversion.  If `case-fold-search' is
set to `nil', case is significant in matching occurrences of `foo' to
replace; this also inhibits case conversion of the replacement string.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

Query Replace
-------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     Replace some occurrences of STRING with NEWSTRING.

`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, then you cannot use an ordinary
`replace-string'.  Instead, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  A numeric argument to `query-replace'
tells it to consider only occurrences that are bounded by
word-delimiter characters.  This preserves case, just like
`replace-string', provided `case-replace' is non-`nil', as it normally
is.

   Aside from querying, `query-replace' works just like
`replace-string', and `query-replace-regexp' works just like
`replace-regexp'.  The shortest way to type this command name is `M-x
que SPC SPC SPC RET'.

   The things you can type when you are shown an occurrence of STRING
or a match for REGEXP are:

`SPC'
     to replace the occurrence with NEWSTRING.

`DEL'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character, except that since the
     replacement has already been made, DEL and SPC are equivalent.
     You could type `C-r' at this point (see below) to alter the
     replaced text.  You could also type `C-x u' to undo the
     replacement; this exits the `query-replace', so if you want to do
     further replacement you must use `C-x ESC ESC RET' to restart
     (*note Repetition::.).

`RET'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the position of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake.
     This works by popping the mark ring.  Only one `^' in a row is
     allowed, because only one previous replacement position is kept
     during `query-replace'.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' to proceed
     to the next occurrence.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' to proceed to the next occurrence.

`C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

`C-h'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Some other characters are aliases for the ones listed above: `y',
`n' and `q' are equivalent to SPC, DEL and RET.

   Aside from this, any other character exits the `query-replace', and
is then reread as part of a key sequence.  Thus, if you type `C-k', it
exits the `query-replace' and then kills to end of line.

   To restart a `query-replace' once it is exited, use `C-x ESC ESC',
which repeats the `query-replace' because it used the minibuffer to
read its arguments.  *Note C-x ESC ESC: Repetition.

   See also *Note Transforming File Names::, for Dired commands to
rename, copy, or link files by replacing regexp matches in file names.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

Other Search-and-Loop Commands
==============================

   Here are some other commands that find matches for a regular
expression.  They all operate from point to the end of the buffer.

`M-x occur RET REGEXP RET'
     Print each line that follows point and contains a match for
     REGEXP.  A numeric argument specifies the number of context lines
     to print before and after each matching line; the default is none.

     The buffer `*Occur*' containing the output serves as a menu for
     finding the occurrences in their original context.  Find an
     occurrence as listed in `*Occur*', position point there and type
     `C-c C-c'; this switches to the buffer that was searched and moves
     point to the original of the same occurrence.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x count-matches RET REGEXP RET'
     Print the number of matches for REGEXP after point.

`M-x flush-lines RET REGEXP RET'
     Delete each line that follows point and contains a match for
     REGEXP.

`M-x keep-lines RET REGEXP RET'
     Delete each line that follows point and does not contain a match
     for REGEXP.


File: emacs,  Node: Fixit,  Next: Files,  Prev: Search,  Up: Top

Commands for Fixing Typos
*************************

   In this chapter we describe the commands that are especially useful
for the times when you catch a mistake in your text just after you have
made it, or change your mind while composing text on line.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Kill Errors,  Next: Transpose,  Up: Fixit

Killing Your Mistakes
=====================

`DEL'
     Delete last character (`delete-backward-char').

`M-DEL'
     Kill last word (`backward-kill-word').

`C-x DEL'
     Kill to beginning of sentence (`backward-kill-sentence').

   The DEL character (`delete-backward-char') is the most important
correction command.  When used among graphic (self-inserting)
characters, it can be thought of as canceling the last character typed.

   When your mistake is longer than a couple of characters, it might be
more convenient to use `M-DEL' or `C-x DEL'.  `M-DEL' kills back to the
start of the last word, and `C-x DEL' kills back to the start of the
last sentence.  `C-x DEL' is particularly useful when you change your
mind about the phrasing of the text you are writing.  `M-DEL' and `C-x
DEL' save the killed text for `C-y' and `M-y' to retrieve.  *Note
Yanking::.

   `M-DEL' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and aren't
sure exactly what you typed.  At such a time, you cannot correct with
DEL except by looking at the screen to see what you did.  It requires
less thought to kill the whole word and start over again.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

Transposing Text
================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars').
Normally, `C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back to between
the two transposed characters.  If you transposed a space with the last
character of the word before it, the word motion commands are a good
way of getting there.  Otherwise, a reverse search (`C-r') is often the
best way.  *Note Search::.

   `M-t' (`transpose-words') transposes the word before point with the
word after point.  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Lists::.), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except in determining the
division of the text into syntactic units.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, sexp, line)
before or containing point across several other characters (words,
sexps, lines).  For example, `C-u 3 C-t' moves the character before
point forward across three other characters.  It would change
`f-!-oobar' into `oobf-!-ar'.  This is equivalent to repeating `C-t'
three times.  `C-u - 4 M-t' moves the word before point backward across
four words.  `C-u - C-M-t' would cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, sexp, line) ending after point with the
one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

Case Conversion
===============

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.


File: emacs,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

Checking and Correcting Spelling
================================

   This section describes the commands to check the spelling of a single
word or of a portion of a buffer.  These commands work with the spelling
checker program Ispell, which is not part of Emacs.  *Note Ispell: (The
Ispell Manual)Top.

`M-$'
     Check and correct spelling of word at point (`ispell-word').

`M-x ispell-buffer'
     Check and correct spelling of each word in the buffer.

`M-x ispell-region'
     Check and correct spelling of each word in the region.

`M-x ispell-complete-word'
     Complete the word before point based on the spelling dictionary.

`M-x ispell-kill-ispell'
     Kill the Ispell subprocess.

   To check the spelling of the word around or next to point, and
optionally correct it as well, use the command `M-$' (`ispell-word').
If the word is not correct, the command offers you various alternatives
for what to do about it.

   To check the entire current buffer, use `M-x ispell-buffer'.  Use
`M-x ispell-region' to check just the current region.  Each time these
commands encounter an incorrect word, they ask you what to do.

   Whenever one of these commands finds an incorrect word, it displays a
list of alternatives, usually including several "near-misses"--words
that are close to the word being checked.  Here are the valid responses:

`SPC'
     Skip this word--continue to consider it incorrect, but don't
     change it here.

`r NEW RET'
     Replace the word (just this time) with NEW.

`R NEW RET'
     Replace the word with NEW, and do a `query-replace' so you can
     replace it elsewhere in the buffer if you wish.

`DIGIT'
     Replace the word (just this time) with one of the displayed
     near-misses.  Each near-miss is listed with a digit; type that
     digit to select it.

`a'
     Accept the incorrect word--treat it as correct, but only in this
     editing session.

`A'
     Accept the incorrect word--treat it as correct, but only in this
     editing session and for this buffer.

`i'
     Insert this word in your private dictionary file so that Ispell
     will consider it correct it from now on, even in future sessions.

`m'
     Like `i', but you can also specify dictionary completion
     information.

`l WORD RET'
     Look in the dictionary for words that match WORD.  These words
     become the new list of "near-misses"; you can select one of them to
     replace with by typing a digit.  You can use `*' in WORD as a
     wildcard.

`C-g'
     Quit interactive spell checking.  You can restart it again
     afterward with `C-u M-$'.

`X'
     Same as `C-g'.

`C-z'
     This key has its normal command meaning (suspend Emacs or iconify
     this frame).

   The command `ispell-complete-word', which is bound to the key
`M-TAB' in Text mode and related modes, shows a list of completions
based on spelling correction.  Insert the beginning of a word, and then
type `M-TAB'; the command displays a completion list window.  To choose
one of the completions listed, click `Mouse-2' on it, or move the
cursor there in the completions window and type RET.  *Note Text Mode::.

   Once started, the Ispell subprocess continues to run (waiting for
something to do), so that subsequent spell checking commands complete
more quickly.  If you want to get rid of the Ispell process, use `M-x
ispell-kill-ispell'.  This is not usually necessary, since the process
uses no time except when you do spelling correction.


File: emacs,  Node: Files,  Next: Buffers,  Prev: Fixit,  Up: Top

File Handling
*************

   The basic unit of stored data in Unix is the "file".  To edit a file,
you must tell Emacs to examine the file and prepare a buffer containing
a copy of the file's text.  This is called "visiting" the file.  Editing
commands apply directly to text in the buffer; that is, to the copy
inside Emacs.  Your changes appear in the file itself only when you
"save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, keep multiple versions of them, and operate
on file directories.

* Menu:

* File Names::       How to type and edit file name arguments.
* Visiting::         Visiting a file prepares Emacs to edit the file.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Auto Save::        Auto Save periodically protects against loss of data.
* File Aliases::     Handling multiple names for one file.
* Version Control::  Version control systems (RCS and SCCS).
* ListDir::          Listing the contents of a file directory.
* Comparing Files::  Finding where two files differ.
* Misc File Ops::    Other things you can do on files.


File: emacs,  Node: File Names,  Next: Visiting,  Up: Files

File Names
==========

   Most Emacs commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows which
file name to use for them.)  You enter the file name using the
minibuffer (*note Minibuffer::.).  "Completion" is available, to make
it easier to specify long file names.  *Note Completion::.

   For most operations, there is a "default file name" which is used if
you type just RET to enter an empty argument.  Normally the default
file name is the name of the file visited in the current buffer; this
makes it easy to operate on that file with any of the Emacs file
commands.

   Each buffer has a default directory, normally the same as the
directory of the file visited in that buffer.  When you enter a file
name without a directory, the default directory is used.  If you specify
a directory in a relative fashion, with a name that does not start with
a slash, it is interpreted with respect to the default directory.  The
default directory is kept in the variable `default-directory', which
has a separate value in every buffer.

   For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is `/u/rms/gnu/'.  If you type just `foo', which
does not specify a directory, it is short for `/u/rms/gnu/foo'.
`../.login' would stand for `/u/rms/.login'.  `new/foo' would stand for
the file name `/u/rms/gnu/new/foo'.

   The command `M-x pwd' prints the current buffer's default directory,
and the command `M-x cd' sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the `cd'
command is used.  A file-visiting buffer's default directory is
initialized to the directory of the file that is visited there.  If you
create a buffer with `C-x b', its default directory is copied from that
of the buffer that was current at the time.

   The default directory actually appears in the minibuffer when the
minibuffer becomes active to read a file name.  This serves two
purposes: it *shows* you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to *edit* the default to specify a different directory.
This insertion of the default directory is inhibited if the variable
`insert-default-directory' is set to `nil'.

   Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name as part of the text.  The final minibuffer contents may look
invalid, but that is not so.  For example, if the minibuffer starts out
with `/usr/tmp/' and you add `/x1/rms/foo', the double slash says to
ignore the default directory and use just the name that you typed.
*Note Minibuffer File::.

   You can refer to files on other machines using a special file name
syntax:

     /HOST:FILENAME
     /USER@HOST:FILENAME

   When you do this, Emacs uses the FTP program to read and write files
on the specified host.  It logs in through FTP using your user name or
the name USER.  It may ask you for a password from time to time; this
is used for logging in on HOST.

   `$' in a file name is used to substitute environment variables.  For
example, if you have used the shell command `setenv FOO rms/hacks' to
set up an environment variable named `FOO', then you can use
`/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  The environment variable name consists of all
the alphanumeric characters after the `$'; alternatively, it may be
enclosed in braces after the `$'.  Note that the `setenv' command
affects Emacs only if done before Emacs is started.

   To access a file with `$' in its name, type `$$'.  This pair is
converted to a single `$' at the same time as variable substitution is
performed for single `$'.  The Lisp function that performs the
substitution is called `substitute-in-file-name'.  The substitution is
performed only on file names read as such using the minibuffer.


File: emacs,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

Visiting Files
==============

`C-x C-f'
     Visit a file (`find-file').

`C-x C-r'
     Visit a file for viewing, without allowing changes to it
     (`find-file-read-only').

`C-x C-v'
     Visit a different file instead of the one visited last
     (`find-alternate-file').

`C-x 4 C-f'
     Visit a file, in another window (`find-file-other-window').  Don't
     change the selected window.

`C-x 5 C-f'
     Visit a file, in a new frame (`find-file-other-frame').  Don't
     change the selected frame.

   "Visiting" a file means copying its contents into an Emacs buffer so
you can edit them.  Emacs makes a new buffer for each file that you
visit.  We say that this buffer is visiting the file that it was created
to hold.  Emacs constructs the buffer name from the file name by
throwing away the directory, keeping just the name proper.  For example,
a file named `/usr/rms/emacs.tex' would get a buffer named `emacs.tex'.
If there is already a buffer with that name, a unique name is
constructed by appending `<2>', `<3>', or so on, using the lowest
number that makes a name that is not already in use.

   Each window's mode line shows the name of the buffer that is being
displayed in that window, so you can always tell what buffer you are
editing.

   The changes you make with Emacs are made in the Emacs buffer.  They
do not take effect in the file that you visited, or any place
permanent, until you "save" the buffer.  Saving the buffer means that
Emacs writes the current contents of the buffer into its visited file.
*Note Saving::.

   If a buffer contains changes that have not been saved, we say the
buffer is "modified".  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line
displays two stars near the left margin to indicate that the buffer is
modified.

   To visit a file, use the command `C-x C-f' (`find-file').  Follow
the command with the name of the file you wish to visit, terminated by a
RET.

   The file name is read using the minibuffer (*note Minibuffer::.),
with defaulting and completion in the standard manner (*note File
Names::.).  While in the minibuffer, you can abort `C-x C-f' by typing
`C-g'.

   Your confirmation that `C-x C-f' has completed successfully is the
appearance of new text on the screen and a new buffer name in the mode
line.  If the specified file does not exist and could not be created, or
cannot be read, then you get an error, with an error message displayed
in the echo area.

   If you visit a file that is already in Emacs, `C-x C-f' does not make
another copy.  It selects the existing buffer containing that file.
However, before doing so, it checks that the file itself has not changed
since you visited or saved it last.  If the file has changed, a warning
message is printed.  *Note Simultaneous Editing: Interlocking.

   What if you want to create a new file?  Just visit it.  Emacs prints
`(New File)' in the echo area, but in other respects behaves as if you
had visited an existing empty file.  If you make any changes and save
them, the file is created.

   If the file you specify is actually a directory, Dired is called on
that directory (*note Dired::.).  This can be inhibited by setting the
variable `find-file-run-dired' to `nil'; then it is an error to try to
visit a directory.

   If you visit a file that the operating system won't let you modify,
Emacs makes the buffer read-only, so that you won't go ahead and make
changes that you'll have trouble saving afterward.  You can make the
buffer writable with `C-x C-q' (`vc-toggle-read-only').  *Note Misc
Buffer::.

   Occasionally you might want to visit a file as read-only in order to
protect yourself from entering changes accidentally; do so by visiting
the file with the command `C-x C-r' (`find-file-read-only').

   If you visit a nonexistent file unintentionally (because you typed
the wrong file name), use the `C-x C-v' command (`find-alternate-file')
to visit the file you really wanted.  `C-x C-v' is similar to `C-x
C-f', but it kills the current buffer (after first offering to save it
if it is modified).  When it reads the file name to visit, it inserts
the entire default file name in the buffer, with point just after the
directory part; this is convenient if you made a slight error in typing
the name.

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If this command is used when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.

   `C-x 5 f' (`find-file-other-frame') is similar, but opens a new
frame.  This feature is available only when you are using a window
system.  *Note Frames::.

   Two special hook variables allow extensions to modify the operation
of visiting files.  Visiting a file that does not exist runs the
functions in the list `find-file-not-found-hooks'; this variable holds
a list of functions, and the functions are called one by one until one
of them returns non-`nil'.  Any visiting of a file, whether extant or
not, expects `find-file-hooks' to contain a list of functions and calls
them all, one by one.  In both cases the functions receive no
arguments.  Of these two variables, `find-file-not-found-hooks' takes
effect first.  These variables are *not* normal hooks, and their names
end in `-hooks' rather than `-hook' to indicate that fact.

   There are several ways to specify automatically the major mode for
editing the file (*note Choosing Modes::.), and to specify local
variables defined for that file (*note File Variables::.).


File: emacs,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

Saving Files
============

   "Saving" a buffer in Emacs means writing its contents back into the
file that was visited in the buffer.

`C-x C-s'
     Save the current buffer in its visited file (`save-buffer').

`C-x s'
     Save any or all buffers in their visited files
     (`save-some-buffers').

`M-~'
     Forget that the current buffer has been changed (`not-modified').

`C-x C-w'
     Save the current buffer in a specified file (`write-file').

`M-x set-visited-file-name'
     Change file the name under which the current buffer will be saved.

   When you wish to save the file and make your changes permanent, type
`C-x C-s' (`save-buffer').  After saving is finished, `C-x C-s' prints
a message such as

     Wrote /u/rms/gnu/gnu.tasks

If the selected buffer is not modified (no changes have been made in it
since the buffer was created or last saved), saving is not really done,
because it would have no effect.  Instead, `C-x C-s' prints a message
in the echo area saying

     (No changes need to be written)

   The command `C-x s' (`save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  The
options are analogous to those of `query-replace':

`y'
     Save this buffer and ask about the rest of the buffers.

`n'
     Don't save this buffer, but ask about the rest of the buffers.

`!'
     Save this buffer and all the rest with no more questions.

`ESC'
     Terminate `save-some-buffers' without any more saving.

`.'
     Save this buffer, then exit `save-some-buffers' without even asking
     about other buffers.

`C-r'
     View the buffer that you are currently being asked about.  When
     you exit View mode, you get back to `save-some-buffers', which
     asks the question again.

`C-h'
     Display a help message about these options.

   `C-x C-c', the key sequence to exit Emacs, invokes
`save-some-buffers' and therefore asks the same questions.

   If you have changed a buffer and do not want the changes to be saved,
you should take some action to prevent it.  Otherwise, each time you use
`C-x s' or `C-x C-c', you are liable to save it by mistake.  One thing
you can do is type `M-~' (`not-modified'), which clears out the
indication that the buffer is modified.  If you do this, none of the
save commands will believe that the buffer needs to be saved.  (`~' is
often used as a mathematical symbol for `not'; thus `M-~' is `not',
metafied.)  You could also use `set-visited-file-name' (see below) to
mark the buffer as visiting a different file name, one which is not in
use for anything important.  Alternatively, you can cancel all the
changes made since the file was visited or saved, by reading the text
from the file again.  This is called "reverting".  *Note Reverting::.
You could also undo all the changes by repeating the undo command `C-x
u' until you have undone all the changes; but reverting is easier.

   `M-x set-visited-file-name' alters the name of the file that the
current buffer is visiting.  It reads the new file name using the
minibuffer.  Then it specifies the visited file name and changes the
buffer name correspondingly (as long as the new name is not in use).
`set-visited-file-name' does not save the buffer in the newly visited
file; it just alters the records inside Emacs in case you do save
later.  It also marks the buffer as "modified" so that `C-x C-s' in
that buffer *will* save.

   If you wish to mark the buffer as visiting a different file and save
it right away, use `C-x C-w' (`write-file').  It is precisely
equivalent to `set-visited-file-name' followed by `C-x C-s'.  `C-x C-s'
used on a buffer that is not visiting with a file has the same effect
as `C-x C-w'; that is, it reads a file name, marks the buffer as
visiting that file, and saves it there.  The default file name in a
buffer that is not visiting a file is made by combining the buffer name
with the buffer's default directory.

   If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem
caused by simultaneous editing and requires your immediate attention.
*Note Simultaneous Editing: Interlocking.

   If the variable `require-final-newline' is non-`nil', Emacs puts a
newline at the end of any file that doesn't already end in one, every
time a file is saved or written.

   You can implement other ways to write files, and other things to be
done before writing them, using the variable `write-file-hooks'.  The
value of this variable should be a list of Lisp functions.  When a file
is to be written, the functions in the list are called, one by one,
with no arguments.  If one of them returns a non-`nil' value, Emacs
takes this to mean that the file has been written in some suitable
fashion; the rest of the functions are not called, and normal writing
is not done.  If this variable is local to a buffer, changing major
modes does not clear it.  However, changing the visited file name does
clear this variable to `nil'.

   The list `local-write-file-hooks' is used just like
`write-file-hooks'.  This list is for use as a local variable.  It is a
permanent local, so that switching major modes does not affect it.

   The variable `write-contents-hooks' holds another list of functions
to be called before writing out a buffer to a file.  These functions
are used just like the ones in `write-file-hooks'.  The difference
between this and `write-file-hooks' is that changing the major mode
does clear this variable, and setting the visited file name does not
clear it.

   The hook functions are responsible for writing backup files, if you
want that to be done.  Here is how:

     (or buffer-backed-up (backup-buffer))

You might also wish to save the file modes value returned by
`backup-buffer' and use that to set the mode bits of the file that you
write.  This is what happens ordinarily when backups are made.

   The hook variables described here are not normal hooks, because the
values returned by the hook functions do matter.  This is why they have
names ending in `-hooks' rather than `-hook'.  *Note Hooks::.

* Menu:

* Backup::        How Emacs saves the old version of your file.
* Interlocking::  How Emacs protects against simultaneous editing
                    of one file by two users.


File: emacs,  Node: Backup,  Next: Interlocking,  Up: Saving

Backup Files
------------

   Because Unix does not provide version numbers in file names,
rewriting a file in Unix automatically destroys all record of what the
file used to contain.  Thus, saving a file from Emacs throws away the
old contents of the file--or it would, except that Emacs carefully
copies the old contents to another file, called the "backup" file,
before actually saving.  (This assumes that the variable
`make-backup-files' is non-`nil'.  Backup files are not written if this
variable is `nil'.)

   At your option, Emacs can keep either a single backup file or a
series of numbered backup files for each file that you edit.

   Emacs makes a backup for a file only the first time the file is saved
from one buffer.  No matter how many times you save a file, its backup
file continues to contain the contents from before the file was visited.
Normally this means that the backup file contains the contents from
before the current editing session; however, if you kill the buffer and
then visit the file again, a new backup file will be made by the next
save.

* Menu:

* Names: Backup Names.		How backup files are named;
				  choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.


File: emacs,  Node: Backup Names,  Next: Backup Deletion,  Up: Backup

Single or Numbered Backups
..........................

   If you choose to have a single backup file (this is the default),
the backup file's name is constructed by appending `~' to the file name
being edited; thus, the backup file for `eval.c' would be `eval.c~'.

   If you choose to have a series of numbered backup files, backup file
names are made by appending `.~', the number, and another `~' to the
original file name.  Thus, the backup files of `eval.c' would be called
`eval.c.~1~', `eval.c.~2~', and so on, through names like
`eval.c.~259~' and beyond.

   If protection stops you from writing backup files under the usual
names, the backup file is written as `%backup%~' in your home directory.
Only one such file can exist, so only the most recently made such
backup is available.

   The choice of single backup or numbered backups is controlled by the
variable `version-control'.  Its possible values are

`t'
     Make numbered backups.

`nil'
     Make numbered backups for files that have numbered backups already.
     Otherwise, make single backups.

`never'
     Do not in any case make numbered backups; always make single
     backups.

You can set `version-control' locally in an individual buffer to
control the making of backups for that buffer's file.  For example,
Rmail mode locally sets `version-control' to `never' to make sure that
there is only one backup for an Rmail file.  *Note Locals::.

   If you set the environment variable `VERSION_CONTROL', to tell
various GNU utilities what to do with backup files, Emacs also obeys the
environment variable by setting the Lisp variable `version-control'
accordingly at startup.  If the environment variable's value is `t' or
`numbered', then `version-control' becomes `t'; if the value is `nil'
or `existing', then `version-control' becomes `nil'; if it is `never'
or `simple', then `version-control' becomes `never'.

   For files under version control (*note Version Control::.), the
variable `vc-make-backup-files' determines whether to make backup
files.  By default, it is `nil', since backup files are redundant when
you store all the previous versions in a version control system.  *Note
Editing with VC::.


File: emacs,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

Automatic Deletion of Backups
.............................

   To prevent unlimited consumption of disk space, Emacs can delete
numbered backup versions automatically.  Generally Emacs keeps the
first few backups and the latest few backups, deleting any in between.
This happens every time a new backup is made.

   The two variables `kept-old-versions' and `kept-new-versions'
control this deletion.  Their values are, respectively the number of
oldest (lowest-numbered) backups to keep and the number of newest
(highest-numbered) ones to keep, each time a new backup is made.
Recall that these values are used just after a new backup version is
made; that newly made backup is included in the count in
`kept-new-versions'.  By default, both variables are 2.

   If `trim-versions-without-asking' is non-`nil', the excess middle
versions are deleted without a murmur.  If it is `nil', the default,
then you are asked whether the excess middle versions should really be
deleted.

   Dired's `.' (Period) command can also be used to delete old versions.
*Note Dired Deletion::.


File: emacs,  Node: Backup Copying,  Prev: Backup Deletion,  Up: Backup

Copying vs. Renaming
....................

   Backup files can be made by copying the old file or by renaming it.
This makes a difference when the old file has multiple names.  If the
old file is renamed into the backup file, then the alternate names
become names for the backup file.  If the old file is copied instead,
then the alternate names remain names for the file that you are
editing, and the contents accessed by those names will be the new
contents.

   The method of making a backup file may also affect the file's owner
and group.  If copying is used, these do not change.  If renaming is
used, you become the file's owner, and the file's group becomes the
default (different operating systems have different defaults for the
group).

   Having the owner change is usually a good idea, because then the
owner always shows who last edited the file.  Also, the owners of the
backups show who produced those versions.  Occasionally there is a file
whose owner should not change; it is a good idea for such files to
contain local variable lists to set `backup-by-copying-when-mismatch'
locally (*note File Variables::.).

   The choice of renaming or copying is controlled by three variables.
Renaming is the default choice.  If the variable `backup-by-copying' is
non-`nil', copying is used.  Otherwise, if the variable
`backup-by-copying-when-linked' is non-`nil', then copying is used for
files that have multiple names, but renaming may still used when the
file being edited has only one name.  If the variable
`backup-by-copying-when-mismatch' is non-`nil', then copying is used if
renaming would cause the file's owner or group to change.


File: emacs,  Node: Interlocking,  Prev: Backup,  Up: Saving

Protection against Simultaneous Editing
---------------------------------------

   Simultaneous editing occurs when two users visit the same file, both
make changes, and then both save them.  If nobody were informed that
this was happening, whichever user saved first would later find that his
changes were lost.  On some systems, Emacs notices immediately when the
second user starts to change the file, and issues an immediate warning.

   For the sake of systems where that is not possible, and in case
someone else proceeds to change the file despite the warning, Emacs also
checks when the file is saved, and issues a second warning if you are
about to overwrite a file containing another user's changes.  You can
prevent loss of the other user's work by taking the proper corrective
action at that time.

   When you make the first modification in an Emacs buffer that is
visiting a file, Emacs records that  the file is "locked" by you.  (It
does this by writing another file in a directory reserved for this
purpose.)  The lock is removed when you save the changes.  The idea is
that the file is locked whenever an Emacs buffer visiting it has
unsaved changes.

   If you begin to modify the buffer while the visited file is locked by
someone else, this constitutes a "collision".  When Emacs detects a
collision, it asks you what to do, by calling the Lisp function
`ask-user-about-lock'.  You can redefine this function for the sake of
customization.  The standard definition of this function asks you a
question and accepts three possible answers:

`s'
     Steal the lock.  Whoever was already changing the file loses the
     lock, and you gain the lock.

`p'
     Proceed.  Go ahead and edit the file despite its being locked by
     someone else.

`q'
     Quit.  This causes an error (`file-locked') and the modification
     you were trying to make in the buffer does not actually take place.

   Note that locking works on the basis of a file name; if a file has
multiple names, Emacs does not realize that the two names are the same
file and cannot prevent two users from editing it simultaneously under
different names.  However, basing locking on names means that Emacs can
interlock the editing of new files that will not really exist until
they are saved.

   Some systems are not configured to allow Emacs to make locks.  On
these systems, Emacs cannot detect trouble in advance, but it still can
detect the collision when you try to save a file and overwrite someone
else's changes.

   Every time Emacs saves a buffer, it first checks the
last-modification date of the existing file on disk to verify that it
has not changed since the file was last visited or saved.  If the date
does not match, it implies that changes were made in the file in some
other way, and these changes are about to be lost if Emacs actually
does save.  To prevent this, Emacs prints a warning message and asks
for confirmation before saving.  Occasionally you will know why the
file was changed and know that it does not matter; then you can answer
`yes' and proceed.  Otherwise, you should cancel the save with `C-g'
and investigate the situation.

   The first thing you should do when notified that simultaneous
editing has already taken place is to list the directory with `C-u C-x
C-d' (*note Directory Listing: ListDir.).  This  shows the file's
current author.  You should attempt to contact him to warn him not to
continue editing.  Often the next step is to save the contents of your
Emacs buffer under a different name, and use `diff' to compare the two
files.

   Simultaneous editing checks are also made when you visit with `C-x
C-f' a file that is already visited and when you start to modify a
file.  This is not strictly necessary, but it can cause you to find out
about the collision earlier, when perhaps correction takes less work.


File: emacs,  Node: Reverting,  Next: Auto Save,  Prev: Saving,  Up: Files

Reverting a Buffer
==================

   If you have made extensive changes to a file and then change your
mind about them, you can get rid of them by reading in the previous
version of the file.  To do this, use `M-x revert-buffer', which
operates on the current buffer.  Since this is a very dangerous thing
to do, you must confirm it with `yes'.

   `revert-buffer' keeps point at the same distance (measured in
characters) from the beginning of the file.  If the file was edited only
slightly, you will be at approximately the same piece of text after
reverting as before.  If you have made drastic changes, the same value
of point in the old file may address a totally different piece of text.

   Reverting marks the buffer as "not modified" until another change is
made.

   Some kinds of buffers whose contents reflect data bases other than
files, such as Dired buffers, can also be reverted.  For them,
reverting means recalculating their contents from the appropriate data
base.  Buffers created randomly with `C-x b' cannot be reverted;
`revert-buffer' reports an error when asked to do so.


File: emacs,  Node: Auto Save,  Next: File Aliases,  Prev: Reverting,  Up: Files

Auto-Saving: Protection Against Disasters
=========================================

   Emacs saves all the visited files from time to time (based on
counting your keystrokes) without being asked.  This is called
"auto-saving".  It prevents you from losing more than a limited amount
of work if the system crashes.

   When Emacs determines that it is time for auto-saving, each buffer is
considered, and is auto-saved if auto-saving is turned on for it and it
has been changed since the last time it was auto-saved.  If any
auto-saving is done, the message `Auto-saving...' is displayed in the
echo area until auto-saving is finished.  Errors occurring during
auto-saving are caught so that they do not interfere with the execution
of commands you have been typing.

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.


File: emacs,  Node: Auto Save Files,  Next: Auto Save Control,  Up: Auto Save

Auto-Save Files
---------------

   Auto-saving does not normally save in the files that you visited,
because it can be very undesirable to save a program that is in an
inconsistent state when you have made half of a planned change.
Instead, auto-saving is done in a different file called the "auto-save
file", and the visited file is changed only when you request saving
explicitly (such as with `C-x C-s').

   Normally, the auto-save file name is made by appending `#' to the
front and rear of the visited file name.  Thus, a buffer visiting file
`foo.c' is auto-saved in a file `#foo.c#'.  Most buffers that are not
visiting files are auto-saved only if you request it explicitly; when
they are auto-saved, the auto-save file name is made by appending `#%'
to the front and `#' to the rear of buffer name.  For example, the
`*mail*' buffer in which you compose messages to be sent is auto-saved
in a file named `#%*mail*#'.  Auto-save file names are made this way
unless you reprogram parts of Emacs to do something different (the
functions `make-auto-save-file-name' and `auto-save-file-name-p').  The
file name to be used for auto-saving in a buffer is calculated when
auto-saving is turned on in that buffer.

   When you delete a substantial part of the text in a large buffer,
auto save turns off temporarily in that buffer.  This is so that if you
delete text accidentally, it is likely to remain present in the auto
save file.  To reenable auto-saving after this happens, simply save the
file explicitly with `C-x C-s'.  Using `C-u 1 M-x auto-save-mode' also
cancels this particular state.

   If you want auto-saving to be done in the visited file, set the
variable `auto-save-visited-file-name' to be non-`nil'.  In this mode,
there is really no difference between auto-saving and explicit saving.

   A buffer's auto-save file is deleted when you save the buffer in its
visited file.  To inhibit this, set the variable
`delete-auto-save-files' to `nil'.  Changing the visited file name with
`C-x C-w' or `set-visited-file-name' renames any auto-save file to go
with the new visited name.

   When you delete a large amount of a buffer's text, auto-saving turns
off in that buffer.  This is because if you deleted the text
unintentionally, you might find the auto-save file more useful if it
contains the deleted text.  To restart auto-saving in that buffer, use
`M-x auto-save' with a positive argument.


File: emacs,  Node: Auto Save Control,  Next: Recover,  Prev: Auto Save Files,  Up: Auto Save

Controlling Auto-Saving
-----------------------

   Each time you visit a file, auto-saving is turned on for that file's
buffer if the variable `auto-save-default' is non-`nil' (but not in
batch mode; *note Entering Emacs::.).  The default for this variable is
`t', so auto-saving is the usual practice for file-visiting buffers.
Auto-saving can be turned on or off for any existing buffer with the
command `M-x auto-save-mode'.  Like other minor mode commands, `M-x
auto-save-mode' turns auto-saving on with a positive argument, off with
a zero or negative argument; with no argument, it toggles.

   Emacs does auto-saving periodically based on counting how many
characters you have typed since the last time auto-saving was done.
The variable `auto-save-interval' specifies how many characters there
are between auto-saves.  By default, it is 300.

   Auto-saving also takes place when you stop typing for a while.  The
variable `auto-save-timeout' says how many seconds Emacs should wait
before it does an auto save (and perhaps also a garbage collection).
(The actual time period is longer if the current buffer is long; this
is a heuristic which aims to keep out of your way when you are editing
long buffers in which auto-save takes an appreciable amount of time.)
Auto-saving during idle periods accomplishes two things: first, it
makes sure all your work is saved if you go away from the terminal for
a while; second, it may avoid some auto-saving while you are actually
typing.

   Emacs also does auto-saving whenever it gets a fatal error.  This
includes killing the Emacs job with a shell command such as `kill
%emacs', or disconnecting a phone line or network connection.

   You can request an auto-save explicitly with the command `M-x
do-auto-save'.

