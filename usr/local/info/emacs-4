This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

Help by Command or Variable Name
================================

   `C-h f' (`describe-function') reads the name of a Lisp function
using the minibuffer, then displays that function's documentation string
in a window.  Since commands are Lisp functions, you can use this to get
the documentation of a command that is known by name.  For example,

     C-h f auto-fill-mode RET

displays the documentation of `auto-fill-mode'.  This is the only way
to get the documentation of a command that is not bound to any key (one
which you would normally run using `M-x').

   `C-h f' is also useful for Lisp functions that you are planning to
use in a Lisp program.  For example, if you have just written the
expression `(make-vector len)' and want to check that you are using
`make-vector' properly, type `C-h f make-vector RET'.  Because `C-h f'
allows all function names, not just command names, you may find that
some of your favorite abbreviations that work in `M-x' don't work in
`C-h f'.  An abbreviation may be unique among command names yet fail to
be unique when other function names are allowed.

   The function name for `C-h f' to describe has a default which is
used if you type RET leaving the minibuffer empty.  The default is the
function called by the innermost Lisp expression in the buffer around
point, *provided* that is a valid, defined Lisp function name.  For
example, if point is located following the text `(make-vector (car x)',
the innermost list containing point is the one that starts with
`(make-vector', so the default is to describe the function
`make-vector'.

   `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a default in the
prompt, you have typed the name of a defined Lisp function.  If that is
all you want to know, just type `C-g' to cancel the `C-h f' command,
then go on editing.

   `C-h w COMMAND RET' tells you what keys are bound to COMMAND.  It
prints a list of the keys in the echo area.  If it says the command is
not on any key, you must use `M-x' to run it.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, but only if that is the name of a known Lisp
variable.  *Note Variables::.


File: emacs,  Node: Apropos,  Next: Library Keywords,  Prev: Name Help,  Up: Help

Apropos
=======

   A more sophisticated sort of question to ask is, "What are the
commands for working with files?"  To ask this question, type `C-h a
file RET', which displays a list of all command names that contain
`file', including `copy-file', `find-file', and so on.  With each
command name appears a brief description of how to use the command, and
what keys you can currently invoke it with.  For example, it would say
that you can invoke `find-file' by typing `C-x C-f'.  The `a' in `C-h
a' stands for `Apropos'; `C-h a' runs the command `command-apropos'.

   Because `C-h a' looks only for functions whose names contain the
string which you specify, you must use ingenuity in choosing the
string.  If you are looking for commands for killing backwards and `C-h
a kill-backwards RET' doesn't reveal any, don't give up.  Try just
`kill', or just `backwards', or just `back'.  Be persistent.  Also note
that you can use a regular expression as the argument, for more
flexibility (*note Regexps::.).

   Here is a set of arguments to give to `C-h a' that covers many
classes of Emacs commands, since there are strong conventions for naming
the standard Emacs commands.  By giving you a feel for the naming
conventions, this set should also serve to aid you in developing a
technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, file, dir, register, mode,
     beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe.

   To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h a'.  This command does not check key bindings by
default; specify a numeric argument if you want it to check them.

   The `super-apropos' command is like `apropos' except that it
searches documentation strings as well as symbol names for matches for
the specified regular expression.


File: emacs,  Node: Library Keywords,  Next: Misc Help,  Prev: Apropos,  Up: Help

Keyword Search for Lisp Libraries
=================================

   The `C-h p' command lets you search the standard Emacs Lisp
libraries by topic keywords.  Here is a partial list of keywords you can
use:

`abbrev'
     Abbreviation handling, typing shortcuts, macros.

`bib'
     Support for the bibliography processor `bib'.

`c'
     C and C++ language support.

`calendar'
     Calendar and time management support.

`comm'
     Communications, networking, remote access to files.

`docs'
     Support for Emacs documentation.

`emulations'
     Emulations of other editors.

`extensions'
     Emacs Lisp language extensions.

`faces'
     Support for using faces (fonts and colors; *note Faces::.).

`games'
     Games, jokes and amusements.

`hardware'
     Support for interfacing with exotic hardware.

`help'
     Support for on-line help systems.

`i18n'
     Internationalization and alternate character-set support.

`internal'
     Code for Emacs internals, build process, defaults.

`languages'
     Specialized modes for editing programming languages.

`lisp'
     Support for using Lisp (including Emacs Lisp).

`local'
     Libraries local to your site.

`maint'
     Maintenance aids for the Emacs development group.

`mail'
     Modes for electronic-mail handling.

`news'
     Support for netnews reading and posting.

`non-text'
     Support for editing files that are not ordinary text.

`processes'
     Process, subshell, compilation, and job control support.

`terminals'
     Support for terminal types.

`tex'
     Support for the TeX formatter.

`tools'
     Programming tools.

`unix'
     Front-ends/assistants for, or emulators of, Unix features.

`vms'
     Support code for VMS.

`wp'
     Word processing.


File: emacs,  Node: Misc Help,  Prev: Library Keywords,  Up: Help

Other Help Commands
===================

   `C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire Emacs manual is
available within Info.  Eventually all the documentation of the GNU
system will be available.  Type `h' after entering Info to run a
tutorial on using Info.

   There are two special help commands for accessing Emacs documentation
through Info.  `C-h C-f FUNCTION RET' enters Info and goes straight to
the documentation of the Emacs function FUNCTION.  `C-h C-k KEY' enters
Info and goes straight to the documentation of the key KEY.  These two
keys run the commands `Info-goto-emacs-command-node' and
`Info-goto-emacs-key-command-node'.

   If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed in.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

   Emacs has numerous major modes, each of which redefines a few keys
and makes a few other changes in how editing works.  `C-h m'
(`describe-mode') prints documentation on the current major mode, which
normally describes all the commands that are changed in this mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax')
present other information about the current Emacs mode.  `C-h b'
displays a list of all the key bindings now in effect; the local
bindings defined by the current minor modes first, then the local
bindings defined by the current major mode, and finally the global
bindings (*note Key Bindings::.).  `C-h s' displays the contents of the
syntax table, with explanations of each character's syntax (*note
Syntax::.).

   You can get a similar list for a particular prefix key by typing
`C-h' after the prefix key.  (There are a few prefix keys for which
this does not work--those that provide their own bindings for `C-h'.
One of these is ESC, because `ESC C-h' is actually `C-M-h', which marks
a defun.)

   The other `C-h' options display various files of useful information.
`C-h C-w' displays the full details on the complete absence of warranty
for GNU Emacs.  `C-h n' (`view-emacs-news') displays the file
`emacs/etc/NEWS', which contains documentation on Emacs changes
arranged chronologically.  `C-h t' (`help-with-tutorial') displays the
learn-by-doing Emacs tutorial.  `C-h C-c' (`describe-copying') displays
the file `emacs/etc/COPYING', which tells you the conditions you must
obey in distributing copies of Emacs.  `C-h C-d'
(`describe-distribution') displays the file `emacs/etc/DISTRIB', which
tells you how you can order a copy of the latest version of Emacs.


File: emacs,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

The Mark and the Region
***********************

   There are many Emacs commands which operate on an arbitrary
contiguous part of the current buffer.  To specify the text for such a
command to operate on, you set "the mark" at one end of it, and move
point to the other end.  The text between point and the mark is called
"the region".  You can move point or the mark to adjust the boundaries
of the region.  It doesn't matter which one is set first
chronologically, or which one comes earlier in the text.

   Once the mark has been set, it remains where you put it until it is
set again at another place.  The mark remains fixed with respect to the
preceding character if text is inserted or deleted in the buffer.  Each
Emacs buffer has its own mark, so that when you return to a buffer that
had been selected previously, it has the same mark it had before.

   Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position point and the mark at opposite ends of the
inserted text, so that the region contains the text just inserted.

   Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark in the "mark ring".

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region-
			  when there is one.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.


File: emacs,  Node: Setting Mark,  Next: Transient Mark,  Up: Mark

Setting the Mark
================

   Here are some commands for setting the mark:

`C-SPC'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

   For example, suppose you wish to convert part of the buffer to all
upper-case, using the `C-x C-u' (`upcase-region') command which
operates on the text in the region.  You can first go to the beginning
of the text to be capitalized, type `C-SPC' to put the mark there, move
to the end, and then type `C-x C-u'.  Or, you can set the mark at the
end of the text, move to the beginning, and then type `C-x C-u'.

   The most common way to set the mark is with the `C-SPC' command
(`set-mark-command').  This sets the mark where point is.  Then you can
move point away, leaving the mark behind.

   Ordinary terminals have only one cursor, so there is no way for Emacs
to show you where the mark is located.  You have to remember.  The usual
solution to this problem is to set the mark and then use it soon, before
you forget where it is.  Alternatively, you can see where the mark is
with the command `C-x C-x' (`exchange-point-and-mark') which puts the
mark where point was and point where the mark was.  The extent of the
region is unchanged, but the cursor and point are now at the previous
position of the mark.

   `C-x C-x' is also useful when you are satisfied with the position of
point but want to move the mark; do `C-x C-x' to put point at that end
of the region, and then move it.  A second use of `C-x C-x', if
necessary, puts the mark at the new position with point back at its
original position.

   There is no such character as `C-SPC' in ASCII; when you type SPC
while holding down CTRL, what you get on most ordinary terminals is the
character `C-@'.  This key is actually bound to `set-mark-command'.
But unless you are unlucky enough to have a terminal where typing
`C-SPC' does not produce `C-@', you might as well think of this
character as `C-SPC'.  Under X, `C-SPC' is actually a distinct
character, but its binding is still `set-mark-command'.


File: emacs,  Node: Transient Mark,  Next: Using Region,  Prev: Setting Mark,  Up: Mark

Transient Mark Mode
===================

   Many Emacs commands move the mark and invisibly set new regions.
This means that there is almost always some region that you can act on.
This is convenient, provided you get used to keeping track of the
mark's position.

   Some people prefer a more rigid mode of operation in which you must
set up a region for each command that uses one--in which the region
"lasts" only temporarily.  This is called Transient Mark mode.  It is
particularly well-suited to window systems such as X, since Emacs can
highlight the region when it is active.

   To enable Transient Mark mode, type `M-x transient-mark-mode'.  This
command toggles the mode, so you can issue it again to return to the
normal Emacs way of handling the mark and the region.

   Here are the details of Transient Mark mode:

   * To set the mark, type `C-SPC' (`set-mark-command').  This makes
     the mark active; as you move point, you will see the region
     highlighting change in extent.

   * On a window system, an easy way to select a region is to press the
     button Mouse-1 (normally the left button) at one end of it, drag
     the mouse to the other end, and then release the button.

   * When the mark is active, you can execute any commands you want on
     the region, such as killing, indentation, or writing to a file.

   * Any change to the buffer, such as inserting or deleting a
     character, deactivates the mark.  This means any subsequent
     command that operates on a region will get an error and refuse to
     operate.  You can make the region active again by typing `C-x C-x'.

   * Commands like `M->' that "leave the mark behind" do not activate
     the new mark.  You can activate the new region by executing `C-x
     C-x' (`exchange-point-and-mark').

   * Quitting with `C-g' deactivates the mark.

   Transient Mark mode is also sometimes known as "Zmacs mode" because
the Zmacs editor on the MIT Lisp Machine handled the mark in a similar
way.

   When multiple windows show the same buffer, they can have different
regions, because they can have different values of point.  In Transient
Mark mode, each window highlights its own region.  The part that is
highlighted in the selected window is the region that editing commands
use.  *Note Windows::.


File: emacs,  Node: Using Region,  Next: Marking Objects,  Prev: Transient Mark,  Up: Mark

Operating on the Region
=======================

   Once you have set up a region and the mark is active, you can do many
things to the text in it:

   * Kill it with `C-w' (*note Killing::.).

   * Save it in a register with `C-x r s' (*note Registers::.).

   * Save it in a buffer or a file (*note Accumulating Text::.).

   * Convert case with `C-x C-l' or `C-x C-u' (*note Case::.).

   * Indent it with `C-x TAB' or `C-M-\' (*note Indentation::.).

   * Fill it as text with `M-x fill-region' (*note Filling::.).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::.).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::.).

   Most commands that operate on the text in the region have the word
`region' in their names.


File: emacs,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
================================

   Here are the commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next Lisp expression.
These commands handle arguments just like `M-f' and `C-M-f'.

   Other commands set both point and mark, to delimit an object in the
buffer.  For example, `M-h' (`mark-paragraph') moves point to the
beginning of the paragraph that surrounds or follows point, and puts
the mark at the end of that paragraph (*note Paragraphs::.).  It
prepares the region so you can indent, case-convert, or kill a whole
paragraph.

   `C-M-h' (`mark-defun') similarly puts point before and the mark
after the current or following defun (*note Defuns::.).  `C-x C-p'
(`mark-page') puts point before the current page, and mark at the end
(*note Pages::.).  The mark goes after the terminating page delimiter
(to include it), while point goes after the preceding page delimiter
(to exclude it).  A numeric argument specifies a later page (if
positive) or an earlier page (if negative) instead of the current page.

   Finally, `C-x h' (`mark-whole-buffer') sets up the entire buffer as
the region, by putting point at the beginning and the mark at the end.


File: emacs,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
=============

   Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark, in the "mark ring".  Commands that set the mark also push the old
mark onto this ring.  To return to a marked location, use `C-u C-SPC'
(or `C-u C-@'); this is the command `set-mark-command' given a numeric
argument.  It moves point to where the mark was, and restores the mark
from the ring of former marks.  Thus, repeated use of this command
moves point to all of the old marks on the ring, one by one.  The mark
positions you move through in this way are not lost; they go to the end
of the ring.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-SPC' always stays in
the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This is to make it easier for you to move back
later.  Searches set the mark if they move point.  You can tell when a
command sets the mark because it displays `Mark Set' in the echo area.

   If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (*note RegPos::.).

   The variable `mark-ring-max' specifies the maximum number of entries
to keep in the mark ring.  If that many entries exist and another one
is pushed, the last one in the list is discarded.  Repeating `C-u
C-SPC' circulates through the positions currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: emacs,  Node: Global Mark Ring,  Prev: Mark Ring,  Up: Mark

The Global Mark Ring
====================

   Each Emacs buffer has its own mark ring.  In addition, Emacs has a
single "global mark ring".

   The global mark ring stores positions in various Emacs buffers.
Setting the mark always makes an entry on the current buffer's mark
ring.  If you have switched buffers since the previous mark setting, the
new mark position makes an entry on the global mark ring also.  The
result is that the global mark ring holds a sequence of buffers that you
have been in, and for each buffer, it records a place where you set the
mark.

   The command `C-x C-SPC' (`pop-global-mark') jumps to the buffer and
position of the latest entry in the global ring.  It also rotates the
ring, so that successive uses of `C-x C-SPC' take you to earlier and
earlier buffers.


File: emacs,  Node: Killing,  Next: Yanking,  Prev: Mark,  Up: Top

Deletion and Killing
====================

   Most commands which erase text from the buffer save it in the kill
ring so that you can move or copy it to other parts of the buffer.
These commands are known as "kill" commands.  The rest of the commands
that erase text do not save it in the kill ring; they are known as
"delete" commands.  (This distinction is made only for erasure of text
in the buffer.)  If you do a kill or delete command by mistake, you can
use the `C-x u' (`undo') command to undo it (*note Undo::.).

   The delete commands include `C-d' (`delete-char') and DEL
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can destroy significant amounts of nontrivial data generally kill.  The
commands' names and individual descriptions use the words `kill' and
`delete' to say which they do.

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.


File: emacs,  Node: Deletion,  Next: Killing by Lines,  Up: Killing

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`DEL'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-SPC'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, along with any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and DEL
(`delete-backward-char').  `C-d' deletes the character after point, the
one the cursor is "on top of".  This doesn't move point.  DEL deletes
the character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and DEL aren't always delete
commands; when given arguments, they kill instead, since they can erase
more than one character this way.

   The other delete commands are those which delete only whitespace
characters: spaces, tabs and newlines.  `M-\'
(`delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  `M-SPC' (`just-one-space') does likewise but
leaves a single space after point, regardless of the number of spaces
that existed previously (even zero).

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line.  If the current line is blank, it deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).

   `M-^' (`delete-indentation') joins the current line and the previous
line, by deleting a newline and all surrounding spaces, usually leaving
a single space.  *Note M-^: Indentation.


File: emacs,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Killing

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving it blank.  When used
on a blank line, it kills the whole line including its newline.  To kill
an entire non-blank line, go to the beginning and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following point, thus merging the next line into the current one.
Spaces and tabs that you can't see at the end of the line are ignored
when deciding which case applies, so if point appears to be at the end
of the line, you can be sure `C-k' will kill the newline.

   When `C-k' is given a positive argument, it kills that many lines
and the newlines that follow them (however, text on the current line
before point is spared).  With a negative argument -N, it kills N lines
preceding the current line (together with the text on the current line
before point).  Thus, `C-u - 2 C-k' at the front of a line kills the
two previous lines.

   `C-k' with an argument of zero kills the text before point on the
current line.

   If the variable `kill-whole-line' is non-`nil', `C-k' at the very
beginning of a line kills the entire line including the following
newline.  This variable is normally `nil'.


File: emacs,  Node: Other Kill Commands,  Prev: Killing by Lines,  Up: Killing

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').

`M-d'
     Kill word (`kill-word').  *Note Words::.

`M-DEL'
     Kill word backwards (`backward-kill-word').

`C-x DEL'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill through the next occurrence of CHAR (`zap-to-char').

   A kill command which is very general is `C-w' (`kill-region'), which
kills everything between point and the mark.  With this command, you
can kill any contiguous sequence of characters, if you first set the
region around them.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (and
including) the next occurrence of that character in the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-DEL' and `M-d'
(*note Words::.); sexps, with `C-M-k' (*note Lists::.); and sentences,
with `C-x DEL' and `M-k' (*note Sentences::.).

   You can use kill commands in read-only buffers.  They don't actually
change the buffer, and they beep to warn you of that, but they do copy
the text you tried to kill into the kill ring, so you can yank it into
other buffers.  Most of the kill commands move point across the text
they copy in this way, so that successive kill commands add text to the
most recent kill-ring entry just as they would if they were really
killing the text.


File: emacs,  Node: Yanking,  Next: Accumulating Text,  Prev: Killing,  Up: Top

Yanking
=======

   "Yanking" means reinserting text previously killed.  This is what
some systems call "pasting".  The usual way to move or copy text is to
kill it and then yank it elsewhere one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace text just yanked with an earlier batch of killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`kill-ring-save').

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.


File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Up: Yanking

The Kill Ring
-------------

   All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This is only if the argument is specified with just a `C-u',
precisely.  Any other sort of argument, including `C-u' and digits,
specifies an earlier kill to yank (*note Earlier Kills::.).

   If you wish to copy a block of text, you might want to use `M-w'
(`kill-ring-save'), which copies the region into the kill ring without
removing it from the buffer.  This is approximately equivalent to `C-w'
followed by `C-x u', except that `M-w' does not alter the undo history
and does not temporarily change the screen.


File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

   Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' gets it all back as it was before
it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains

     This is a line -!-of sample text.

with point as shown.  If you type `M-d M-DEL M-d M-DEL', killing
alternately forward and backward, you end up with `a line of sample' as
one entry in the kill ring, and `This is  text.' in the buffer.  (Note
the double space, which you can clean up with `M-SPC' or `M-q'.)

   Another way to kill the same text is to move back two words with
`M-b M-b', then kill all four words forward with `C-u M-d'.  This
produces exactly the same results in the buffer and in the kill ring.
`M-f M-f C-u M-DEL' kills the same text, all going backward; once
again, the result is the same.  The text in the kill ring entry always
has the same order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
`C-M-w' (`append-next-kill') right before it.  The `C-M-w' tells the
following command, if it is a kill command, to append the text it kills
to the last killed text, instead of starting a new entry.  With
`C-M-w', you can kill several separated pieces of text and accumulate
them to be yanked back in one place.


File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

   To recover killed text that is no longer the most recent kill, use
the `M-y' command (`yank-pop').  It takes the text previously yanked
and replaces it with the text from an earlier kill.  So, to recover the
text of the next-to-the-last kill, first use `C-y' to yank the last
kill, and then use `M-y' to replace it with the previous kill.  `M-y'
is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
moves it to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the "last yank"
pointer remains at the same place in the kill ring, so repeating `C-y'
will yank another copy of the same previous kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument restores the text the specified
number of entries back in the kill ring.  Thus, `C-u 2 C-y' gets the
next to the last block of killed text.  It is equivalent to `C-y M-y'.
`C-y' with a numeric argument starts counting from the "last yank"
pointer, and sets the "last yank" pointer to the entry that it yanks.

   The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are saved.

   The actual contents of the kill ring are stored in a variable named
`kill-ring'; you can view the entire contents of the kill ring with the
command `C-h v kill-ring'.


File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Yanking,  Up: Top

Accumulating Text
=================

   Usually we copy or move text by killing it and yanking it, but there
are other methods convenient for copying one block of text in many
places, or for copying many scattered blocks of text into one place.  To
copy one block to many places, store it in a register (*note
Registers::.).  Here we describe the commands to accumulate scattered
pieces of text into a buffer or into a file.

`M-x append-to-buffer'
     Append region to contents of specified buffer.

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to contents of specified file, at the end.

   To accumulate text into a buffer, use `M-x append-to-buffer'.  This
reads a buffer name, them inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, `append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, wherever point happens
to be in it.

   Point in that buffer is left at the end of the copied text, so
successive uses of `append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, `append-to-buffer' does not always append to the text already
in the buffer--only if point in that buffer is at the end.  However, if
`append-to-buffer' is the only command you use to alter a buffer, then
point is always at the end.

   `M-x prepend-to-buffer' is just like `append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is similar
except that any existing text in the other buffer is deleted, so the
buffer is left containing just the text newly copied into it.

   To retrieve the accumulated text from another buffer, use `M-x
insert-buffer'; this too takes BUFFERNAME as an argument.  It inserts a
copy of the text in buffer BUFFERNAME into the selected buffer.  You
can alternatively select the other buffer for editing, then optionally
move text from it by killing.  *Note Buffers::, for background
information on buffers.

   Instead of accumulating text within Emacs, in a buffer, you can
append text directly into a file with `M-x append-to-file', which takes
FILENAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.

   You should use `append-to-file' only with files that are *not* being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing
some of your editing.


File: emacs,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

   The rectangle commands operate on rectangular areas of the text: all
the characters between a certain pair of columns, in a certain range of
lines. Commands are provided to kill rectangles, yank killed rectangles,
clear them out, fill them with blanks or text, or delete them. Rectangle
commands are useful with text in multicolumn formats, and for changing
text into or out of such formats.

   When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner.  The
rectangle thus specified is called the "region-rectangle" because you
control it in about the same way the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as a region or as a rectangle, depending on the
command that uses them.

   If point and the mark are in the same column, the rectangle they
delimit is empty.  If they are in the same line, the rectangle is one
line high.  This asymmetry between lines and columns comes about
because point (and likewise the mark) is between two columns, but within
a line.

`C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     "last killed rectangle" (`kill-rectangle').

`C-x r d'
     Delete the text of the region-rectangle (`delete-rectangle').

`C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     (`yank-rectangle').

`C-x r o'
     Insert blank space to fill the space of the region-rectangle
     (`open-rectangle').  This pushes the previous contents of the
     region-rectangle rightward.

`M-x delete-rectangle'
     Delete the text of the region-rectangle without saving it in any
     special way.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

`M-x string-rectangle RET STRING RET'
     Insert STRING on each line of the region-rectangle.

   The rectangle operations fall into two classes: commands deleting and
inserting rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `C-x r d' (`delete-rectangle') and
`C-x r k' (`kill-rectangle').  In either case, the portion of each line
that falls inside the rectangle's boundaries is deleted, causing
following text (if any) on the line to move left into the gap.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that can only record the most recent rectangle killed.  This is because
yanking a rectangle is so different from yanking linear text that
different yank commands have to be used and yank-popping is hard to
make sense of.

   Yanking a rectangle is the opposite of killing one.  Point specifies
where to put the rectangle's upper left corner.  The rectangle's first
line is inserted there, the rectangle's second line is inserted at a
point one line vertically down, and so on.  The number of lines affected
is determined by the height of the saved rectangle.

   To yank the last killed rectangle, type `C-x r y'
(`yank-rectangle').  This can be used to convert single-column lists
into double-column lists; kill the second half of the list as a
rectangle and then yank it beside the first line of the list.

   You can also copy rectangles into and out of registers with `C-x r r
R' and `C-x r i R'.  *Note Rectangle Registers: RegRect.

   The command `M-x string-rectangle' is similar to `C-x r o', but it
inserts a specified string instead of blanks.  You specify the string
with the minibuffer.  Since the length of the string specifies how many
columns to insert, the width of the region-rectangle does not matter
for this command.  What does matter is the position of the left edge
(which specifies the column position for the insertion in each line)
and the range of lines that the rectangle occupies.  The previous
contents of the text after the insertion column are pushed rightward.

   There are two commands for making with blank rectangles: `M-x
clear-rectangle' to blank out existing text, and `C-x r o'
(`open-rectangle') to insert a blank rectangle.  Clearing a rectangle
is equivalent to deleting it and then inserting a blank rectangle of
the same size.


File: emacs,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

   Emacs "registers" are places you can save text or positions for
later use.  Text and rectangles saved in registers can be copied into
the buffer once or many times; you can move point to a position saved in
a register.

   Each register has a name which is a single character.  A register can
store a piece of text, a rectangle, a position, a window configuration
or a file name, but only one thing at any given time.  Whatever you
store in a register remains there until you store something else in that
register.  To see what a register R contains, use `M-x view-register'.

`M-x view-register RET R'
     Display a description of what register R contains.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: emacs,  Node: RegPos,  Next: RegText,  Up: Registers

Saving Positions in Registers
=============================

   Saving a position records a spot in a buffer so that you can move
back there later.  Moving to a saved position reselects that buffer and
moves point to that spot.

`C-x r SPC R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r SPC R'.  The register R retains the position thus saved
until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to record the
same position.  You can jump to the same position using the same
register any number of times.


File: emacs,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

   When you want to insert a copy of the same piece of text several
times, it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r i R'
     Insert text from register R (`insert-register').

   `C-x r s R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x r s R' deletes the
text from the buffer as well.

   `C-x r i R' inserts in the buffer the text from register R.
Normally it leaves point before the text and places the mark after, but
with a numeric argument (`C-u') it puts point after the text and the
mark before.


File: emacs,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

   A register can contain a rectangle instead of linear text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on how to specify a rectangle in the buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-region-to-rectangle').  With numeric argument, delete it as
     well.

`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts a text string if the register
contains one, and inserts a rectangle if the register contains one.


File: emacs,  Node: RegConfig,  Next: RegFiles,  Prev: RegRect,  Up: Registers

Saving Window Configurations in Registers
=========================================

   You can save the window configuration of the selected frame in a
register, or even the configuration of all frames, and restore the
configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`C-x r f R'
     Save the state of all windows in all frames in register R
     (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: emacs,  Node: RegFiles,  Next: Bookmarks,  Prev: RegConfig,  Up: Registers

Keeping File Names in Registers
===============================

   If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)

