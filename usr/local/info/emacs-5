This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Bookmarks,  Prev: RegFiles,  Up: Registers

Bookmarks
=========

   "Bookmarks" are somewhat like registers in that they record
positions you can jump to.  Unlike registers, they have long names, and
they persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

`C-x r m RET'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK RET'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK RET'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks'.

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions.  Type `C-h m' in that buffer
for more information about its special editing commands.

   When you kill Emacs, Emacs offers to save your bookmark values in
your default bookmark file, `~/.emacs-bkmrks', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one Emacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if Emacs crashes.

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record, on each side of the bookmark's
position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load RET FILENAME RET'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write RET FILENAME RET'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete RET BOOKMARK RET'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-locate RET BOOKMARK RET'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert RET BOOKMARK RET'
     Insert in the buffer the *contents* of the file that bookmark
     BOOKMARK points to.


File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

   Since only part of a large buffer fits in the window, Emacs tries to
show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the text you want to see.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`NEXT'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`PRIOR'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

`C-x $'
     Make deeply indented lines invisible (`set-selective-display').

   The names of all scroll commands are based on the direction that the
text moves in the window.  Thus, the command to scrolling forward is
called `scroll-up', since the text moves up.

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Display::       Optional display features.
* European Display::	   Displaying (and inputing) European characters.
* Display Vars::           Information on variables for customizing display.


File: emacs,  Node: Scrolling,  Next: Horizontal Scrolling,  Up: Display

Scrolling
=========

   If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous portion
of the text.  The portion shown always contains point.

   "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means that
text moves up, and new text appears at the bottom.  Scrolling backward
moves text down and new text appears at the top.

   Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also explicitly request scrolling with the
commands in this section.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`NEXT'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`PRIOR'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-M-l'
     Scroll heuristically to bring useful information onto the screen
     (`reposition-window').

   The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire screen and redisplays all windows.  In
addition, it scrolls the selected window so that point is halfway down
from the top of the window.

   The scrolling commands `C-v' and `M-v' let you move all the text in
the window up or down a few lines.  `C-v' (`scroll-up') with an
argument shows you that many more lines at the bottom of the window,
moving the text and point up together as `C-l' might.  `C-v' with a
negative argument shows you more lines at the top of the window.  `M-v'
(`scroll-down') is like `C-v', but moves in the opposite direction.
The function keys NEXT and PRIOR are equivalent to `C-v' and `M-v'.

   To read the buffer a windowful at a time, use `C-v' with no argument.
It takes the last two lines at the bottom of the window and puts them at
the top, followed by nearly a whole windowful of lines not previously
visible.  If point was in the text scrolled off the top, it moves to the
new top of the window.  `M-v' with no argument moves backward with
overlap similarly.  The number of lines of overlap across a `C-v' or
`M-v' is controlled by the variable `next-screen-context-lines'; by
default, it is two.

   Another way to do scrolling is with `C-l' with a numeric argument.
`C-l' does not clear the screen when given an argument; it only scrolls
the selected window.  With a positive argument N, it repositions text
to put point N lines down from the top.  An argument of zero puts point
on the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the screen.  `C-l' with a
negative argument puts point that many lines from the bottom of the
window.  For example, `C-u - 1 C-l' puts point on the bottom line, and
`C-u - 5 C-l' puts it five lines from the bottom.  Just `C-u' as
argument, as in `C-u C-l', scrolls point to the center of the screen.

   The `C-M-l' command (`reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.

   Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually the scrolling
is done so as to put point vertically centered within the window.
However, if the variable `scroll-step' has a nonzero value, an attempt
is made to scroll the buffer by that many lines; if that is enough to
bring point back into visibility, that is what is done.


File: emacs,  Node: Horizontal Scrolling,  Next: Selective Display,  Prev: Scrolling,  Up: Display

Horizontal Scrolling
====================

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

   The text in a window can also be scrolled horizontally.  This means
that each line of text is shifted sideways in the window, and one or
more characters at the beginning of each line are not displayed at all.
When a window has been scrolled horizontally in this way, text lines
are truncated rather than continued (*note Continuation Lines::.), with
a `$' appearing in the first column when there is text truncated to the
left, and in the last column when there is text truncated to the right.

   The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  This moves part of the
beginning of each line off the left edge of the window.  With no
argument, it scrolls by almost the full width of the window (two
columns less, to be precise).

   `C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displaying
normally (with each line starting at the window's left margin);
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for `C-x >'; any sufficiently large
argument will restore normally display.


File: emacs,  Node: Selective Display,  Next: Optional Display,  Prev: Horizontal Scrolling,  Up: Display

Selective Display
=================

   Emacs has the ability to hide lines indented more than a certain
number of columns (you specify how many columns).  You can use this to
get an overview of a part of a program.

   To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  Then lines with at least N columns of indentation
disappear from the screen.  The only indication of their presence is
that three dots (`...') appear at the end of each visible line that is
followed by one or more invisible ones.

   The commands `C-n' and `C-p' move across the invisible lines as if
they were not there.

   The invisible lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of
invisible text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make everything visible again, type `C-x $' with no argument.


File: emacs,  Node: European Display,  Next: Display Vars,  Prev: Optional Display,  Up: Display

European Character Set Display
==============================

   Emacs can display accented characters, assuming the font in use
supports them.  The `M-x standard-display-european' command toggles
European character display.  When enabled, Emacs displays characters
according to the ISO 8859 Latin-1 encoding for European languages; when
disabled, Emacs uses octal notation for all characters not specified by
the ordinary ASCII standard.  Load the library `iso-syntax' to specify
the correct syntactic properties for the character codes 128 and above.

   With a prefix argument, `M-x standard-display-european' enables
European character display if and only if the argument is positive.

   If your terminal can send character codes 128 and up to represent
ISO Latin-1 characters, execute the following expression to enable
Emacs to understand them:

     (set-input-mode (car (current-input-mode))
                     (nth 1 (current-input-mode))
                     0)

Otherwise, you can load the library `iso-transl' to turn the key `C-x
8' into a "compose character" prefix for entry of the extra ISO Latin-1
printing characters.  `C-x 8' is good for insertion (in the minibuffer
as well as other buffers), for searching, and in any other context
where a key sequence is allowed.  The ALT modifier key, if you have
one, serves the same purpose as `C-x 8'; use ALT together with an
accent character to modify the following letter.

   If you enter non-ASCII ISO Latin-1 characters often, you might find
ISO Accents mode convenient.  When this minor mode is enabled, the
characters ``', `'', `"', `^', `/' and `~' modify the following letter
by adding the corresponding diacritical mark to it, if possible.  To
enter one of those six special characters, type a space after it.

   Some of those characters have a corresponding "dead key" accent
character in the ISO Latin-1 character set; to enter that character,
type the corresponding ASCII character twice.  For example, `''' enters
the Latin-1 character acute-accent (character code 0264).

   In addition to the accented letters, you can use these special
sequences in ISO Accents mode to enter certain other ISO Latin-1
characters:

`/A'
     `A' with ring.

`~C'
     `C' with cedilla.

`~D'
     `D' with stroke.

`/E'
     `AE' ligature.

`/a'
     `a' with ring.

`~c'
     `c' with cedilla.

`~d'
     `d' with stroke.

`/e'
     `ae' ligature.

`"s'
     German sharp `s'.

`~<'
     Left guillemet.

`~>'
     Right guillemet.

   This feature is available whenever a key sequence is expected: for
ordinary insertion, for searching, and for certain command arguments.

   To enable or disable ISO Accents mode, use the command `M-x
iso-accents-mode'.  This command affects only the current buffer.


File: emacs,  Node: Optional Display,  Next: European Display,  Prev: Selective Display,  Up: Display

Optional Display Features
=========================

   To add the current line number of point to the mode line, enable Line
Number mode with the command `M-x line-number-mode'.  The line number
appears before POS, with the letter `L' to indicate what it is.  *Note
Minor Modes::, for more information about minor modes and about how to
use this command.

   If the buffer is very large (larger than the value of
`line-number-display-limit'), then the line number doesn't appear.
Emacs doesn't compute the line number when the buffer is large, because
that would be too slow.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time'.  The
information added to the mode line usually appears after the buffer
name, before the mode names and their parentheses.  It looks like this:

     HH:MMpm L.LL [D]

Here HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number of running processes in the whole
system recently.  D is an approximate index of the ratio of disk
activity to cpu activity for all users.  (Some fields may be missing if
your operating system cannot support them.)

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.

   Customization note: the variable `mode-line-inverse-video' controls
whether the mode line is displayed in inverse video (assuming the
terminal supports it); `nil' means no inverse video.  The default is
`t'.  *Note Display Vars::.


File: emacs,  Node: Display Vars,  Prev: European Display,  Up: Display

Variables Controlling Display
=============================

   This section contains information for customization only.  Beginning
users should skip it.

   The variable `mode-line-inverse-video' controls whether the mode
line is displayed in inverse video (assuming the terminal supports it);
`nil' means don't do so.  *Note Mode Line::.  If you specify the
foreground color for the `mode-line' face, and
`mode-line-inverse-video' is non-`nil', then the default background
color for that face is the usual foreground color.  *Note Faces::.

   If the variable `inverse-video' is non-`nil', Emacs attempts to
invert all the lines of the display from what they normally are.

   If the variable `visible-bell' is non-`nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a way
to make the screen blink.

   When you reenter Emacs after suspending, Emacs normally clears the
screen and redraws the entire display.  On some terminals with more than
one page of memory, it is possible to arrange the termcap entry so that
the `ti' and `te' strings (output to the terminal when Emacs is entered
and exited, respectively) switch between pages of memory so as to use
one page for Emacs and another page for other output.  Then you might
want to set the variable `no-redraw-on-reenter' non-`nil'; this tells
Emacs to assume, when resumed, that the screen page it is using still
contains what Emacs last wrote there.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero meaning don't echo at all.
*Note Echo Area::.

   If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, all except newline
and tab.  Altering the value of `ctl-arrow' makes it local to the
current buffer; until that time, the default value is in effect.  The
default is initially `t'.  *Note Display Tables: (elisp)Display Tables.

   Normally, a tab character in the buffer is displayed as whitespace
which extends to the next display tab stop position, and display tab
stops come at intervals equal to eight spaces.  The number of spaces
per tab is controlled by the variable `tab-width', which is made local
by changing it, just like `ctl-arrow'.  Note that how the tab character
in the buffer is displayed has nothing to do with the definition of TAB
as a command.  The variable `tab-width' must have an integer value
between 1 and 1000, inclusive.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots do not appear at the end of a line that precedes invisible
lines.  Then there is no visible indication of the invisible lines.
This variable too becomes local automatically when set.

   If the variable `truncate-lines' is non-`nil', then each line of
text gets just one screen line for display; if the text line is too
long, display shows only the part that fits.  If `truncate-lines' is
`nil', then long text lines display as more than one screen line,
enough to show the whole text of the line.  *Note Continuation Lines::.
Altering the value of `truncate-lines' makes it local to the current
buffer; until that time, the default value is in effect.  The default
is initially `nil'.

   If the variable `truncate-partial-width-windows' is non-`nil', it
forces truncation rather than continuation in any window less than the
full width of the screen or frame, regardless of the value of
`truncate-lines'.  For information about side-by-side windows, see
*Note Split Window::.  See also *Note Display: (elisp)Display.

   The variable `baud-rate' holds the the output speed of the terminal,
as far as Emacs knows.  Setting this variable does not change the speed
of actual data transmission, but the value is used for calculations
such as padding.  It also affects decisions about whether to scroll
part of the screen or redraw it instead--even when using a window
system.  (We designed it this way, despite the fact that a window
system has no true "output speed", to give you a way to tune these
decisions.)


File: emacs,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

Searching and Replacement
*************************

   Like other editors, Emacs has commands for searching for occurrences
of a string.  The principal search command is unusual in that it is
"incremental"; it begins to search before you have finished typing the
search string.  There are also nonincremental search commands more like
those of other editors.

   Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a
fancy replacement command called `query-replace' which asks
interactively which occurrences to replace.

* Menu:

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.


File: emacs,  Node: Incremental Search,  Next: Nonincremental Search,  Prev: Search,  Up: Search

Incremental Search
==================

   An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) would be
found.  When you have typed enough characters to identify the place you
want, you can stop.  Depending on what you plan to do next, you may or
may not need to terminate the search explicitly with RET.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

   `C-s' starts an incremental search.  `C-s' reads characters from the
keyboard and positions the cursor at the first occurrence of the
characters that you have typed.  If you type `C-s' and then `F', the
cursor moves right after the first `F'.  Type an `O', and see the
cursor move to after the first `FO'.  After another `O', the cursor is
after the first `FOO' after the place where you started the search.
Meanwhile, the search string `FOO' has been echoed in the echo area.

   If you make a mistake in typing the search string, you can cancel
characters with DEL.  Each DEL cancels the last character of search
string.  This does not happen until Emacs is ready to read another
input character; first it must either find, or fail to find, the
character you want to erase.  If you do not want to wait for this to
happen, use `C-g' as described below.

   When you are satisfied with the place you have reached, you can type
RET, which stops searching, leaving the cursor where the search brought
it.  Also, any command not specially meaningful in searches stops the
searching and is then executed.  Thus, typing `C-a' would exit the
search and then move to the beginning of the line.  RET is necessary
only if the next command you want to type is a printing character, DEL,
RET, or another control character that is special within searches
(`C-q', `C-w', `C-r', `C-s', `C-y', `M-y', `M-r', or `M-s').

   Sometimes you search for `FOO' and find it, but not the one you
expected to find.  There was a second `FOO' that you forgot about,
before the one you were looking for.  In this event, type another `C-s'
to move to the next occurrence of the search string.  This can be done
any number of times.  If you overshoot, you can cancel some `C-s'
characters with DEL.

   After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again".

   To reuse earlier search strings, use the "search ring".  The
commands `M-p' and `M-n' move through the ring to pick a search string
to reuse.  These commands leave the selected search ring element in the
minibuffer, where you can edit it.  Type `C-s' or `C-r' to terminate
editing the string and search for it.

   If your string is not found at all, the echo area says `Failing
I-Search'.  The cursor is after the place where Emacs found as much of
your string as it could.  Thus, if you search for `FOOT', and there is
no `FOOT', you might see the cursor after the `FOO' in `FOOL'.  At this
point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the
place you have found, you can type RET or some other Emacs command to
"accept what the search offered".  Or you can type `C-g', which removes
from the search string the characters that could not be found (the `T'
in `FOOT'), leaving those that were found (the `FOO' in `FOOT').  A
second `C-g' at that point cancels the search entirely, returning point
to where it was when the search started.

   An upper-case letter in the search string makes the search
case-sensitive.  If you delete the upper-case character from the search
string, it ceases to have this effect.  *Note Search Case::.

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with `C-r' starts again from the end.  This is
called "wrapping around".  `Wrapped' appears in the search prompt once
this has happened.

   The `C-g' "quit" character does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search.  The cursor moves back to where you started the search.
If `C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  With
them gone, the search is now successful and waiting for more input, so
a second `C-g' will cancel the entire search.

   To search for a newline, type LFD (also known as `C-j').  To search
for another control character such as control-S or carriage return, you
must quote it by typing `C-q' first.  This function of `C-q' is
analogous to its meaning as an Emacs command: it causes the following
character to be treated the way a graphic character would normally be
treated in the same context.  You can also specify a character by its
octal code: enter `C-q' followed by three octal digits.

   You can change to searching backwards with `C-r'.  If a search fails
because the place you started was too late in the file, you should do
this.  Repeated `C-r' keeps looking for more occurrences backwards.  A
`C-s' starts going forwards again.  `C-r' in a search can be cancelled
with DEL.

   If you know initially that you want to search backwards, you can use
`C-r' instead of `C-s' to start the search, because `C-r' is also a key
running a command (`isearch-backward') to search backward.

   The characters `C-y' and `C-w' can be used in incremental search to
grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the word after point as part of the search string, advancing
point over that word.  Another `C-s' to repeat the search will then
search for a string including that word.  `C-y' is similar to `C-w' but
copies all the rest of the current line into the search string.  Both
`C-y' and `C-w' convert the text they copy to lower case if the search
is current not case-sensitive; this is so the search remains
case-insensitive.

   The character `M-y' copies the most recent killed text into the
search string.

   To customize the special characters that incremental search
understands, alter their bindings in the keymap `isearch-mode-map'.

Slow Terminal Incremental Search
--------------------------------

   Incremental search on a slow terminal uses a modified style of
display that is designed to take less time.  Instead of redisplaying
the buffer at each place the search gets to, it creates a new
single-line window and uses that to display the line that the search
has found.  The single-line window comes into play as soon as point
gets outside of the text that is already on the screen.

   When you terminate the search, the single-line window is removed.
Then Emacs redisplays the window in which the search was done, to show
its new position of point.

   The slow terminal style of display is used when the terminal baud
rate is less than or equal to the value of the variable
`search-slow-speed', initially 1200.

   The number of lines to use in slow terminal search display is
controlled by the variable `search-slow-window-lines'.  1 is its normal
value.


File: emacs,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

Nonincremental Search
=====================

   Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

`C-s RET STRING RET'
     Search for STRING.

`C-r RET STRING RET'
     Search backward for STRING.

   To do a nonincremental search, first type `C-s RET'.  This enters
the minibuffer to read the search string; terminate the string with
RET, and then the search takes place.  If the string is not found, the
search command gets an error.

   The way `C-s RET' works is that the `C-s' invokes incremental
search, which is specially programmed to invoke nonincremental search
if the argument you give it is empty.  (Such an empty argument would
otherwise be useless.)  `C-r RET' also works this way.

   However, nonincremental searches performed using `C-s RET' do not
call `search-forward' right away.  The first thing done is to see if
the next character is `C-w', which requests a word search.  *Note Word
Search::.

   Forward and backward nonincremental searches are implemented by the
commands `search-forward' and `search-backward'.  These commands may be
bound to keys in the usual manner.  The feature that you can get to
them via the incremental search commands exists for historical reasons,
and to avoid the need to find suitable key sequences for them.


File: emacs,  Node: Word Search,  Next: Regexp Search,  Prev: Nonincremental Search,  Up: Search

Word Search
===========

   Word search searches for a sequence of words without regard to how
the words are separated.  More precisely, you type a string of many
words, using single spaces to separate them, and the string can be
found even if there are multiple spaces, newlines or other punctuation
between the words.

   Word search is useful for editing a printed document made with a text
formatter.  If you edit while looking at the printed, formatted version,
you can't tell where the line breaks are in the source file.  With word
search, you can search without having to know them.

`C-s RET C-w WORDS RET'
     Search for WORDS, ignoring details of punctuation.

`C-r RET C-w WORDS RET'
     Search backward for WORDS, ignoring details of punctuation.

   Word search is a special case of nonincremental search and is invoked
with `C-s RET C-w'.  This is followed by the search string, which must
always be terminated with RET.  Being nonincremental, this search does
not start until the argument is terminated.  It works by constructing a
regular expression and searching for that; see *Note Regexp Search::.

   Use `C-r RET C-w' to do backward word search.

   Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  These commands may
be bound to keys in the usual manner.  The feature that you can get to
them via the incremental search commands exists for historical reasons,
and to avoid the need to find suitable key sequences for them.


File: emacs,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

Regular Expression Search
=========================

   A "regular expression" ("regexp", for short) is a pattern that
denotes a class of alternative strings to match, possibly infinitely
many.  In GNU Emacs, you can search for the next match for a regexp
either incrementally or not.

   Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp').  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the
regexp longer, and the new regexp is searched for.  To search backward
in the buffer, use `C-M-r' (`isearch-backward-regexp').

   All of the control characters that do special things within an
ordinary incremental search have the same function in incremental regexp
search.  Typing `C-s' or `C-r' immediately after starting the search
retrieves the last incremental search regexp used; that is to say,
incremental regexp and non-regexp searches have independent defaults.
They also have separate search rings that you can access with `M-p' and
`M-n'.

   If you type SPC in incremental regexp search, it matches any
sequence of whitespace characters, including newlines.  If you want to
match just a space, type `C-q SPC'.

   Note that adding characters to the regexp in an incremental regexp
search can make the cursor move back and start again.  For example, if
you have searched for `foo' and you add `\|bar', the cursor backs up in
case the first `bar' precedes the first `foo'.

   Nonincremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke these
with `M-x', or bind them to keys, or invoke them by way of incremental
regexp search with `C-M-s RET' and `C-M-r RET'.


File: emacs,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that same character and
nothing else.  The special characters are `$', `^', `.', `*', `+', `?',
`[', `]' and `\'.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does *not* match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regexps also match `F' and `O', but we
consider this a generalization of "the same string", rather than an
exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b' which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator, which
     means to match the preceding regular expression repetitively as
     many times as possible.  Thus, `o*' matches any number of `o's
     (including no `o's).

     `*' always applies to the *smallest* possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     matching `ca*ar' against the string `caaar', the `a*' first tries
     to match all three `a's; but the rest of the pattern is `ar' and
     there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a postfix character, similar to `*' except that it must match
     the preceding expression at least once.  So, for example, `ca+r'
     matches the strings `car' and `caaaar' but not the string `cr',
     whereas `ca*r' matches all three strings.

`?'
     is a postfix character, similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' matches `car' or `cr'; nothing else.

`[ ... ]'
     is a "character set", which begins with `[' and is terminated by a
     `]'.  In the simplest case, the characters between the two
     brackets are what this set can match.

     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can also include character ranges a character set, by writing
     two characters with a `-' between them.  Thus, `[a-z]' matches any
     lower-case letter.  Ranges may be intermixed freely with individual
     characters, as in `[a-z$%.]', which matches any lower case letter
     or `$', `%' or period.

     Note that the usual special characters are not special any more
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' at the beginning or end of a range.  To include
     `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters *except* letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (`-' and `]' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as `grep'.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' which
     occurs at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `xx*$' matches a string of one `x' or more at the end of a line.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression which matches only `$', and `\[' is a regular
     expression which matches only `[', etc.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; better to quote the special character anyway,
regardless of where is appears.

   For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with `\' which have special meanings.  The second
character in the sequence is always an ordinary character on their own.
Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything that
     either A or B matches.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the scope of
     `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix operators
          `*', `+' and `?' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To mark a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature which is assigned
     as a second meaning to the same `\( ... \)' construct.  In practice
     there is no conflict between the two meanings.  Here is an
     explanation of this feature:

`\D'
     after the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in order that the open-parentheses appear in the regular
     expression.  `\1' through `\9' refer to the text previously
     matched by the corresponding `\( ... \)' construct.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

     If a particular `\( ... \)' construct matches more than once
     (which can easily happen if it is followed by `*'), only the last
     match is recorded.

`\`'
     matches the empty string, provided it is at the beginning of the
     buffer.

`\''
     matches the empty string, provided it is at the end of the buffer.

`\b'
     matches the empty string, provided it is at the beginning or end
     of a word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

`\B'
     matches the empty string, provided it is *not* at the beginning or
     end of a word.

`\<'
     matches the empty string, provided it is at the beginning of a
     word.

`\>'
     matches the empty string, provided it is at the end of a word.

`\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.

`\W'
     matches any character that is not a word-constituent.

`\sC'
     matches any character whose syntax is C.  Here C is a character
     which represents a syntax code: thus, `w' for word constituent,
     `(' for open-parenthesis, etc.  Represent a character of
     whitespace (which can be a newline) by either `-' or a space
     character.

`\SC'
     matches any character whose syntax is not C.

   The constructs that pertain to words and syntax are controlled by the
setting of the syntax table (*note Syntax::.).

   Here is a complicated regexp, used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is given in Lisp
syntax to enable you to distinguish the spaces from the tab characters.
In Lisp syntax, the string constant begins and ends with a
double-quote.  `\"' stands for a double-quote as part of the regexp,
`\\' for a backslash as part of the regexp, `\t' for a tab and `\n' for
a newline.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This contains four parts in succession: a character set matching period,
`?', or `!'; a character set matching close-brackets, quotes, or
parentheses, repeated any number of times; an alternative in
backslash-parentheses that matches end-of-line, a tab, or two spaces;
and a character set matching whitespace characters, repeated any number
of times.

   To enter the same regexp interactively, you would type TAB to enter
a tab, and `C-q C-j' to enter a newline.  You would also type single
slashes as themselves, instead of doubling them for Lisp syntax.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

   Incremental searches in Emacs normally ignore the case of the text
they are searching through, if you specify the text in lower case.
Thus, if you specify searching for `foo', then `Foo' and `foo' are also
considered a match.  Regexps, and in particular character sets, are
included: `[ab]' would match `a' or `A' or `b' or `B'.

   An upper-case letter in the incremental search string makes the
search case-sensitive.  Thus, searching for `Foo' does not find `foo'
or `FOO'.  This applies to regular expression search as well as to
string search.  If you delete the upper-case character from the search
string, it ceases to have this effect.

   If you set the variable `case-fold-search' to `nil', then all
letters must match exactly, including case.  This is a per-buffer
variable; altering the variable affects only the current buffer, but
there is a default value which you can change as well.  *Note Locals::.
This variable applies to nonincremental searches also, including those
performed by the replace commands (*note Replace::.).


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

   Global search-and-replace operations are not needed as often in Emacs
as they are in other editors(1), but they are available.  In addition
to the simple `M-x replace-string' command which is like that found in
most editors, there is a `M-x query-replace' command which asks you, for
each occurrence of the pattern, whether to replace it.

   The replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs'.  *Note Expanding
Abbrevs::.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.

   ---------- Footnotes ----------

   (1)  In some editors, search-and-replace operations are the only
convenient way to make a single change in the text.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string RET STRING RET NEWSTRING RET'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, narrow to that part of the buffer
before doing the replacement (*note Narrowing::.).

   When `replace-string' exits, point is left at the last occurrence
replaced.  The position of point where the `replace-string' command was
issued is remembered on the mark ring; use `C-u C-SPC' to move back
there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

   The `M-x replace-string' command replaces exact matches for a single
string.  The similar command `M-x replace-regexp' replaces any match
for a specified pattern.

   In `replace-regexp', the NEWSTRING need not be constant: it can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire text being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  To include a `\' in the text to
replace with, you must give `\\'.  For example,

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

replaces (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

performs the inverse transformation.

