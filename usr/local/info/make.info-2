This is Info file make.info, produced by Makeinfo-1.54 from the input
file ./make.texinfo.

   This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.45, last updated 11 May 1994, of `The GNU Make
Manual', for `make', Version 3.71 Beta.

   Copyright (C) 1988, '89, '90, '91, '92, '93, '94 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: make.info,  Node: Rule Example,  Next: Rule Syntax,  Up: Rules

Rule Example
============

   Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

   Its target is `foo.o' and its dependencies are `foo.c' and `defs.h'.
It has one command, which is `cc -c -g foo.c'.  The command line
starts with a tab to identify it as a command.

   This rule says two things:

   * How to decide whether `foo.o' is out of date: it is out of date if
     it does not exist, or if either `foo.c' or `defs.h' is more recent
     than it.

   * How to update the file `foo.o': by running `cc' as stated.  The
     command does not explicitly mention `defs.h', but we presume that
     `foo.c' includes it, and that that is why `defs.h' was added to
     the dependencies.


File: make.info,  Node: Rule Syntax,  Next: Wildcards,  Prev: Rule Example,  Up: Rules

Rule Syntax
===========

   In general, a rule looks like this:

     TARGETS : DEPENDENCIES
             COMMAND
             ...

or like this:

     TARGETS : DEPENDENCIES ; COMMAND
             COMMAND
             ...

   The TARGETS are file names, separated by spaces.  Wildcard
characters may be used (*note Using Wildcard Characters in File Names:
Wildcards.) and a name of the form `A(M)' represents member M in
archive file A (*note Archive Members as Targets: Archive Members.).
Usually there is only one target per rule, but occasionally there is a
reason to have more (*note Multiple Targets in a Rule: Multiple
Targets.).

   The COMMAND lines start with a tab character.  The first command may
appear on the line after the dependencies, with a tab character, or may
appear on the same line, with a semicolon.  Either way, the effect is
the same.  *Note Writing the Commands in Rules: Commands.

   Because dollar signs are used to start variable references, if you
really want a dollar sign in a rule you must write two of them, `$$'
(*note How to Use Variables: Using Variables.).  You may split a long
line by inserting a backslash followed by a newline, but this is not
required, as `make' places no limit on the length of a line in a
makefile.

   A rule tells `make' two things: when the targets are out of date,
and how to update them when necessary.

   The criterion for being out of date is specified in terms of the
DEPENDENCIES, which consist of file names separated by spaces.
(Wildcards and archive members (*note Archives::.) are allowed here
too.) A target is out of date if it does not exist or if it is older
than any of the dependencies (by comparison of last-modification
times).  The idea is that the contents of the target file are computed
based on information in the dependencies, so if any of the dependencies
changes, the contents of the existing target file are no longer
necessarily valid.

   How to update is specified by COMMANDS.  These are lines to be
executed by the shell (normally `sh'), but with some extra features
(*note Writing the Commands in Rules: Commands.).


File: make.info,  Node: Wildcards,  Next: Directory Search,  Prev: Rule Syntax,  Up: Rules

Using Wildcard Characters in File Names
=======================================

   A single file name can specify many files using "wildcard
characters".  The wildcard characters in `make' are `*', `?' and
`[...]', the same as in the Bourne shell.  For example, `*.c' specifies
a list of all the files (in the working directory) whose names end in
`.c'.

   The character `~' at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example `~/bin' expands to `/home/you/bin'.  If the `~'
is followed by a word, the string represents the home directory of the
user named by that word.  For example `~john/bin' expands to
`/home/john/bin'.

   Wildcard expansion happens automatically in targets, in dependencies,
and in commands (where the shell does the expansion).  In other
contexts, wildcard expansion happens only if you request it explicitly
with the `wildcard' function.

   The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, `foo\*bar' would refer to a
specific file whose name consists of `foo', an asterisk, and `bar'.

* Menu:

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.


File: make.info,  Node: Wildcard Examples,  Next: Wildcard Pitfall,  Up: Wildcards

Wildcard Examples
-----------------

   Wildcards can be used in the commands of a rule, where they are
expanded by the shell.  For example, here is a rule to delete all the
object files:

     clean:
             rm -f *.o

   Wildcards are also useful in the dependencies of a rule.  With the
following rule in the makefile, `make print' will print all the `.c'
files that have changed since the last time you printed them:

     print: *.c
             lpr -p $?
             touch print

This rule uses `print' as an empty target file; see *Note Empty Target
Files to Record Events: Empty Targets.  (The automatic variable `$?' is
used to print only those files that have changed; see *Note Automatic
Variables: Automatic.)

   Wildcard expansion does not happen when you define a variable.
Thus, if you write this:

     objects = *.o

then the value of the variable `objects' is the actual string `*.o'.
However, if you use the value of `objects' in a target, dependency or
command, wildcard expansion will take place at that time.  To set
`objects' to the expansion, instead use:

     objects := $(wildcard *.o)

*Note Wildcard Function::.


File: make.info,  Node: Wildcard Pitfall,  Next: Wildcard Function,  Prev: Wildcard Examples,  Up: Wildcards

Pitfalls of Using Wildcards
---------------------------

   Now here is an example of a naive way of using wildcard expansion,
that does not do what you would intend.  Suppose you would like to say
that the executable file `foo' is made from all the object files in the
directory, and you write this:

     objects = *.o
     
     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of `objects' is the actual string `*.o'.  Wildcard expansion
happens in the rule for `foo', so that each *existing* `.o' file
becomes a dependency of `foo' and will be recompiled if necessary.

   But what if you delete all the `.o' files?  When a wildcard matches
no files, it is left as it is, so then `foo' will depend on the
oddly-named file `*.o'.  Since no such file is likely to exist, `make'
will give you an error saying it cannot figure out how to make `*.o'.
This is not what you want!

   Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
`wildcard' function and string substitution.  *Note The Function
`wildcard': Wildcard Function.


File: make.info,  Node: Wildcard Function,  Prev: Wildcard Pitfall,  Up: Wildcards

The Function `wildcard'
-----------------------

   Wildcard expansion happens automatically in rules.  But wildcard
expansion does not normally take place when a variable is set, or
inside the arguments of a function.  If you want to do wildcard
expansion in such places, you need to use the `wildcard' function, like
this:

     $(wildcard PATTERN...)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output of the `wildcard'
function.  Note that this is different from how unmatched wildcards
behave in rules, where they are used verbatim rather than ignored
(*note Wildcard Pitfall::.).

   One use of the `wildcard' function is to get a list of all the C
source files in a directory, like this:

     $(wildcard *.c)

   We can change the list of C source files into a list of object files
by replacing the `.o' suffix with `.c' in the result, like this:

     $(patsubst %.c,%.o,$(wildcard *.c))

(Here we have used another function, `patsubst'.  *Note Functions for
String Substitution and Analysis: Text Functions.)

   Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects := $(patsubst %.c,%.o,$(wildcard *.c))
     
     foo : $(objects)
             cc -o foo $(objects)

(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.
*Note The Two Flavors of Variables: Flavors, for an explanation of
`:=', which is a variant of `='.)


File: make.info,  Node: Directory Search,  Next: Phony Targets,  Prev: Wildcards,  Up: Rules

Searching Directories for Dependencies
======================================

   For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The "directory search" features of `make'
facilitate this by searching several directories automatically to find
a dependency.  When you redistribute the files among directories, you
do not need to change the individual rules, just the search paths.

* Menu:

* General Search::              Specifying a search path that applies
                                  to every dependency.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.


File: make.info,  Node: General Search,  Next: Selective Search,  Up: Directory Search

`VPATH': Search Path for All Dependencies
-----------------------------------------

   The value of the `make' variable `VPATH' specifies a list of
directories that `make' should search.  Most often, the directories are
expected to contain dependency files that are not in the current
directory; however, `VPATH' specifies a search list that `make' applies
for all files, including files which are targets of rules.

   Thus, if a file that is listed as a target or dependency does not
exist in the current directory, `make' searches the directories listed
in `VPATH' for a file with that name.  If a file is found in one of
them, that file becomes the dependency.  Rules may then specify the
names of source files in the dependencies as if they all existed in the
current directory.  *Note Writing Shell Commands with Directory Search:
Commands/Search.

   In the `VPATH' variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by `make' in its search.

   For example,

     VPATH = src:../headers

specifies a path containing two directories, `src' and `../headers',
which `make' searches in that order.

   With this value of `VPATH', the following rule,

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file `foo.c' does not exist in the current directory but
is found in the directory `src'.


File: make.info,  Node: Selective Search,  Next: Commands/Search,  Prev: General Search,  Up: Directory Search

The `vpath' Directive
---------------------

   Similar to the `VPATH' variable but more selective is the `vpath'
directive (note lower case), which allows you to specify a search path
for a particular class of file names, those that match a particular
pattern.  Thus you can supply certain search directories for one class
of file names and other directories (or none) for other file names.

   There are three forms of the `vpath' directive:

`vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for file names that match
     PATTERN.

     The search path, DIRECTORIES, is a list of directories to be
     searched, separated by colons or blanks, just like the search path
     used in the `VPATH' variable.

`vpath PATTERN'
     Clear out the search path associated with PATTERN.

`vpath'
     Clear all search paths previously specified with `vpath'
     directives.

   A `vpath' pattern is a string containing a `%' character.  The
string must match the file name of a dependency that is being searched
for, the `%' character matching any sequence of zero or more characters
(as in pattern rules; *note Defining and Redefining Pattern Rules:
Pattern Rules.).  For example, `%.h' matches files that end in `.h'.
(If there is no `%', the pattern must match the dependency exactly,
which is not useful very often.)

   `%' characters in a `vpath' directive's pattern can be quoted with
preceding backslashes (`\').  Backslashes that would otherwise quote
`%' characters can be quoted with more backslashes.  Backslashes that
quote `%' characters or other backslashes are removed from the pattern
before it is compared to file names.  Backslashes that are not in
danger of quoting `%' characters go unmolested.

   When a dependency fails to exist in the current directory, if the
PATTERN in a `vpath' directive matches the name of the dependency file,
then the DIRECTORIES in that directive are searched just like (and
before) the directories in the `VPATH' variable.

   For example,

     vpath %.h ../headers

tells `make' to look for any dependency whose name ends in `.h' in the
directory `../headers' if the file is not found in the current
directory.

   If several `vpath' patterns match the dependency file's name, then
`make' processes each matching `vpath' directive one by one, searching
all the directories mentioned in each directive.  `make' handles
multiple `vpath' directives in the order in which they appear in the
makefile; multiple directives with the same pattern are independent of
each other.

   Thus,

     vpath %.c foo
     vpath %   blish
     vpath %.c bar

will look for a file ending in `.c' in `foo', then `blish', then `bar',
while

     vpath %.c foo:bar
     vpath %   blish

will look for a file ending in `.c' in `foo', then `bar', then `blish'.


File: make.info,  Node: Commands/Search,  Next: Implicit/Search,  Prev: Selective Search,  Up: Directory Search

Writing Shell Commands with Directory Search
--------------------------------------------

   When a dependency is found in another directory through directory
search, this cannot change the commands of the rule; they will execute
as written.  Therefore, you must write the commands with care so that
they will look for the dependency in the directory where `make' finds
it.

   This is done with the "automatic variables" such as `$^' (*note
Automatic Variables: Automatic.).  For instance, the value of `$^' is a
list of all the dependencies of the rule, including the names of the
directories in which they were found, and the value of `$@' is the
target.  Thus:

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

(The variable `CFLAGS' exists so you can specify flags for C
compilation by implicit rules; we use it here for consistency so it will
affect all C compilations uniformly; *note Variables Used by Implicit
Rules: Implicit Variables..)

   Often the dependencies include header files as well, which you do not
want to mention in the commands.  The automatic variable `$<' is just
the first dependency:

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $< -o $@


File: make.info,  Node: Implicit/Search,  Next: Libraries/Search,  Prev: Commands/Search,  Up: Directory Search

Directory Search and Implicit Rules
-----------------------------------

   The search through the directories specified in `VPATH' or with
`vpath' also happens during consideration of implicit rules (*note
Using Implicit Rules: Implicit Rules.).

   For example, when a file `foo.o' has no explicit rule, `make'
considers implicit rules, such as the built-in rule to compile `foo.c'
if that file exists.  If such a file is lacking in the current
directory, the appropriate directories are searched for it.  If `foo.c'
exists (or is mentioned in the makefile) in any of the directories, the
implicit rule for C compilation is applied.

   The commands of implicit rules normally use automatic variables as a
matter of necessity; consequently they will use the file names found by
directory search with no extra effort.


File: make.info,  Node: Libraries/Search,  Prev: Implicit/Search,  Up: Directory Search

Directory Search for Link Libraries
-----------------------------------

   Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a
dependency whose name is of the form `-lNAME'.  (You can tell something
strange is going on here because the dependency is normally the name of
a file, and the *file name* of the library looks like `libNAME.a', not
like `-lNAME'.)

   When a dependency's name has the form `-lNAME', `make' handles it
specially by searching for the file `libNAME.a' in the current
directory, in directories specified by matching `vpath' search paths
and the `VPATH' search path, and then in the directories `/lib',
`/usr/lib', and `PREFIX/lib' (normally `/usr/local/lib').

   For example,

     foo : foo.c -lcurses
             cc $^ -o $@

would cause the command `cc foo.c /usr/lib/libcurses.a -o foo' to be
executed when `foo' is older than `foo.c' or than
`/usr/lib/libcurses.a'.


File: make.info,  Node: Phony Targets,  Next: Force Targets,  Prev: Directory Search,  Up: Rules

Phony Targets
=============

   A phony target is one that is not really the name of a file.  It is
just a name for some commands to be executed when you make an explicit
request.  There are two reasons to use a phony target: to avoid a
conflict with a file of the same name, and to improve performance.

   If you write a rule whose commands will not create the target file,
the commands will be executed every time the target comes up for
remaking.  Here is an example:

     clean:
             rm *.o temp

Because the `rm' command does not create a file named `clean', probably
no such file will ever exist.  Therefore, the `rm' command will be
executed every time you say `make clean'.

   The phony target will cease to work if anything ever does create a
file named `clean' in this directory.  Since it has no dependencies, the
file `clean' would inevitably be considered up to date, and its
commands would not be executed.  To avoid this problem, you can
explicitly declare the target to be phony, using the special target
`.PHONY' (*note Special Built-in Target Names: Special Targets.) as
follows:

     .PHONY : clean

Once this is done, `make clean' will run the commands regardless of
whether there is a file named `clean'.

   Since it knows that phony targets do not name actual files that
could be remade from other files, `make' skips the implicit rule search
for phony targets (*note Implicit Rules::.).  This is why declaring a
target phony is good for performance, even if you are not worried about
the actual file existing.

   Thus, you first write the line that states that `clean' is a phony
target, then you write the rule, like this:

     .PHONY: clean
     clean:
             rm *.o temp

   A phony target should not be a dependency of a real target file; if
it is, its commands are run every time `make' goes to update that file.
As long as a phony target is never a dependency of a real target, the
phony target commands will be executed only when the phony target is a
specified goal (*note Arguments to Specify the Goals: Goals.).

   Phony targets can have dependencies.  When one directory contains
multiple programs, it is most convenient to describe all of the
programs in one makefile `./Makefile'.  Since the target remade by
default will be the first one in the makefile, it is common to make
this a phony target named `all' and give it, as dependencies, all the
individual programs.  For example:

     all : prog1 prog2 prog3
     .PHONY : all
     
     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o
     
     prog2 : prog2.o
             cc -o prog2 prog2.o
     
     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o

Now you can say just `make' to remake all three programs, or specify as
arguments the ones to remake (as in `make prog1 prog3').

   When one phony target is a dependency of another, it serves as a
subroutine of the other.  For example, here `make cleanall' will delete
the object files, the difference files, and the file `program':

     .PHONY: cleanall cleanobj cleandiff
     
     cleanall : cleanobj cleandiff
             rm program
     
     cleanobj :
             rm *.o
     
     cleandiff :
             rm *.diff


File: make.info,  Node: Force Targets,  Next: Empty Targets,  Prev: Phony Targets,  Up: Rules

Rules without Commands or Dependencies
======================================

   If a rule has no dependencies or commands, and the target of the rule
is a nonexistent file, then `make' imagines this target to have been
updated whenever its rule is run.  This implies that all targets
depending on this one will always have their commands run.

   An example will illustrate this:

     clean: FORCE
             rm $(objects)
     FORCE:

   Here the target `FORCE' satisfies the special conditions, so the
target `clean' that depends on it is forced to run its commands.  There
is nothing special about the name `FORCE', but that is one name
commonly used this way.

   As you can see, using `FORCE' this way has the same results as using
`.PHONY: clean'.

   Using `.PHONY' is more explicit and more efficient.  However, other
versions of `make' do not support `.PHONY'; thus `FORCE' appears in
many makefiles.  *Note Phony Targets::.


File: make.info,  Node: Empty Targets,  Next: Special Targets,  Prev: Force Targets,  Up: Rules

Empty Target Files to Record Events
===================================

   The "empty target" is a variant of the phony target; it is used to
hold commands for an action that you request explicitly from time to
time.  Unlike a phony target, this target file can really exist; but
the file's contents do not matter, and usually are empty.

   The purpose of the empty target file is to record, with its
last-modification time, when the rule's commands were last executed.  It
does so because one of the commands is a `touch' command to update the
target file.

   The empty target file must have some dependencies.  When you ask to
remake the empty target, the commands are executed if any dependency is
more recent than the target; in other words, if a dependency has
changed since the last time you remade the target.  Here is an example:

     print: foo.c bar.c
             lpr -p $?
             touch print

With this rule, `make print' will execute the `lpr' command if either
source file has changed since the last `make print'.  The automatic
variable `$?' is used to print only those files that have changed
(*note Automatic Variables: Automatic.).


File: make.info,  Node: Special Targets,  Next: Multiple Targets,  Prev: Empty Targets,  Up: Rules

Special Built-in Target Names
=============================

   Certain names have special meanings if they appear as targets.

`.PHONY'
     The dependencies of the special target `.PHONY' are considered to
     be phony targets.  When it is time to consider such a target,
     `make' will run its commands unconditionally, regardless of
     whether a file with that name exists or what its last-modification
     time is.  *Note Phony Targets: Phony Targets.

`.SUFFIXES'
     The dependencies of the special target `.SUFFIXES' are the list of
     suffixes to be used in checking for suffix rules.  *Note
     Old-Fashioned Suffix Rules: Suffix Rules.

`.DEFAULT'
     The commands specified for `.DEFAULT' are used for any target for
     which no rules are found (either explicit rules or implicit rules).
     *Note Last Resort::.  If `.DEFAULT' commands are specified, every
     file mentioned as a dependency, but not as a target in a rule,
     will have these commands executed on its behalf.  *Note Implicit
     Rule Search Algorithm: Search Algorithm.

`.PRECIOUS'
     The targets which `.PRECIOUS' depends on are given the following
     special treatment: if `make' is killed or interrupted during the
     execution of their commands, the target is not deleted.  *Note
     Interrupting or Killing `make': Interrupts.  Also, if the target
     is an intermediate file, it will not be deleted after it is no
     longer needed, as is normally done.  *Note Chains of Implicit
     Rules: Chained Rules.

     You can also list the target pattern of an implicit rule (such as
     `%.o') as a dependency file of the special target `.PRECIOUS' to
     preserve intermediate files created by rules whose target patterns
     match that file's name.

`.IGNORE'
     Simply by being mentioned as a target, `.IGNORE' says to ignore
     errors in execution of commands.  The dependencies and commands for
     `.IGNORE' are not meaningful.

     `.IGNORE' exists for historical compatibility.  Since `.IGNORE'
     affects every command in the makefile, it is not very useful; we
     recommend you use the more selective ways to ignore errors in
     specific commands.  *Note Errors in Commands: Errors.

`.SILENT'
     Simply by being mentioned as a target, `.SILENT' says not to print
     commands before executing them.  The dependencies and commands for
     `.SILENT' are not meaningful.

     `.SILENT' exists for historical compatibility.  We recommend you
     use the more selective ways to silence specific commands.  *Note
     Command Echoing: Echoing.  If you want to silence all commands for
     a particular run of `make', use the `-s' or `--silent' option
     (*note Options Summary::.).

`.EXPORT_ALL_VARIABLES'
     Simply by being mentioned as a target, this tells `make' to export
     all variables to child processes by default.  *Note Communicating
     Variables to a Sub-`make': Variables/Recursion.

   Any defined implicit rule suffix also counts as a special target if
it appears as a target, and so does the concatenation of two suffixes,
such as `.c.o'.  These targets are suffix rules, an obsolete way of
defining implicit rules (but a way still widely used).  In principle,
any target name could be special in this way if you break it in two and
add both pieces to the suffix list.  In practice, suffixes normally
begin with `.', so these special target names also begin with `.'.
*Note Old-Fashioned Suffix Rules: Suffix Rules.


File: make.info,  Node: Multiple Targets,  Next: Multiple Rules,  Prev: Special Targets,  Up: Rules

Multiple Targets in a Rule
==========================

   A rule with multiple targets is equivalent to writing many rules,
each with one target, and all identical aside from that.  The same
commands apply to all the targets, but their effects may vary because
you can substitute the actual target name into the command using `$@'.
The rule contributes the same dependencies to all the targets also.

   This is useful in two cases.

   * You want just dependencies, no commands.  For example:

          kbd.o command.o files.o: command.h

     gives an additional dependency to each of the three object files
     mentioned.

   * Similar commands work for all the targets.  The commands do not
     need to be absolutely identical, since the automatic variable `$@'
     can be used to substitute the particular target to be remade into
     the commands (*note Automatic Variables: Automatic.).  For example:

          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) > $@

     is equivalent to

          bigoutput : text.g
                  generate text.g -big > bigoutput
          littleoutput : text.g
                  generate text.g -little > littleoutput

     Here we assume the hypothetical program `generate' makes two types
     of output, one if given `-big' and one if given `-little'.  *Note
     Functions for String Substitution and Analysis: Text Functions,
     for an explanation of the `subst' function.

   Suppose you would like to vary the dependencies according to the
target, much as the variable `$@' allows you to vary the commands.  You
cannot do this with multiple targets in an ordinary rule, but you can
do it with a "static pattern rule".  *Note Static Pattern Rules: Static
Pattern.


File: make.info,  Node: Multiple Rules,  Next: Static Pattern,  Prev: Multiple Targets,  Up: Rules

Multiple Rules for One Target
=============================

   One file can be the target of several rules.  All the dependencies
mentioned in all the rules are merged into one list of dependencies for
the target.  If the target is older than any dependency from any rule,
the commands are executed.

   There can only be one set of commands to be executed for a file.  If
more than one rule gives commands for the same file, `make' uses the
last set given and prints an error message.  (As a special case, if the
file's name begins with a dot, no error message is printed.  This odd
behavior is only for compatibility with other implementations of
`make'.) There is no reason to write your makefiles this way; that is
why `make' gives you an error message.

   An extra rule with just dependencies can be used to give a few extra
dependencies to many files at once.  For example, one usually has a
variable named `objects' containing a list of all the compiler output
files in the system being made.  An easy way to say that all of them
must be recompiled if `config.h' changes is to write the following:

     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h

   This could be inserted or taken out without changing the rules that
really specify how to make the object files, making it a convenient
form to use if you wish to add the additional dependency intermittently.

   Another wrinkle is that the additional dependencies could be
specified with a variable that you set with a command argument to `make'
(*note Overriding Variables: Overriding.).  For example,

     extradeps=
     $(objects) : $(extradeps)

means that the command `make extradeps=foo.h' will consider `foo.h' as
a dependency of each object file, but plain `make' will not.

   If none of the explicit rules for a target has commands, then `make'
searches for an applicable implicit rule to find some commands *note
Using Implicit Rules: Implicit Rules.).


File: make.info,  Node: Static Pattern,  Next: Double-Colon,  Prev: Multiple Rules,  Up: Rules

Static Pattern Rules
====================

   "Static pattern rules" are rules which specify multiple targets and
construct the dependency names for each target based on the target name.
They are more general than ordinary rules with multiple targets because
the targets do not have to have identical dependencies.  Their
dependencies must be *analogous*, but not necessarily *identical*.

* Menu:

* Static Usage::                The syntax of static pattern rules.
* Static versus Implicit::      When are they better than implicit rules?


File: make.info,  Node: Static Usage,  Next: Static versus Implicit,  Up: Static Pattern

Syntax of Static Pattern Rules
------------------------------

   Here is the syntax of a static pattern rule:

     TARGETS ...: TARGET-PATTERN: DEP-PATTERNS ...
             COMMANDS
             ...

The TARGETS list specifies the targets that the rule applies to.  The
targets can contain wildcard characters, just like the targets of
ordinary rules (*note Using Wildcard Characters in File Names:
Wildcards.).

   The TARGET-PATTERN and DEP-PATTERNS say how to compute the
dependencies of each target.  Each target is matched against the
TARGET-PATTERN to extract a part of the target name, called the "stem".
This stem is substituted into each of the DEP-PATTERNS to make the
dependency names (one from each DEP-PATTERN).

   Each pattern normally contains the character `%' just once.  When the
TARGET-PATTERN matches a target, the `%' can match any part of the
target name; this part is called the "stem".  The rest of the pattern
must match exactly.  For example, the target `foo.o' matches the
pattern `%.o', with `foo' as the stem.  The targets `foo.c' and
`foo.out' do not match that pattern.

   The dependency names for each target are made by substituting the
stem for the `%' in each dependency pattern.  For example, if one
dependency pattern is `%.c', then substitution of the stem `foo' gives
the dependency name `foo.c'.  It is legitimate to write a dependency
pattern that does not contain `%'; then this dependency is the same for
all targets.

   `%' characters in pattern rules can be quoted with preceding
backslashes (`\').  Backslashes that would otherwise quote `%'
characters can be quoted with more backslashes.  Backslashes that quote
`%' characters or other backslashes are removed from the pattern before
it is compared to file names or has a stem substituted into it.
Backslashes that are not in danger of quoting `%' characters go
unmolested.  For example, the pattern `the\%weird\\%pattern\\' has
`the%weird\' preceding the operative `%' character, and `pattern\\'
following it.  The final two backslashes are left alone because they
cannot affect any `%' character.

   Here is an example, which compiles each of `foo.o' and `bar.o' from
the corresponding `.c' file:

     objects = foo.o bar.o
     
     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@

Here `$<' is the automatic variable that holds the name of the
dependency and `$@' is the automatic variable that holds the name of
the target; see *Note Automatic Variables: Automatic.

   Each target specified must match the target pattern; a warning is
issued for each target that does not.  If you have a list of files,
only some of which will match the pattern, you can use the `filter'
function to remove nonmatching file names (*note Functions for String
Substitution and Analysis: Text Functions.):

     files = foo.elc bar.o lose.o
     
     $(filter %.o,$(files)): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $<

In this example the result of `$(filter %.o,$(files))' is `bar.o
lose.o', and the first static pattern rule causes each of these object
files to be updated by compiling the corresponding C source file.  The
result of `$(filter %.elc,$(files))' is `foo.elc', so that file is made
from `foo.el'.

   Another example shows how to use `$*' in static pattern rules:

     bigoutput littleoutput : %output : text.g
             generate text.g -$* > $@

When the `generate' command is run, `$*' will expand to the stem,
either `big' or `little'.


File: make.info,  Node: Static versus Implicit,  Prev: Static Usage,  Up: Static Pattern

Static Pattern Rules versus Implicit Rules
------------------------------------------

   A static pattern rule has much in common with an implicit rule
defined as a pattern rule (*note Defining and Redefining Pattern Rules:
Pattern Rules.).  Both have a pattern for the target and patterns for
constructing the names of dependencies.  The difference is in how
`make' decides *when* the rule applies.

   An implicit rule *can* apply to any target that matches its pattern,
but it *does* apply only when the target has no commands otherwise
specified, and only when the dependencies can be found.  If more than
one implicit rule appears applicable, only one applies; the choice
depends on the order of rules.

   By contrast, a static pattern rule applies to the precise list of
targets that you specify in the rule.  It cannot apply to any other
target and it invariably does apply to each of the targets specified.
If two conflicting rules apply, and both have commands, that's an error.

   The static pattern rule can be better than an implicit rule for these
reasons:

   * You may wish to override the usual implicit rule for a few files
     whose names cannot be categorized syntactically but can be given
     in an explicit list.

   * If you cannot be sure of the precise contents of the directories
     you are using, you may not be sure which other irrelevant files
     might lead `make' to use the wrong implicit rule.  The choice
     might depend on the order in which the implicit rule search is
     done.  With static pattern rules, there is no uncertainty: each
     rule applies to precisely the targets specified.


File: make.info,  Node: Double-Colon,  Next: Automatic Dependencies,  Prev: Static Pattern,  Up: Rules

Double-Colon Rules
==================

   "Double-colon" rules are rules written with `::' instead of `:'
after the target names.  They are handled differently from ordinary
rules when the same target appears in more than one rule.

   When a target appears in multiple rules, all the rules must be the
same type: all ordinary, or all double-colon.  If they are
double-colon, each of them is independent of the others.  Each
double-colon rule's commands are executed if the target is older than
any dependencies of that rule.  This can result in executing none, any,
or all of the double-colon rules.

   Double-colon rules with the same target are in fact completely
separate from one another.  Each double-colon rule is processed
individually, just as rules with different targets are processed.

   The double-colon rules for a target are executed in the order they
appear in the makefile.  However, the cases where double-colon rules
really make sense are those where the order of executing the commands
would not matter.

   Double-colon rules are somewhat obscure and not often very useful;
they provide a mechanism for cases in which the method used to update a
target differs depending on which dependency files caused the update,
and such cases are rare.

   Each double-colon rule should specify commands; if it does not, an
implicit rule will be used if one applies.  *Note Using Implicit Rules:
Implicit Rules.


File: make.info,  Node: Automatic Dependencies,  Prev: Double-Colon,  Up: Rules

Generating Dependencies Automatically
=====================================

   In the makefile for a program, many of the rules you need to write
often say only that some object file depends on some header file.  For
example, if `main.c' uses `defs.h' via an `#include', you would write:

     main.o: defs.h

You need this rule so that `make' knows that it must remake `main.o'
whenever `defs.h' changes.  You can see that for a large program you
would have to write dozens of such rules in your makefile.  And, you
must always be very careful to update the makefile every time you add
or remove an `#include'.

   To avoid this hassle, most modern C compilers can write these rules
for you, by looking at the `#include' lines in the source files.
Usually this is done with the `-M' option to the compiler.  For
example, the command:

     cc -M main.c

generates the output:

     main.o : main.c defs.h

Thus you no longer have to write all those rules yourself.  The
compiler will do it for you.

   Note that such a dependency constitutes mentioning `main.o' in a
makefile, so it can never be considered an intermediate file by implicit
rule search.  This means that `make' won't ever remove the file after
using it; *note Chains of Implicit Rules: Chained Rules..

   With old `make' programs, it was traditional practice to use this
compiler feature to generate dependencies on demand with a command like
`make depend'.  That command would create a file `depend' containing
all the automatically-generated dependencies; then the makefile could
use `include' to read them in (*note Include::.).

   In GNU `make', the feature of remaking makefiles makes this practice
obsolete--you need never tell `make' explicitly to regenerate the
dependencies, because it always regenerates any makefile that is out of
date.  *Note Remaking Makefiles::.

   The practice we recommend for automatic dependency generation is to
have one makefile corresponding to each source file.  For each source
file `NAME.c' there is a makefile `NAME.d' which lists what files the
object file `NAME.o' depends on.  That way only the source files that
have changed need to be rescanned to produce the new dependencies.

   Here is the pattern rule to generate a file of dependencies (i.e., a
makefile) called `NAME.d' from a C source file called `NAME.c':

     %.d: %.c
             $(SHELL) -ec '$(CC) -M $(CPPFLAGS) $< | sed '\''s/$*.o/& $@/g'\'' > $@'

*Note Pattern Rules::, for information on defining pattern rules.  The
`-e' flag to the shell makes it exit immediately if the `$(CC)' command
fails (exits with a nonzero status).  Normally the shell exits with the
status of the last command in the pipeline (`sed' in this case), so
`make' would not notice a nonzero status from the compiler.

   The purpose of the `sed' command is to translate (for example):

     main.o : main.c defs.h

into:

     main.o main.d : main.c defs.h

This makes each `.d' file depend on all the source and header files
that the corresponding `.o' file depends on.  `make' then knows it must
regenerate the dependencies whenever any of the source or header files
changes.

   Once you've defined the rule to remake the `.d' files, you then use
the `include' directive to read them all in.  *Note Include::.  For
example:

     sources = foo.c bar.c
     
     include $(sources:.c=.d)

(This example uses a substitution variable reference to translate the
list of source files `foo.c bar.c' into a list of dependency makefiles,
`foo.d bar.d'.  *Note Substitution Refs::, for full information on
substitution references.)  Since the `.d' files are makefiles like any
others, `make' will remake them as necessary with no further work from
you.  *Note Remaking Makefiles::.


File: make.info,  Node: Commands,  Next: Using Variables,  Prev: Rules,  Up: Top

Writing the Commands in Rules
*****************************

   The commands of a rule consist of shell command lines to be executed
one by one.  Each command line must start with a tab, except that the
first command line may be attached to the target-and-dependencies line
with a semicolon in between.  Blank lines and lines of just comments
may appear among the command lines; they are ignored.

   Users use many different shell programs, but commands in makefiles
are always interpreted by `/bin/sh' unless the makefile specifies
otherwise.  *Note Command Execution: Execution.

   The shell that is in use determines whether comments can be written
on command lines, and what syntax they use.  When the shell is
`/bin/sh', a `#' starts a comment that extends to the end of the line.
The `#' does not have to be at the beginning of a line.  Text on a line
before a `#' is not part of the comment.

* Menu:

* Echoing::                     How to control when commands are echoed.
* Execution::                   How commands are executed.
* Parallel::                    How commands can be executed in parallel.
* Errors::                      What happens after a command execution error.
* Interrupts::                  What happens when a command is interrupted.
* Recursion::                   Invoking `make' from makefiles.
* Sequences::                   Defining canned sequences of commands.
* Empty Commands::              Defining useful, do-nothing commands.


File: make.info,  Node: Echoing,  Next: Execution,  Up: Commands

Command Echoing
===============

   Normally `make' prints each command line before it is executed.  We
call this "echoing" because it gives the appearance that you are typing
the commands yourself.

   When a line starts with `@', the echoing of that line is suppressed.
The `@' is discarded before the command is passed to the shell.
Typically you would use this for a command whose only effect is to print
something, such as an `echo' command to indicate progress through the
makefile:

     @echo About to make distribution files

   When `make' is given the flag `-n' or `--just-print', echoing is all
that happens, no execution.  *Note Summary of Options: Options Summary.
In this case and only this case, even the commands starting with `@'
are printed.  This flag is useful for finding out which commands `make'
thinks are necessary without actually doing them.

   The `-s' or `--silent' flag to `make' prevents all echoing, as if
all commands started with `@'.  A rule in the makefile for the special
target `.SILENT' has the same effect (*note Special Built-in Target
Names: Special Targets.).  `.SILENT' is essentially obsolete since `@'
is more flexible.


File: make.info,  Node: Execution,  Next: Parallel,  Prev: Echoing,  Up: Commands

Command Execution
=================

   When it is time to execute commands to update a target, they are
executed by making a new subshell for each line.  (In practice, `make'
may take shortcuts that do not affect the results.)

   *Please note:* this implies that shell commands such as `cd' that
set variables local to each process will not affect the following
command lines.  If you want to use `cd' to affect the next command, put
the two on a single line with a semicolon between them.  Then `make'
will consider them a single command and pass them, together, to a shell
which will execute them in sequence.  For example:

     foo : bar/lose
             cd bar; gobble lose > ../foo

   If you would like to split a single shell command into multiple
lines of text, you must use a backslash at the end of all but the last
subline.  Such a sequence of lines is combined into a single line, by
deleting the backslash-newline sequences, before passing it to the
shell.  Thus, the following is equivalent to the preceding example:

     foo : bar/lose
             cd bar;  \
             gobble lose > ../foo

   The program used as the shell is taken from the variable `SHELL'.
By default, the program `/bin/sh' is used.

   Unlike most variables, the variable `SHELL' is never set from the
environment.  This is because the `SHELL' environment variable is used
to specify your personal choice of shell program for interactive use.
It would be very bad for personal choices like this to affect the
functioning of makefiles.  *Note Variables from the Environment:
Environment.


File: make.info,  Node: Parallel,  Next: Errors,  Prev: Execution,  Up: Commands

Parallel Execution
==================

   GNU `make' knows how to execute several commands at once.  Normally,
`make' will execute only one command at a time, waiting for it to
finish before executing the next.  However, the `-j' or `--jobs' option
tells `make' to execute many commands simultaneously.

   If the `-j' option is followed by an integer, this is the number of
commands to execute at once; this is called the number of "job slots".
If there is nothing looking like an integer after the `-j' option,
there is no limit on the number of job slots.  The default number of job
slots is one, which means serial execution (one thing at a time).

   One unpleasant consequence of running several commands
simultaneously is that output from all of the commands comes when the
commands send it, so messages from different commands may be
interspersed.

   Another problem is that two processes cannot both take input from the
same device; so to make sure that only one command tries to take input
from the terminal at once, `make' will invalidate the standard input
streams of all but one running command.  This means that attempting to
read from standard input will usually be a fatal error (a `Broken pipe'
signal) for most child processes if there are several.

   It is unpredictable which command will have a valid standard input
stream (which will come from the terminal, or wherever you redirect the
standard input of `make').  The first command run will always get it
first, and the first command started after that one finishes will get
it next, and so on.

   We will change how this aspect of `make' works if we find a better
alternative.  In the mean time, you should not rely on any command using
standard input at all if you are using the parallel execution feature;
but if you are not using this feature, then standard input works
normally in all commands.

   If a command fails (is killed by a signal or exits with a nonzero
status), and errors are not ignored for that command (*note Errors in
Commands: Errors.), the remaining command lines to remake the same
target will not be run.  If a command fails and the `-k' or
`--keep-going' option was not given (*note Summary of Options: Options
Summary.), `make' aborts execution.  If make terminates for any reason
(including a signal) with child processes running, it waits for them to
finish before actually exiting.

   When the system is heavily loaded, you will probably want to run
fewer jobs than when it is lightly loaded.  You can use the `-l' option
to tell `make' to limit the number of jobs to run at once, based on the
load average.  The `-l' or `--max-load' option is followed by a
floating-point number.  For example,

     -l 2.5

will not let `make' start more than one job if the load average is
above 2.5.  The `-l' option with no following number removes the load
limit, if one was given with a previous `-l' option.

   More precisely, when `make' goes to start up a job, and it already
has at least one job running, it checks the current load average; if it
is not lower than the limit given with `-l', `make' waits until the load
average goes below that limit, or until all the other jobs finish.

   By default, there is no load limit.

