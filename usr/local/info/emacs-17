This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Basic Kbd Macro,  Next: Save Kbd Macro,  Up: Keyboard Macros

Basic Use
---------

   To start defining a keyboard macro, type the `C-x (' command
(`start-kbd-macro').  From then on, your keys continue to be executed,
but also become part of the definition of the macro.  `Def' appears in
the mode line to remind you of what is going on.  When you are
finished, the `C-x )' command (`end-kbd-macro') terminates the
definition (without becoming part of it!).  For example

     C-x ( M-f foo C-x )

defines a macro to move forward a word and then insert `foo'.

   The macro thus defined can be invoked again with the `C-x e' command
(`call-last-kbd-macro'), which may be given a repeat count as a numeric
argument to execute the macro many times.  `C-x )' can also be given a
repeat count as an argument, in which case it repeats the macro that
many times right after defining it, but defining the macro counts as
the first repetition (since it is executed as you define it).  So,
giving `C-x )' an argument of 4 executes the macro immediately 3
additional times.  An argument of zero to `C-x e' or `C-x )' means
repeat the macro indefinitely (until it gets an error or you type
`C-g').

   If you wish to repeat an operation at regularly spaced places in the
text, define a macro and include as part of the macro the commands to
move to the next place you want to use it.  For example, if you want to
change each line, you should position point at the start of a line, and
define a macro to change that line and leave point at the start of the
next line.  Then repeating the macro will operate on successive lines.

   After you have terminated the definition of a keyboard macro, you
can add to the end of its definition by typing `C-u C-x ('.  This is
equivalent to plain `C-x (' followed by retyping the whole definition
so far.  As a consequence it re-executes the macro as previously
defined.

   You can use function keys in a keyboard macro, just like keyboard
keys.  You can even use mouse events, but be careful about that: when
the macro replays the mouse event, it uses the original mouse position
of that event, the position that the mouse had while you were defining
the macro.  The effect of this may be hard to predict.  (Using the
current mouse position would be even less predictable.)

   One thing that doesn't always work well in a keyboard macro is the
command `C-M-c' (`exit-recursive-edit').  When this command exits a
recursive edit that started within the macro, it works as you'd expect.
But if it exits a recursive edit that started before you invoked the
keyboard macro, it also necessarily exits the keyboard macro as part of
the process.

   You can edit a keyboard macro already defined by typing `C-x C-k'
(`edit-kbd-macro').  Follow that with the keyboard input that you would
use to invoke the macro--`C-x e' or `M-x NAME' or some other key
sequence.  This formats the macro definition in a buffer and enters a
specialized major mode for editing it.  Type `C-h m' once in that
buffer to display details of how to edit the macro.  When you are
finished editing, type `C-c C-c'.


File: emacs,  Node: Save Kbd Macro,  Next: Kbd Macro Query,  Prev: Basic Kbd Macro,  Up: Keyboard Macros

Naming and Saving Keyboard Macros
---------------------------------

   If you wish to save a keyboard macro for longer than until you
define the next one, you must give it a name using `M-x
name-last-kbd-macro'.  This reads a name as an argument using the
minibuffer and defines that name to execute the macro.  The macro name
is a Lisp symbol, and defining it in this way makes it a valid command
name for calling with `M-x' or for binding a key to with
`global-set-key' (*note Keymaps::.).  If you specify a name that has a
prior definition other than another keyboard macro, an error message is
printed and nothing is changed.

   Once a macro has a command name, you can save its definition in a
file.  Then it can be used in another editing session.  First, visit
the file you want to save the definition in.  Then use this command:

     M-x insert-kbd-macro RET MACRONAME RET

This inserts some Lisp code that, when executed later, will define the
same macro with the same definition it has now.  (You need not
understand Lisp code to do this, because `insert-kbd-macro' writes the
Lisp code for you.)  Then save the file.  You can load the file later
with `load-file' (*note Lisp Libraries::.).  If the file you save in is
your init file `~/.emacs' (*note Init File::.) then the macro will be
defined each time you run Emacs.

   If you give `insert-kbd-macro' a prefix argument, it makes
additional Lisp code to record the keys (if any) that you have bound to
the keyboard macro, so that the macro will be reassigned the same keys
when you load the file.


File: emacs,  Node: Kbd Macro Query,  Prev: Save Kbd Macro,  Up: Keyboard Macros

Executing Macros with Variations
--------------------------------

   Using `C-x q' (`kbd-macro-query'), you can get an effect similar to
that of `query-replace', where the macro asks you each time around
whether to make a change.  When you are defining the macro, type `C-x
q' at the point where you want the query to occur.  During macro
definition, the `C-x q' does nothing, but when you run the macro later,
`C-x q' asks you interactively whether to continue.

   The valid responses when `C-x q' asks are SPC (or `y'), DEL (or
`n'), ESC (or `q'), `C-l' and `C-r'.  The answers are the same as in
query replace, though not all of the query-replace options are
meaningful.

   Specifically, SPC means to continue.  DEL means to skip the
remainder of this repetition of the macro and start right away with the
next repetition.  ESC means to skip the remainder of this repetition
and cancel further repetition.  `C-l' redraws the screen and asks you
again for a character to say what to do.

   `C-r' enters a recursive editing level, in which you can perform
editing which is not part of the macro.  When you exit the recursive
edit using `C-M-c', you are asked again how to continue with the
keyboard macro.  If you type a SPC at this time, the rest of the macro
definition is executed.  It is up to you to leave point and the text in
a state such that the rest of the macro will do what you want.

   `C-u C-x q', which is `C-x q' with a numeric argument, performs a
different function.  It enters a recursive edit reading input from the
keyboard, both when you type it during the definition of the macro, and
when it is executed from the macro.  During definition, the editing you
do inside the recursive edit does not become part of the macro.  During
macro execution, the recursive edit gives you a chance to do some
particularized editing.  *Note Recursive Edit::.


File: emacs,  Node: Key Bindings,  Next: Keyboard Translations,  Prev: Keyboard Macros,  Up: Customization

Customizing Key Bindings
========================

   This section describes "key bindings" which map keys to commands,
and the "keymaps" which record key bindings.  It also explains how to
customize key bindings.

   Recall that a command is a Lisp function whose definition provides
for interactive use.  Like every Lisp function, a command has a function
name which usually consists of lower case letters and hyphens.

* Menu:

* Keymaps::          Generalities.  The global keymap.
* Prefix Keymaps::   Keymaps for prefix keys.
* Local Keymaps::    Major and minor modes have their own keymaps.
* Minibuffer Maps::  The minibuffer uses its own local keymaps.
* Rebinding::        How to redefine one key's meaning conveniently.
* Init Rebinding::   Rebinding keys with your init file, `.emacs'.
* Function Keys::    Rebinding terminal function keys.
* Named ASCII Chars::Distinguishing TAB from `C-i', and so on.
* Mouse Buttons::    Rebinding mouse buttons in Emacs.
* Disabling::        Disabling a command means confirmation is required
                       before it can be executed.  This is done to protect
                       beginners from surprises.


File: emacs,  Node: Keymaps,  Next: Prefix Keymaps,  Up: Key Bindings

Keymaps
-------

   The bindings between key sequences and command functions are recorded
in data structures called "keymaps".  Emacs has many of these, each
used on particular occasions.

   Recall that a "key sequence" ("key", for short) is a sequence of
"input events" that have a meaning as a unit.  Input events include
characters, function keys and mouse buttons--all the inputs that you
can send to the computer with your terminal.  A key sequence gets its
meaning from its "binding", which says what command it runs.  The
function of keymaps is to record these bindings.

   The "global" keymap is the most important keymap because it is
always in effect.  The global keymap defines keys for Fundamental mode;
most of these definitions are common to all (or most) major modes.  Each
major or minor mode can have its own keymap which overrides the
definitions of some keys.

   For example, a self-inserting character such as `g' is
self-inserting because the global keymap binds it to the command
`self-insert-command'.  The standard Emacs editing characters such as
`C-a' also get their standard meanings from the global keymap.
Commands to rebind keys, such as `M-x global-set-key', actually work by
storing the new binding in the proper place in the global map.  *Note
Rebinding::.

   Meta characters work differently; Emacs translates each Meta
character into a pair of characters starting with ESC.  When you type
the character `M-a' in a key sequence, Emacs replaces it with `ESC a'.
A meta key comes in as a single input event, but becomes two events for
purposes of key bindings.  The reason for this is historical, and we
might change it someday.

   Most modern keyboards have function keys as well as character keys.
Function keys send input events just as character keys do, and keymaps
can have bindings for them.

   On many terminals, typing a function key actually sends the computer
a sequence of characters; the precise details of the sequence depends on
which function key and on the model of terminal you are using.  (Often
the sequence starts with `ESC ['.)  If Emacs understands your terminal
type properly, it recognizes the character sequences forming function
keys wherever they occur in a key sequence (not just at the beginning).
Thus, for most purposes, you can pretend the function keys reach Emacs
directly and ignore their encoding as character sequences.

   Mouse buttons also produce input events.  These events come with
other data--the window and position where you pressed or released the
button, and a timestamp.  But only the choice of button matters for key
bindings; the other data matters only if a command looks at it.
(Commands designed for mouse invocation usually do look at the other
data.)

   A keymap records definitions for single events.  Interpreting a key
sequence of multiple events involves a chain of keymaps.  The first
keymap gives a definition for the first event; this definition is
another keymap, which is used to look up the second event in the
sequence, and so on.

   Key sequences can mix function keys and characters.  For example,
`C-x SELECT' makes sense.  If you make SELECT a prefix key, then
`SELECT C-n' makes sense.  You can even mix mouse events with keyboard
events, but we recommend against it, because such sequences are
inconvenient to type in.


File: emacs,  Node: Prefix Keymaps,  Next: Local Keymaps,  Prev: Keymaps,  Up: Key Bindings

Prefix Keymaps
--------------

   A prefix key such as `C-x' or ESC has its own keymap, which holds
the definition for the event that immediately follows that prefix.

   The definition of a prefix key is the keymap to use for looking up
the following event.  The definition can also be a Lisp symbol whose
function definition is the following keymap; the effect is the same, but
it provides a command name for the prefix key that can be used as a
description of what the prefix key is for.  Thus, the binding of `C-x'
is the symbol `Ctl-X-Prefix', whose function definition is the keymap
for `C-x' commands.  The definitions of `C-c', `C-x', `C-h' and ESC as
prefix keys appear in the global map, so these prefix keys are always
available.

   Some prefix keymaps are stored in variables with names:

   * `ctl-x-map' is the variable name for the map used for characters
     that follow `C-x'.

   * `help-map' is for characters that follow `C-h'.

   * `esc-map' is for characters that follow ESC.  Thus, all Meta
     characters are actually defined by this map.

   * `ctl-x-4-map' is for characters that follow `C-x 4'.

   * `mode-specific-map' is for characters that follow `C-c'.


File: emacs,  Node: Local Keymaps,  Next: Minibuffer Maps,  Prev: Prefix Keymaps,  Up: Key Bindings

Local Keymaps
-------------

   So far we have explained the ins and outs of the global map.  Major
modes customize Emacs by providing their own key bindings in "local
keymaps".  For example, C mode overrides TAB to make it indent the
current line for C code.  Portions of text in the buffer can specify
their own keymaps to substitute for the keymap of the buffer's major
mode.

   Minor modes can also have local keymaps.  Whenever a minor mode is
in effect, the definitions in its keymap override both the major mode's
local keymap and the global keymap.

   The local keymaps for Lisp mode, C mode, and several other major
modes always exist even when not in use.  These are kept in variables
named `lisp-mode-map', `c-mode-map', and so on.  For major modes less
often used, the local keymap is normally constructed only when the mode
is used for the first time in a session.  This is to save space.

   All minor mode keymaps are created in advance.  There is no way to
defer their creation until the minor mode is enabled.

   A local keymap can locally redefine a key as a prefix key by defining
it as a prefix keymap.  If the key is also defined globally as a prefix,
then its local and global definitions (both keymaps) effectively
combine: both of them are used to look up the event that follows the
prefix key.  Thus, if the mode's local keymap defines `C-c' as another
keymap, and that keymap defines `C-z' as a command, this provides a
local meaning for `C-c C-z'.  This does not affect other sequences that
start with `C-c'; If those sequences don't have their own local
bindings, their global bindings remain in effect.

   Another way to think of this is that Emacs handles a multi-event key
sequence by looking in several keymaps, one by one, for a binding of the
whole key sequence.  First it checks the minor mode keymaps for minor
modes that are enabled, then it checks the major mode's keymap, and then
it checks the global keymap.  This is not precisely how key lookup
works, but it's good enough for understanding ordinary circumstances.


File: emacs,  Node: Minibuffer Maps,  Next: Rebinding,  Prev: Local Keymaps,  Up: Key Bindings

Minibuffer Keymaps
------------------

   The minibuffer has its own set of local keymaps; they contain various
completion and exit commands.

   * `minibuffer-local-map' is used for ordinary input (no completion).

   * `minibuffer-local-ns-map' is similar, except that SPC exits just
     like RET.  This is used mainly for Mocklisp compatibility.

   * `minibuffer-local-completion-map' is for permissive completion.

   * `minibuffer-local-must-match-map' is for strict completion and for
     cautious completion.


File: emacs,  Node: Rebinding,  Next: Init Rebinding,  Prev: Minibuffer Maps,  Up: Key Bindings

Changing Key Bindings Interactively
-----------------------------------

   The way to redefine an Emacs key is to change its entry in a keymap.
You can change the global keymap, in which case the change is effective
in all major modes (except those that have their own overriding local
definitions for the same key).  Or you can change the current buffer's
local map, which affects all buffers using the same major mode.

`M-x global-set-key RET KEY CMD RET'
     Define KEY globally to run CMD.

`M-x local-set-key RET KEY CMD RET'
     Define KEY locally (in the major mode now in effect) to run CMD.

`M-x global-unset-key RET KEY'
     Make KEY undefined in the global map.

`M-x local-unset-key RET KEY'
     Make KEY undefined locally (in the major mode now in effect).

   For example, suppose you like to execute commands in a subshell
within an Emacs buffer, instead of suspending Emacs and executing
commands in your login shell.  Normally, `C-z' is bound to the function
`suspend-emacs', but you can change `C-z' to invoke an interactive
subshell within Emacs, by binding it to `shell' as follows:

     M-x global-set-key RET C-z shell RET

`global-set-key' reads the command name after the key.   After you
press the key, a message like this appears so that you can confirm that
you are binding the key you want:

     Set key C-z to command:

   You can redefine function keys and mouse events in the same way; just
type the function key or click the mouse when it's time to specify the
key to rebind.

   You can rebind a key that contains more than one event in the same
way.  Emacs keeps reading the key to rebind until it is a complete key
(that is, not a prefix key).  Thus, if you type `C-f' for KEY, that's
the end; the minibuffer is entered immediately to read CMD.  But if you
type `C-x', another character is read; if that is `4', another
character is read, and so on.  For example,

     M-x global-set-key RET C-x 4 $ spell-other-window RET

would redefine `C-x 4 $' to run the (fictitious) command
`spell-other-window'.

   You can remove the global definition of a key with
`global-unset-key'.  This makes the key "undefined"; if you type it,
Emacs will just beep.  Similarly, `local-unset-key' makes a key
undefined in the current major mode keymap, which makes the global
definition (or lack of one) come back into effect in that major mode.

   If you have redefined (or undefined) a key and you subsequently wish
to retract the change, undefining the key will not do the job--you need
to redefine the key with its standard definition.  To find the name of
the standard definition of a key, go to a Fundamental mode buffer and
use `C-h c'.  The documentation of keys in this manual also lists their
command names.

   If you want to prevent yourself from invoking a command by mistake,
it is better to disable the command than to undefine the key.  A
disabled command is less work to invoke when you really want to.  *Note
Disabling::.


File: emacs,  Node: Init Rebinding,  Next: Function Keys,  Prev: Rebinding,  Up: Key Bindings

Rebinding Keys in Your Init File
--------------------------------

   If you have a set of default definitions that you like to use all
the time, you can put commands in your `.emacs' file by using their
Lisp syntax.  Thus, the first `global-set-key' command in this section
could be put in an `.emacs' file in either of the two following formats:

     (global-set-key "\C-z" 'shell)

   or as:

     (global-set-key [?\C-z] 'shell)

When the key sequence consists of ASCII characters and Meta characters,
like this one, you can write it as a string or as a vector.  The first
format specifies the key sequence as a string, `"\C-z"'.  The second
format uses a vector to specify the key sequence.  The square brackets
(`[...]') delimit the contents of the vector.  The vector in this
example contains just one element, which is the integer code
corresponding to `C-z'.  The question mark is the Lisp syntax for a
character constant; the character must follow with no intervening
spaces.

   The single-quote before `shell' marks it as a constant symbol rather
than a variable.  If you omit the quote, Emacs tries to evaluate
`shell' immediately as a variable.  This probably causes an error; it
certainly isn't what you want.

   Here is another example that binds a key sequence two characters
long:

     (global-set-key "\C-xl" 'make-symbolic-link)

   or:

     (global-set-key [?\C-x ?l] 'make-symbolic-link)

   When the key sequence includes function keys or mouse button events,
or non-ASCII characters such as `C-=' or `H-a', you must use a vector.

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [C-H-mouse-1] 'make-symbolic-link)


File: emacs,  Node: Function Keys,  Next: Named ASCII Chars,  Prev: Init Rebinding,  Up: Key Bindings

Rebinding Function Keys
-----------------------

   Key sequences can contain function keys as well as ordinary
characters.  Just as Lisp characters (actually integers) represent
keyboard characters, Lisp symbols represent function keys.  If the
function key has a word as its label, then that word is also the name of
the corresponding Lisp symbol.  Here are the conventional Lisp names for
other function keys:

`left', `up', `right', `down'
     Cursor arrow keys.

`begin', `end', `home', `next', `prior'
     Other cursor repositioning keys.

`select', `print', `execute', `backtab'
`insert', `undo', `redo', `clearline'
`insertline', `deleteline', `insertchar', `deletechar',
     Miscellaneous function keys.

`f1' ... `f35'
     Numbered function keys (across the top of the keyboard).

`kp-add', `kp-subtract', `kp-multiply', `kp-divide'
`kp-backtab', `kp-space', `kp-tab', `kp-enter'
`kp-separator', `kp-decimal', `kp-equal'
     Keypad keys (to the right of the regular keyboard), with names or
     punctuation.

`kp-0', `kp-1', ... `kp-9'
     Keypad keys with digits.

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     Keypad PF keys.

   These names are conventional, but some systems (especially when using
X windows) may use different names.  To make certain what symbol is used
for a given function key on your terminal, type `C-h c' followed by
that key.

   A key sequence which contains non-characters must be a vector rather
than a string.  To write a vector, write square brackets containing the
vector elements.  Write spaces to separate the elements.  If an element
is a symbol, simply write the symbol's name--no delimiters or
punctuation are needed.  If an element is a character, write a Lisp
character constant, which is `?' followed by the character as it would
appear in a string.

   Thus, to bind function key `f1' to the command `rmail', write the
following:

     (global-set-key [f1] 'rmail)

   To bind the right-arrow key to the command `forward-char', you can
use this expression:

     (global-set-key [right] 'forward-char)

using the Lisp syntax for a vector containing the symbol `right'.
(This binding is present in Emacs by default.)

   You can mix function keys and characters in a key sequence.  This
example binds `C-x RIGHT' to the command `forward-page'.

     (global-set-key [?\C-x right] 'forward-page)

where `?\C-x' is the Lisp character constant for the character `C-x'.
The vector element `right' is a symbol and therefore does not take a
question mark.

   You can use the modifier keys CTRL, META, HYPER, SUPER, ALT and
SHIFT with function keys.  To represent these modifiers, prepend the
strings `C-', `M-', `H-', `s-', `A-' and `S-' to the symbol name.
Thus, here is how to make `Hyper-Meta-RIGHT' move forward a word:

     (global-set-key [H-M-right] 'forward-word)


File: emacs,  Node: Named ASCII Chars,  Next: Mouse Buttons,  Prev: Function Keys,  Up: Key Bindings

Named ASCII Control Characters
------------------------------

   TAB, RET, BS, LFD, ESC and DEL started out as names for certain
ASCII control characters, used so often that they have special keys of
their own.  Later, users found it convenient to distinguish in Emacs
between these keys and the "same" control characters typed with the
CTRL key.

   Emacs 19 distinguishes these two kinds of input, when used with the X
Window System.  It treats the "special" keys as function keys named
`tab', `return', `backspace', `linefeed', `escape', and `delete'.
These function keys translate automatically into the corresponding
ASCII characters *if* they have no bindings of their own.  As a result,
neither users nor Lisp programs need to pay attention to the
distinction unless they care to.

   If you do not want to distinguish between (for example) TAB and
`C-i', then make a binding for the ASCII character TAB (octal code
011).  If you do want to distinguish, make one binding for this ASCII
character, and another for the "function key" `tab'.

   With an ordinary ASCII terminal, there is no way to distinguish
between TAB and `C-i' (and so on), because the terminal sends the same
character in both cases.


File: emacs,  Node: Mouse Buttons,  Next: Disabling,  Prev: Named ASCII Chars,  Up: Key Bindings

Rebinding Mouse Buttons
-----------------------

   Emacs uses Lisp symbols to designate mouse buttons, too.  The
ordinary mouse events in Emacs are "click" events; these happen when you
press a button and release it without moving the mouse.  You can also
get "drag" events, when you move the mouse while holding the button
down.  Drag events happen when you finally let go of the button.

   The symbols for basic click events are `mouse-1' for the leftmost
button, `mouse-2' for the next, and so on.  Here is how you can
redefine the second mouse button to split the current window:

     (global-set-key [mouse-2] 'split-window-vertically)

   The symbols for drag events are similar, but have the prefix `drag-'
before the word `mouse'.  For example, dragging the left button
generates a `drag-mouse-1' event.

   You can also define events that occur when a mouse button is pressed
down.  These events start with `down-' instead of `drag-'.  Such events
are generated only if they have key bindings.  When you get a
button-down event, a corresponding click or drag event will always
follow.

   If you wish, you can distinguish single, double, and triple clicks.
A double click means clicking a mouse button twice in approximately the
same place.  The first click generates an ordinary click event.  The
second click, if it comes soon enough, generates a double-click event
instead.  The event type for a double click event starts with
`double-': for example, `double-mouse-3'.

   This means that you can give a special meaning to the second click at
the same place, but it must act on the assumption that the ordinary
single click definition has run when the first click was received.

   This constrains what you can do with double clicks, but user
interface designers say that this constraint ought to be followed in
any case.  A double click should do something similar to the single
click, only "more so".  The command for the double-click event should
perform the extra work for the double click.

   If a double-click event has no binding, it changes to the
corresponding single-click event.  Thus, if you don't define a
particular double click specially, it executes the single-click command
twice.

   Emacs also supports triple-click events whose names start with
`triple-'.  Emacs does not distinguish quadruple clicks as event types;
clicks beyond the third generate additional triple-click events.
However, the full number of clicks is recorded in the event list, so you
can distinguish if you really want to.  We don't recommend distinct
meanings for more than three clicks, but sometimes it is useful for
subsequent clicks to cycle through the same set of three meanings, so
that four clicks are equivalent to one click, five are equivalent to
two, and six are equivalent to three.

   Emacs also records multiple presses in drag and button-down events.
For example, when you press a button twice, then move the mouse while
holding the button, Emacs gets a `double-drag-' event.  And at the
moment when you press it down for the second time, Emacs gets a
`double-down-' event (which is ignored, like all button-down events, if
it has no binding).

   The variable `double-click-time' specifies how long may elapse
between clicks that are recognized as a pair.  Its value is measured in
milliseconds.  If the value is `nil', double clicks are not detected at
all.  If the value is `t', then there is no time limit.

   The symbols for mouse events also indicate the status of the modifier
keys, with the usual prefixes `C-', `M-', `H-', `s-', `A-' and `S-'.
These always precede `double-' or `triple-', which always precede
`drag-' or `down-'.

   A frame includes areas that don't show text from the buffer, such as
the mode line and the scroll bar.  You can tell whether a mouse button
comes from a special area of the screen by means of dummy "prefix
keys."  For example, if you click the mouse in the mode line, you get
the prefix key `mode-line' before the ordinary mouse-button symbol.
Thus, here is how to define the command for clicking the left button in
a mode line to run `scroll-up':

     (global-set-key [mode-line mouse-1] 'scroll-up)

   Here is the complete list of these dummy prefix keys and their
meanings:

`mode-line'
     The mouse was in the mode line of a window.

`vertical-line'
     The mouse was in the vertical line separating side-by-side windows.

`vertical-scroll-bar'
     The mouse was in a vertical scroll bar.  This is the kind of scroll
     bar people normally use.

`horizontal-scroll-bar'
     The mouse was in a horizontal scroll bar.  Horizontal scroll bars
     do horizontal scrolling, and people don't use them often.

   You can put more than one mouse button in a key sequence, but it
isn't usual to do so.


File: emacs,  Node: Disabling,  Prev: Mouse Buttons,  Up: Key Bindings

Disabling Commands
------------------

   Disabling a command marks the command as requiring confirmation
before it can be executed.  The purpose of disabling a command is to
prevent beginning users from executing it by accident and being
confused.

   Attempting to invoke a disabled command interactively in Emacs
causes the display of a window containing the command's name, its
documentation, and some instructions on what to do immediately; then
Emacs asks for input saying whether to execute the command as
requested, enable it and execute, or cancel it.  If you decide to
enable the command, you are asked whether to do this permanently or
just for the current session.  Enabling permanently works by
automatically editing your `.emacs' file.

   The direct mechanism for disabling a command is to have a non-`nil'
`disabled' property on the Lisp symbol for the command.  Here is the
Lisp program to do this:

     (put 'delete-region 'disabled t)

   If the value of the `disabled' property is a string, that string is
included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   You can make a command disabled either by editing the `.emacs' file
directly or with the command `M-x disable-command', which edits the
`.emacs' file for you.  Likewise, `M-x enable-command' edits `.emacs'
to enable a command permanently.  *Note Init File::.

   Whether a command is disabled is independent of what key is used to
invoke it; it also applies if the command is invoked using `M-x'.
Disabling a command has no effect on calling it as a function from Lisp
programs.


File: emacs,  Node: Keyboard Translations,  Next: Syntax,  Prev: Key Bindings,  Up: Customization

Keyboard Translations
=====================

   Some keyboards do not make it convenient to send all the special
characters that Emacs uses.  The most common problem case is the DEL
character.  Some keyboards provide no convenient way to type this very
important character--usually because they were designed to expect the
character `C-h' to be used for deletion.  On these keyboard, if you
press the key normally used for deletion, Emacs handles the `C-h' as a
prefix character and offers you a list of help options, which is not
what you want.

   You can work around this problem within Emacs by setting up keyboard
translations to turn `C-h' into DEL and DEL into `C-h', as follows:

     ;; Translate `C-h' to DEL.
     (keyboard-translate ?\C-h ?\C-?)
     ;; Translate DEL to `C-h'.
     (keyboard-translate ?\C-? ?\C-h)

   Keyboard translations are not the same as key bindings in keymaps
(*note Keymaps::.).  Emacs contains numerous keymaps that apply in
different situations, but there is only one set of keyboard
translations, and it applies to every character that Emacs reads from
the terminal.  Keyboard translations take place at the lowest level of
input processing; the keys that are looked up in keymaps contain the
characters that result from keyboard translation.

   For full information about how to use keyboard translations, see
*Note Translating Input: (elisp)Translating Input.


File: emacs,  Node: Syntax,  Next: Init File,  Prev: Keyboard Translations,  Up: Customization

The Syntax Table
================

   All the Emacs commands which parse words or balance parentheses are
controlled by the "syntax table".  The syntax table says which
characters are opening delimiters, which are parts of words, which are
string quotes, and so on.  Each major mode has its own syntax table
(though sometimes related major modes use the same one) which it
installs in each buffer that uses that major mode.  The syntax table
installed in the current buffer is the one that all commands use, so we
call it "the" syntax table.  A syntax table is a Lisp object, a vector
of length 256 whose elements are numbers.

   To display a description of the contents of the current syntax table,
type `C-h s' (`describe-syntax').  The description of each character
includes both the string you would have to give to
`modify-syntax-entry' to set up that character's current syntax, and
some English to explain that string if necessary.

   For full information on the syntax table, see *Note Syntax Tables:
(elisp)Syntax Tables.


File: emacs,  Node: Init File,  Prev: Syntax,  Up: Customization

The Init File, `~/.emacs'
=========================

   When Emacs is started, it normally loads a Lisp program from the file
`.emacs' in your home directory.  We call this file your "init file"
because it specifies how to initialize Emacs for you.  You can use the
command line switches `-q' and `-u' to tell Emacs whether to load an
init file, and which one (*note Entering Emacs::.).

   There can also be a "default init file", which is the library named
`default.el', found via the standard search path for libraries.  The
Emacs distribution contains no such library; your site may create one
for local customizations.  If this library exists, it is loaded
whenever you start Emacs (except when you specify `-q').  But your init
file, if any, is loaded first; if it sets `inhibit-default-init'
non-`nil', then `default' is not loaded.

   If you have a large amount of code in your `.emacs' file, you should
move it into another file such as `~/SOMETHING.el', byte-compile it,
and make your `.emacs' file load it with `(load "~/SOMETHING")'.  *Note
Byte Compilation: (elisp)Byte Compilation, for more information about
compiling Emacs Lisp programs.

* Menu:

* Init Syntax::	     Syntax of constants in Emacs Lisp.
* Init Examples::    How to do some things with an init file.
* Terminal Init::    Each terminal type can have an init file.
* Find Init::	     How Emacs finds the init file.


File: emacs,  Node: Init Syntax,  Next: Init Examples,  Up: Init File

Init File Syntax
----------------

   The `.emacs' file contains one or more Lisp function call
expressions.  Each of these consists of a function name followed by
arguments, all surrounded by parentheses.  For example, `(setq
fill-column 60)' calls the function `setq' to set the variable
`fill-column' (*note Filling::.) to 60.

   The second argument to `setq' is an expression for the new value of
the variable.  This can be a constant, a variable, or a function call
expression.  In `.emacs', constants are used most of the time.  They
can be:

Numbers:
     Numbers are written in decimal, with an optional initial minus
     sign.

Strings:
     Lisp string syntax is the same as C string syntax with a few extra
     features.  Use a double-quote character to begin and end a string
     constant.

     In a string, you can include newlines and special characters
     literally.  But often it is cleaner to use backslash sequences for
     them: `\n' for newline, `\b' for backspace, `\r' for carriage
     return, `\t' for tab, `\f' for formfeed (control-L), `\e' for
     escape, `\\' for a backslash, `\"' for a double-quote, or `\OOO'
     for the character whose octal code is OOO.  Backslash and
     double-quote are the only characters for which backslash sequences
     are mandatory.

     `\C-' can be used as a prefix for a control character, as in
     `\C-s' for ASCII control-S, and `\M-' can be used as a prefix for
     a Meta character, as in `\M-a' for `Meta-A' or `\M-\C-a' for
     `Control-Meta-A'.

Characters:
     Lisp character constant syntax consists of a `?' followed by
     either a character or an escape sequence starting with `\'.
     Examples: `?x', `?\n', `?\"', `?\)'.  Note that strings and
     characters are not interchangeable in Lisp; some contexts require
     one and some contexts require the other.

True:
     `t' stands for `true'.

False:
     `nil' stands for `false'.

Other Lisp objects:
     Write a single-quote (') followed by the Lisp object you want.


File: emacs,  Node: Init Examples,  Next: Terminal Init,  Prev: Init Syntax,  Up: Init File

Init File Examples
------------------

   Here are some examples of doing certain commonly desired things with
Lisp expressions:

   * Make TAB in C mode just insert a tab if point is in the middle of a
     line.

          (setq c-tab-always-indent nil)

     Here we have a variable whose value is normally `t' for `true' and
     the alternative is `nil' for `false'.

   * Make searches case sensitive by default (in all buffers that do not
     override this).

          (setq-default case-fold-search nil)

     This sets the default value, which is effective in all buffers
     that do not have local values for the variable.  Setting
     `case-fold-search' with `setq' affects only the current buffer's
     local value, which is not what you probably want to do in an init
     file.

   * Make Text mode the default mode for new buffers.

          (setq default-major-mode 'text-mode)

     Note that `text-mode' is used because it is the command for
     entering Text mode.  The single-quote before it makes the symbol a
     constant; otherwise, `text-mode' would be treated as a variable
     name.

   * Turn on Auto Fill mode automatically in Text mode and related
     modes.

          (add-hook 'text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     This shows how to add a hook function to a normal hook variable
     (*note Hooks::.).  The function we supply is a list starting with
     `lambda', with a single-quote in front of it to make it a list
     constant rather than an expression.

     It's beyond the scope of this manual to explain Lisp functions,
     but for this example it is enough to know that the effect is to
     execute `(auto-fill-mode 1)' when Text mode is entered.  You can
     replace it with any other expression that you like, or with
     several expressions in a row.

     Emacs comes with a function named `turn-on-auto-fill' whose
     definition is `(lambda () (auto-fill-mode 1))'.  Thus, a simpler
     way to write the above example is as follows:

          (add-hook 'text-mode-hook 'turn-on-auto-fill)

   * Load the installed Lisp library named `foo' (actually a file
     `foo.elc' or `foo.el' in a standard Emacs directory).

          (load "foo")

     When the argument to `load' is a relative file name, not starting
     with `/' or `~', `load' searches the directories in `load-path'
     (*note Lisp Libraries::.).

   * Load the compiled Lisp file `foo.elc' from your home directory.

          (load "~/foo.elc")

     Here an absolute file name is used, so no searching is done.

   * Rebind the key `C-x l' to run the function `make-symbolic-link'.

          (global-set-key "\C-xl" 'make-symbolic-link)

     or

          (define-key global-map "\C-xl" 'make-symbolic-link)

     Note once again the single-quote used to refer to the symbol
     `make-symbolic-link' instead of its value as a variable.

   * Do the same thing for C mode only.

          (define-key c-mode-map "\C-xl" 'make-symbolic-link)

   * Redefine all keys which now run `next-line' in Fundamental mode so
     that they run `forward-line' instead.

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * Make `C-x C-v' undefined.

          (global-unset-key "\C-x\C-v")

     One reason to undefine a key is so that you can make it a prefix.
     Simply defining `C-x C-v ANYTHING' will make `C-x C-v' a prefix,
     but `C-x C-v' must first be freed of its usual non-prefix
     definition.

   * Make `$' have the syntax of punctuation in Text mode.  Note the
     use of a character constant for `$'.

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * Enable the use of the command `eval-expression' without
     confirmation.

          (put 'eval-expression 'disabled nil)


File: emacs,  Node: Terminal Init,  Next: Find Init,  Prev: Init Examples,  Up: Init File

Terminal-specific Initialization
--------------------------------

   Each terminal type can have a Lisp library to be loaded into Emacs
when it is run on that type of terminal.  For a terminal type named
TERMTYPE, the library is called `term/TERMTYPE' and it is found by
searching the directories `load-path' as usual and trying the suffixes
`.elc' and `.el'.  Normally it appears in the subdirectory `term' of
the directory where most Emacs libraries are kept.

   The usual purpose of the terminal-specific library is to map the
escape sequences used by the terminal's function keys onto more
meaningful names, using `function-key-map'.  See the file
`term/lk201.el' for an example of how this is done.

   When the terminal type contains a hyphen, only the part of the name
before the first hyphen is significant in choosing the library name.
Thus, terminal types `aaa-48' and `aaa-30-rv' both use the library
`term/aaa'.  The code in the library can use `(getenv "TERM")' to find
the full terminal type name.

   The library's name is constructed by concatenating the value of the
variable `term-file-prefix' and the terminal type.  Your `.emacs' file
can prevent the loading of the terminal-specific library by setting
`term-file-prefix' to `nil'.

   Emacs runs the hook `term-setup-hook' at the end of initialization,
after both your `.emacs' file and any terminal-specific library have
been read in.  Add hook functions to this hook if you wish to override
part of any of the terminal-specific libraries and to define
initializations for terminals that do not have a library.  *Note
Hooks::.


File: emacs,  Node: Find Init,  Prev: Terminal Init,  Up: Init File

How Emacs Finds Your Init File
------------------------------

   Normally Emacs uses the environment variable `HOME' to find
`.emacs'; that's what `~' means in a file name.  But if you have done
`su', Emacs tries to find your own `.emacs', not that of the user you
are currently pretending to be.  The idea is that you should get your
own editor customizations even if you are running as the super user.

   More precisely, Emacs first determines which user's init file to use.
It gets the user name from the environment variables `LOGNAME' and
`USER'; if neither of those exists, it uses effective user-ID.  If that
user name matches the real user-ID, then Emacs uses `HOME'; otherwise,
it looks up the home directory corresponding to that user name in the
system's data base of users.


File: emacs,  Node: Quitting,  Next: Lossage,  Prev: Customization,  Up: Top

Quitting and Aborting
=====================

`C-g'
     Quit.  Cancel running or partially typed command.

`C-]'
     Abort innermost recursive editing level and cancel the command
     which invoked it (`abort-recursive-edit').

`M-x top-level'
     Abort all recursive editing levels that are currently executing.

`C-x u'
     Cancel an already-executed command, usually (`undo').

   There are two ways of cancelling commands which are not finished
executing: "quitting" with `C-g', and "aborting" with `C-]' or `M-x
top-level'.  Quitting cancels a partially typed command or one which is
already running.  Aborting exits a recursive editing level and cancels
the command that invoked the recursive edit.  (*Note Recursive Edit::.)

   Quitting with `C-g' is used for getting rid of a partially typed
command, or a numeric argument that you don't want.  It also stops a
running command in the middle in a relatively safe way, so you can use
it if you accidentally give a command which takes a long time.  In
particular, it is safe to quit out of killing; either your text will
*all* still be in the buffer, or it will *all* be in the kill ring (or
maybe both).  Quitting an incremental search does special things
documented under searching; in general, it may take two successive
`C-g' characters to get out of a search.

   `C-g' works by setting the variable `quit-flag' to `t' the instant
`C-g' is typed; Emacs Lisp checks this variable frequently and quits if
it is non-`nil'.  `C-g' is only actually executed as a command if you
type it while Emacs is waiting for input.

   If you quit with `C-g' a second time before the first `C-g' is
recognized, you activate the "emergency escape" feature and return to
the shell.  *Note Emergency Escape::.

   There may be times when you cannot quit.  When Emacs is waiting for
the operating system to do something, quitting is impossible unless
special pains are taken for the particular system call within Emacs
where the waiting occurs.  We have done this for the system calls that
users are likely to want to quit from, but it's possible you will find
another.  In one very common case--waiting for file input or output
using NFS--Emacs itself knows how to quit, but most NFS implementations
simply do not allow user programs to stop waiting for NFS when the NFS
server is hung.

   Aborting with `C-]' (`abort-recursive-edit') is used to get out of a
recursive editing level and cancel the command which invoked it.
Quitting with `C-g' does not do this, and could not do this, because it
is used to cancel a partially typed command *within* the recursive
editing level.  Both operations are useful.  For example, if you are in
a recursive edit and type `C-u 8' to enter a numeric argument, you can
cancel that argument with `C-g' and remain in the recursive edit.

   The command `M-x top-level' is equivalent to "enough" `C-]' commands
to get you out of all the levels of recursive edits that you are in.
`C-]' gets you out one level at a time, but `M-x top-level' goes out
all levels at once.  Both `C-]' and `M-x top-level' are like all other
commands, and unlike `C-g', in that they are effective only when Emacs
is ready for a command.  `C-]' is an ordinary key and has its meaning
only because of its binding in the keymap.  *Note Recursive Edit::.

   `C-x u' (`undo') is not strictly speaking a way of cancelling a
command, but you can think of it as cancelling a command already
finished executing.  *Note Undo::.


File: emacs,  Node: Lossage,  Next: Bugs,  Prev: Quitting,  Up: Top

Dealing with Emacs Trouble
==========================

   This section describes various conditions in which Emacs fails to
work normally, and how to recognize them and correct them.

* Menu:

* DEL Gets Help::       What to do if DEL doesn't delete.
* Stuck Recursive::     `[...]' in mode line around the parentheses.
* Screen Garbled::      Garbage on the screen.
* Text Garbled::        Garbage in the text.
* Unasked-for Search::  Spontaneous entry to incremental search.
* Emergency Escape::    Emergency escape--
                          What to do if Emacs stops responding.
* Total Frustration::   When you are at your wits' end.


File: emacs,  Node: DEL Gets Help,  Next: Stuck Recursive,  Up: Lossage

If DEL Fails to Delete
----------------------

   If you find that DEL enters Help like `Control-h' instead of
deleting a character, your terminal is sending the wrong code for DEL.
You can work around this problem by changing the keyboard translation
table (*note Keyboard Translations::.).


File: emacs,  Node: Stuck Recursive,  Next: Screen Garbled,  Prev: DEL Gets Help,  Up: Lossage

Recursive Editing Levels
------------------------

   Recursive editing levels are important and useful features of Emacs,
but they can seem like malfunctions to the user who does not understand
them.

   If the mode line has square brackets `[...]' around the parentheses
that contain the names of the major and minor modes, you have entered a
recursive editing level.  If you did not do this on purpose, or if you
don't understand what that means, you should just get out of the
recursive editing level.  To do so, type `M-x top-level'.  This is
called getting back to top level.  *Note Recursive Edit::.

