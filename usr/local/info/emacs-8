This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Split Window,  Next: Other Window,  Prev: Basic Window,  Up: Windows

Splitting Windows
=================

`C-x 2'
     Split the selected window into two windows, one above the other
     (`split-window-vertically').

`C-x 3'
     Split the selected window into two windows positioned side by side
     (`split-window-horizontally').

   The command `C-x 2' (`split-window-vertically') breaks the selected
window into two windows, one above the other.  Both windows start out
displaying the same buffer, with the same value of point.  By default
the two windows each get half the height of the window that was split; a
numeric argument specifies how many lines to give to the top window.

   `C-x 3' (`split-window-horizontally') breaks the selected window
into two side-by-side windows.  A numeric argument specifies how many
columns to give the one on the left.  A line of vertical bars separates
the two windows.  Windows that are not the full width of the screen
have mode lines, but they are truncated; also, they do not always
appear in inverse video, because the Emacs display routines have not
been taught how to display a region of inverse video that is only part
of a line on the screen.

   When a window is less than the full width, text lines too long to
fit are frequent.  Continuing all those lines might be confusing.  The
variable `truncate-partial-width-windows' can be set non-`nil' to force
truncation in all windows less than the full width of the screen,
independent of the buffer being displayed and its value for
`truncate-lines'.  *Note Continuation Lines::.

   Horizontal scrolling is often used in side-by-side windows.  *Note
Display::.

   If `split-window-keep-point' is non-nil, `C-x 2' tries to avoid
shifting any text on the screen by putting point in whichever window
happens to contain the screen line the cursor is already on.  The
default is that `split-window-keep-point' is non-nil on slow terminals.


File: emacs,  Node: Other Window,  Next: Pop Up Window,  Prev: Split Window,  Up: Windows

Using Other Windows
===================

`C-x o'
     Select another window (`other-window').  That is `o', not zero.

`C-M-v'
     Scroll the next window (`scroll-other-window').

`M-x compare-windows'
     Find next place where the text in the selected window does not
     match the text in the next window.

   To select a different window, use `C-x o' (`other-window').  That is
an `o', for `other', not a zero.  When there are more than two windows,
this command moves through all the windows in a cyclic order, generally
top to bottom and left to right.  After the rightmost and bottommost
window, it goes back to the one at the upper left corner.  A numeric
argument means to move several steps in the cyclic order of windows.  A
negative argument moves around the cycle in the opposite order.  When
the minibuffer is active, the minibuffer is the last window in the
cycle; you can switch from the minibuffer window to one of the other
windows, and later switch back and finish supplying the minibuffer
argument that is requested.  *Note Minibuffer Edit::.

   The usual scrolling commands (*note Display::.) apply to the selected
window only, but there is one command to scroll the next window.
`C-M-v' (`scroll-other-window') scrolls the window that `C-x o' would
select.  It takes arguments, positive and negative, like `C-v'.  (In
the minibuffer, `C-M-v' scrolls the window that contains the minibuffer
help display, if any, rather than the next window in the standard
cyclic order.)

   The command `M-x compare-windows' lets you compare two files or
buffers visible in two windows, by moving through them to the next
mismatch.  *Note Comparing Files::.


File: emacs,  Node: Pop Up Window,  Next: Change Window,  Prev: Other Window,  Up: Windows

Displaying in Another Window
============================

   `C-x 4' is a prefix key for commands that select another window
(splitting the window if there is only one) and select a buffer in that
window.  Different `C-x 4' commands have different ways of finding the
buffer to select.

`C-x 4 b BUFNAME RET'
     Select buffer BUFNAME in another window.  This runs
     `switch-to-buffer-other-window'.

`C-x 4 C-o BUFNAME RET'
     Display buffer BUFNAME in another window, but don't select that
     buffer or that window.  This runs `display-buffer'.

`C-x 4 f FILENAME RET'
     Visit file FILENAME and select its buffer in another window.  This
     runs `find-file-other-window'.  *Note Visiting::.

`C-x 4 d DIRECTORY RET'
     Select a Dired buffer for directory DIRECTORY in another window.
     This runs `dired-other-window'.  *Note Dired::.

`C-x 4 m'
     Start composing a mail message in another window.  This runs
     `mail-other-window'; its same-window analogue is `C-x m' (*note
     Sending Mail::.).

`C-x 4 .'
     Find a tag in the current tag table in another window.  This runs
     `find-tag-other-window', the multiple-window variant of `M-.'
     (*note Tags::.).

`C-x 4 r FILENAME RET'
     Visit file FILENAME read-only, and select its buffer in another
     window.  This runs `find-file-read-only-other-window'.  *Note
     Visiting::.


File: emacs,  Node: Change Window,  Prev: Pop Up Window,  Up: Windows

Deleting and Rearranging Windows
================================

`C-x 0'
     Get rid of the selected window (`delete-window').  That is a zero.

`C-x 1'
     Get rid of all windows except the selected one
     (`delete-other-windows').

`C-x ^'
     Make selected window taller (`enlarge-window').

`C-x }'
     Make selected window wider (`enlarge-window-horizontally').

   To delete a window, type `C-x 0' (`delete-window').  (That is a
zero.)  The space occupied by the deleted window is given to an
adjacent window (but not the minibuffer window, even if that is active
at the time).  Once a window is deleted, its attributes are forgotten;
only restoring a window configuration can bring it back.  Deleting the
window has no effect on the buffer it used to display; the buffer
continues to exist, and you can select it in any window with `C-x b'.

   `C-x 1' (`delete-other-windows') is more powerful than `C-x 0'; it
deletes all the windows except the selected one (and the minibuffer);
the selected window expands to use the whole frame except for the echo
area.

   To readjust the division of space among vertically adjacent windows,
use `C-x ^' (`enlarge-window').  It makes the currently selected window
get one line bigger, or as many lines as is specified with a numeric
argument.  With a negative argument, it makes the selected window
smaller.  `C-x }' (`enlarge-window-horizontally') makes the selected
window wider by the specified number of columns.  The extra screen
space given to a window comes from one of its neighbors, if that is
possible.  If this makes any window too small, it is deleted and its
space is given to an adjacent window.  The minimum size is specified by
the variables `window-min-height' and `window-min-width'.


File: emacs,  Node: Frames,  Next: Major Modes,  Prev: Windows,  Up: Top

Frames and X Windows
********************

   When using the X Window System, you can create multiple windows at
the X level in a single Emacs session.  Each X window that belongs to
Emacs displays a "frame" which can contain one or several Emacs windows.
A frame initially contains a single general-purpose Emacs window which
you can subdivide vertically or horizontally into smaller windows.  A
frame normally contains its own echo area and minibuffer, but you can
make frames that don't have these--they use the echo area and
minibuffer of another frame.

   Anything you do in one frame also affects the other frames.  For
instance, if you put text in the kill ring in one frame, you can yank it
in another frame.  If you exit emacs through `C-x C-c' in one frame, it
terminates all the frames.  To delete just one frame, use `C-x 5 0'.

   To avoid confusion, we reserve the word "window" for the
subdivisions that Emacs implements, and never use it to refer to a
frame.

* Menu:

* Mouse Commands::     Moving, cutting, and pasting, with the mouse.
* Secondary Selection::Cutting without altering point and mark.
* Selecting Mouse::    Using the mouse to select an item from a list.
* Mode Line Mouse::    Mouse clicks on the mode line.
* Creating Frames::    Creating additional Emacs frames with various contents.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::   Changing the colors and other modes of frames.
* Scroll Bars::	       How to enable and disable scroll bars; how to use them.
* Menu Bars::	       Enabling and disabling the menu bar.
* Faces::	       How to change the display style using faces.
* Modifying Faces::    How to change what a particular face looks like.
* Misc X::	       Iconifying and deleting frames.	Region highlighting.


File: emacs,  Node: Mouse Commands,  Next: Secondary Selection,  Up: Frames

Mouse Commands
==============

`mouse-1'
     Move point to where you click (`mouse-set-point').  This is
     normally the left button.

`drag-mouse-1'
     Set the region to the text you select by dragging, and copy it to
     the kill ring (`mouse-set-region'). Thus, you can specify both
     ends of the region.

     If you move the mouse off the top or bottom of the window while
     dragging, the window scrolls at a steady rate until you move the
     mouse back into the window.  This way, you can mark regions that
     don't fit entirely on the screen.

`mouse-2'
     Yank the last killed text, where you click (`mouse-yank-at-click').
     This is normally the middle button.

`mouse-3'
     This command, `mouse-save-then-kill', has several functions
     depending on where you click and the status of the region.

     If you have a highlighted region, or if the region was set just
     before by dragging button 1, `mouse-save-then-kill' adjusts the
     nearer end of the region by moving it to where you click.  The
     adjusted region's text also replaces the old region's text in the
     kill ring.

     Otherwise, `mouse-save-then-kill' sets mark where you click,
     without changing point.  It copies the new region to the kill ring.

     If you originally specified the region using a double or triple
     Mouse-1, so that the region is defined to consist of entire words
     or lines, then adjusting the region also proceeds by entire words
     or lines.

     If you use `mouse-save-then-kill' twice in a row at the same place,
     that kills the region already selected.

`double-mouse-1'
     This key sets the region around the word which you click on.

`double-drag-mouse-1'
     This key selects a region made up of the words that you drag
     across.

`triple-mouse-1'
     This key sets the region around the line which you click on.

`triple-drag-mouse-1'
     This key selects a region made up of the lines that you drag
     across.

   The simplest way to kill some text is to press Mouse-1 at one end,
then press Mouse-3 twice at the other end.  *Note Killing::.  To copy
the text into the kill ring without deleting it from the buffer, press
Mouse-3 just once--or just drag across the text with Mouse-1.  Then you
can copy it elsewhere by yanking it.

   To yank the killed or copied text somewhere else, move the mouse
there and press Mouse-2.  *Note Yanking::.  If `mouse-yank-at-point' is
non-`nil', Mouse-2 yanks at point.  Then it does not matter precisely
where you click; all that matters is which window you click on.

   The mouse commands for selecting a region are mostly compatible with
the `xterm' program.

   To copy text to another X window, kill it or save it in the kill
ring.  Under X, this also sets the "primary selection".  Then use the
"paste" or "yank" command of the program operating the other window to
insert the text from the selection.

   To copy text from another X window, use the "cut" or "copy" command
of the program operating the other window, to select the text you want.
Then yank it in Emacs with `C-y' or Mouse-2.

   When Emacs puts text into the kill ring, or rotates text to the front
of the kill ring, it sets the "primary selection" in the X server.
This is how other X clients can access the text.  Emacs also stores the
text in the cut buffer, if the text is short enough (`x-cut-buffer-max'
specifies the maximum number of characters); putting long strings in
the cut buffer can be slow.

   When you yank in Emacs, Emacs checks for a primary selection in
another program; after that, it checks for text in the cut buffer.


File: emacs,  Node: Secondary Selection,  Next: Selecting Mouse,  Prev: Mouse Commands,  Up: Frames

Secondary Selection
===================

   The "secondary selection" is another way of selecting text using X.
It does not use point or the mark, so you can use it to kill text
without setting point or the mark.

`drag-M-mouse-1'
     Set the secondary selection, with one end at the place where you
     press down the button, and the other end at the place where you
     release it (`mouse-set-secondary').  In Transient Mark mode,
     highlighting appears and changes as you drag.

     If you move the mouse off the top or bottom of the window while
     dragging, the window scrolls at a steady rate until you move the
     mouse back into the window.  This way, you can mark regions that
     don't fit entirely on the screen.

`M-mouse-1'
     Set one endpoint for the "secondary selection"
     (`mouse-start-secondary').

`M-mouse-3'
     Make a secondary selection, using the place specified with
     `M-mouse-1' as the other end (`mouse-secondary-save-then-kill').
     A second click at the same place kills the secondary selection
     just made.

`M-mouse-2'
     Insert the secondary selection where you click
     (`mouse-kill-secondary').  This places point to the end of the
     yanked text.

   Double or triple clicking of `M-Mouse-1' operates on words and
lines, much like Mouse-1.

   If `mouse-yank-at-point' is non-`nil', `M-Mouse-2' yanks at point.
Then it does not matter precisely where you click; all that matters is
which window you click on.


File: emacs,  Node: Selecting Mouse,  Next: Mode Line Mouse,  Prev: Secondary Selection,  Up: Frames

Selecting with the Mouse
========================

   Some Emacs buffers display lists of various sorts.  These include
lists of files, of buffers, of possible completions, of matches for a
pattern, and so on.

   Since modifying the text in these buffers is not often useful, most
of them define Mouse-2 specially, as a command to use or view the item
you click on.

   For example, if you click Mouse-2 on a file name in a Dired buffer,
you visit the that file.  If you click Mouse-2 on an error message in
the `*Compilation*' buffer, you go to the source code for that error
message.  If you click Mouse-2 on a completion in the `*Completions*'
buffer, you choose that completion.

   You can usually tell when Mouse-2 has this special sort of meaning
because the sensitive text highlights when you move the mouse over it.


File: emacs,  Node: Mode Line Mouse,  Next: Creating Frames,  Prev: Selecting Mouse,  Up: Frames

Mode Line Mouse Commands
========================

   You can use mouse clicks on window mode lines to select and
manipulate windows.

`Mouse-1'
     Mouse-1 on a mode line selects the window above.

`Mouse-2'
     Mouse-2 on a mode line expands that window to fill its frame.

`Mouse-3'
     Mouse-3 on a mode line deletes the window above.

`C-Mouse-2'
     `C-Mouse-2' on a mode line splits the window above horizontally,
     above the point in the mode line where you click.


File: emacs,  Node: Creating Frames,  Next: Special Buffer Frames,  Prev: Mode Line Mouse,  Up: Frames

Creating Frames
===============

   The prefix key `C-x 5' is analogous to `C-x 4', with parallel
subcommands.  The difference is that `C-x 5' commands create a new
frame rather than just a new window in the selected frame.  (*Note Pop
Up Window::.)  Different `C-x 5' commands have different ways of
finding the buffer to select.

`C-x 5 b BUFNAME RET'
     Select buffer BUFNAME in another window.  This runs
     `switch-to-buffer-other-frame'.

`C-x 5 f FILENAME RET'
     Visit file FILENAME and select its buffer in another frame.  This
     runs `find-file-other-frame'.  *Note Visiting::.

`C-x 5 d DIRECTORY RET'
     Select a Dired buffer for directory DIRECTORY in another frame.
     This runs `dired-other-frame'.  *Note Dired::.

`C-x 5 m'
     Start composing a mail message in another frame.  This runs
     `mail-other-frame', and its same-frame version is `C-x m'.  *Note
     Sending Mail::.

`C-x 5 .'
     Find a tag in the current tag table in another frame.  This runs
     `find-tag-other-frame', the multiple-frame variant of `M-.'.
     *Note Tags::.

`C-x 5 r FILENAME RET'
     Visit file FILENAME read-only, and select its buffer in another
     frame.  This runs `find-file-read-only-other-frame'.  *Note
     Visiting::.


File: emacs,  Node: Special Buffer Frames,  Next: Frame Parameters,  Prev: Creating Frames,  Up: Frames

Special Buffer Frames
=====================

   You can make certain chosen buffers, that normally appear in a
separate window, appear in special frames of their own.  To do this, set
the variable `special-display-buffer-names' to a list of buffer names;
any buffer whose name is in that list automatically gets a special
frame when it is to be displayed in another window.

   For example, if you set the variable this way,

     (setq special-display-buffer-names
           '("*compilation*" "*grep*" "*TeX Shell*"))

then completion lists, `grep' output and the TeX mode shell buffer get
individual frames of their own.  These frames, and the windows in them,
are never automatically split or reused for any other buffers.  They
continue to show the buffers they were created for, unless you alter
them by hand.

   More generally, you can set `special-display-regexps' to a list of
regular expressions; then each buffer whose name matches any of those
regular expressions gets its own frame.

   The variable `special-display-frame-alist' specifies the frame
parameters for these frames.  It has a default value, so you don't need
to set it.


File: emacs,  Node: Frame Parameters,  Next: Scroll Bars,  Prev: Special Buffer Frames,  Up: Frames

Setting Frame Parameters
========================

   This section describes commands for altering the display style and
window management behavior of the selected frame.

`M-x set-foreground-color RET COLOR RET'
     Specify color COLOR for the foreground of the selected frame.

`M-x set-background-color RET COLOR RET'
     Specify color COLOR for the background of the selected frame.

`M-x set-cursor-color RET COLOR RET'
     Specify color COLOR for the cursor of the selected frame.

`M-x set-mouse-color RET COLOR RET'
     Specify color COLOR for the mouse cursor when it is over the
     selected frame.

`M-x set-border-color RET COLOR RET'
     Specify color COLOR for the border of the selected frame.

`M-x auto-raise-mode'
     Toggle whether or not the selected frame should auto-raise.
     Auto-raise means that every time you move the mouse onto the frame,
     it raises the frame.

`M-x auto-lower-mode'
     Toggle whether or not the selected frame should auto-lower.
     Auto-lower means that every time you move the mouse off of the
     frame, the frame moves to the bottom of the stack of X windows.

`M-x set-default-font RET FONT RET'
     Specify font FONT as the default for the selected frame.  *Note
     Font X::, for ways to list the available fonts on your system.

     You can also set a frame's default font through a pop-up menu.
     Press `C-Mouse-3' to activate this menu.

   In Emacs versions that use an X toolkit, the color-setting and
font-setting functions don't affect menus and the menu bar, since they
are displayed by their own widget classes.  To change the appearance of
the menus and menu bar, you must use X resources.  *Note Colors X::,
regarding colors.  *Note Font X::, regarding choice of font.


File: emacs,  Node: Scroll Bars,  Next: Menu Bars,  Prev: Frame Parameters,  Up: Frames

Scroll Bars
===========

   When using X, Emacs normally makes a "scroll bar" at the right of
each Emacs window.  The scroll bar runs the height of the window, and
shows a moving rectangular inner box which represents the portion of the
buffer currently displayed.  The entire height of the scroll bar
represents the entire length of the buffer.

   You can use Mouse-2 (normally, the middle button) in the scroll bar
to move or drag the inner box up and down.  If you move it to the top
of the scroll bar, you see the top of the buffer.  If you move it to
the bottom of the scroll bar, you see the bottom of the buffer.

   The left and right buttons in the scroll bar scroll by controlled
increments.  Mouse-1 (normally, the left button) moves the line at the
level where you click up to the top of the window.  Mouse-3 (normally,
the right button) moves the line at the top of the window down to the
level where you click.  By clicking repeatedly in the same place, you
can scroll by the same distance over and over.

   You can enable or disable Scroll Bar mode with the command `M-x
scroll-bar-mode'.  With no argument, it toggles the use of scroll bars.
With an argument, it turns use of scroll bars on if and only if the
argument is positive.  This command applies to all frames, including
frames yet to be created.

   To enable or disable scroll bars for just the selected frame, use the
`M-x toggle-scroll-bar' command.


File: emacs,  Node: Menu Bars,  Next: Faces,  Prev: Scroll Bars,  Up: Frames

Menu Bars
=========

   By default, each Emacs frame has a menu bar at the top which you can
use to perform certain common operations.  There's no need to describe
them in detail here, as you can more easily see for yourself; also, we
may change them and add to them in subsequent Emacs versions.

   Each of the operations in the menu bar is bound to an ordinary Emacs
command which you can invoke equally well with `M-x' or with its own
key bindings.  The menu lists one equivalent key binding (if the command
has any) at the right margin.  To see the command's name and
documentation, type `C-h k' and then select the menu bar item you are
interested in.

   You can turn display of menu bars on or off with `M-x menu-bar-mode'.
With no argument, this command toggles Menu Bar mode, a minor mode.
With an argument, the command turns Menu Bar mode on if the argument is
positive, off if the argument is not positive.


File: emacs,  Node: Faces,  Next: Modifying Faces,  Prev: Menu Bars,  Up: Frames

Using Multiple Typefaces
========================

   When using Emacs with X, you can set up multiple styles of displaying
characters.  The aspects of style that you can control are the type
font, the foreground color, the background color, and whether to
underline.

   The way you control display style is by defining named "faces".
Each face can specify a type font, a foreground color, a background
color, and an underline flag; but it does not have to specify all of
them.

   The style of display used for a given character in the text is
determined by combining several faces.  Which faces to use is always set
up by Lisp programs, at present, by means of text properties and
overlays.  Any aspect of the display style that isn't specified by
overlays or text properties comes from the frame itself.

   To see what faces are currently defined, and what they look like,
type `M-x list-faces-display'.  It's possible for a given face to look
different in different frames; this command shows the appearance in the
frame in which you type it.  Here's a list of the standardly defined
faces:

`default'
     This face is used for ordinary text that doesn't specify any other
     face.

`mode-line'
     This face is used for mode lines.  By default, it's set up as the
     inverse of the default face.  *Note Display Vars::.

`highlight'
     This face is used for highlighting portions of text, in various
     modes.

`region'
     This face is used for displaying a selected region.

`secondary-selection'
     This face is used for displaying a secondary selection (*note
     Secondary Selection::.).

`bold'
     This face uses a bold variant of the default font, if it has one.

`italic'
     This face uses an italic variant of the default font, if it has
     one.

`bold-italic'
     This face uses a bold italic variant of the default font, if it
     has one.

`underline'
     This face underlines text.

   When Transient Mark mode is enabled, the text of the region is
highlighted when the mark is active.  This uses the face named
`region'; you can control the style of highlighting by changing the
style of this face with the commands below.  *Note Transient Mark::, for
more information about Transient Mark mode and activation and
deactivation of the mark.

   One easy way to use faces is to turn on Font-Lock mode.  This minor
mode, which is always local to a particular buffer, arranges to choose
faces according to the syntax of the text you are editing.  It can
recognize comments and strings in any major mode; for several major
modes, it can also recognize and properly highlight various other
important parts of the text.  To get the full benefit of Font-Lock mode,
you need to choose a default font which has bold, italic, and
bold-italic variants.


File: emacs,  Node: Modifying Faces,  Next: Misc X,  Prev: Faces,  Up: Frames

Modifying Faces
===============

   Here are the commands for users to change the font of a face.

`M-x set-face-font RET FACE RET FONT RET'
     Use font FONT in face FACE.

`M-x make-face-bold RET FACE RET'
     Convert face FACE to use a bold version of its current font.

`M-x make-face-italic RET FACE RET'
     Convert face FACE to use a italic version of its current font.

`M-x make-face-bold-italic RET FACE RET'
     Convert face FACE to use a bold-italic version of its current font.

`M-x make-face-unbold RET FACE RET'
     Convert face FACE to use a non-bold version of its current font.

`M-x make-face-unitalic RET FACE RET'
     Convert face FACE to use a non-italic version of its current font.

   Here are the commands for users to set the colors and underline flag
of a face:

`M-x set-face-foreground RET FACE RET COLOR RET'
     Use color COLOR for the foreground of characters in face FACE.

`M-x set-face-background RET FACE RET COLOR RET'
     Use color COLOR for the background of characters in face FACE.

`M-x set-face-underline-p RET FACE RET FLAG RET'
     Specify whether to underline characters in face FACE.

`M-x invert-face RET FACE RET'
     Swap the foreground and background colors of face FACE.

   You can also use X resources to specify attributes of particular
faces.  *Note Resources X::.


File: emacs,  Node: Misc X,  Prev: Modifying Faces,  Up: Frames

Miscellaneous X Window Features
===============================

   The following commands do user-level mangement of frames under a
window system:

`C-z'
     To iconify the selected Emacs frame, type `C-z'
     (`iconify-or-deiconify-frame').  The normal meaning of `C-z', to
     suspend Emacs, is not useful under a window system, so it has a
     different binding in that case.

     If you type this command on an Emacs icon, it deiconifies the
     frame.

`C-x 5 0'
     To delete the selected frame, type `C-x 5 0' (`delete-frame').  If
     there is more than one frame in this invocation of Emacs, the
     current frame is deleted.

`M-x transient-mark-mode'
     Under X Windows, when Transient Mark mode is enabled, Emacs
     highlights the region when the mark is active.  This is the main
     motive for using Transient Mark mode.  To toggle the state of this
     mode, use the command `M-x transient-mark-mode'.  *Note Mark::.


File: emacs,  Node: Major Modes,  Next: Indentation,  Prev: Frames,  Up: Top

Major Modes
***********

   Emacs provides many alternative "major modes", each of which
customizes Emacs for editing text of a particular sort.  The major modes
are mutually exclusive, and each buffer has one major mode at any time.
The mode line normally shows the name of the current major mode, in
parentheses (*note Mode Line::.).

   The least specialized major mode is called "Fundamental mode".  This
mode has no mode-specific redefinitions or variable settings, so that
each Emacs command behaves in its most general manner, and each option
is in its default state.  For editing any specific type of text, such
as Lisp code or English text, you should switch to the appropriate
major mode, such as Lisp mode or Text mode.

   Selecting a major mode changes the meanings of a few keys to become
more specifically adapted to the language being edited.  The ones which
are changed frequently are TAB, DEL, and LFD.  In addition, the
commands which handle comments use the mode to determine how comments
are to be delimited.  Many major modes redefine the syntactical
properties of characters appearing in the buffer.  *Note Syntax::.

   The major modes fall into three major groups.  Lisp mode (which has
several variants), C mode, Fortran mode and others are for specific
programming languages.  Text mode, Nroff mode, TeX mode and Outline
mode are for editing English text.  The remaining major modes are not
intended for use on users' files; they are used in buffers created for
specific purposes by Emacs, such as Dired mode for buffers made by Dired
(*note Dired::.), and Mail mode for buffers made by `C-x m' (*note
Sending Mail::.), and Shell mode for buffers used for communicating
with an inferior shell process (*note Interactive Shell::.).

   Most programming language major modes specify that only blank lines
separate paragraphs.  This is so that the paragraph commands remain
useful.  (*Note Paragraphs::.)  They also cause Auto Fill mode to use
the definition of TAB to indent the new lines it creates.  This is
because most lines in a program are usually indented.  (*Note
Indentation::.)

* Menu:

* Choosing Modes::     How major modes are specified or chosen.


File: emacs,  Node: Choosing Modes,  Prev: Major Modes,  Up: Major Modes

How Major Modes are Chosen
==========================

   You can select a major mode explicitly for the current buffer, but
most of the time Emacs determines which mode to use based on the file
name or on special text in the file.

   Explicit selection of a new major mode is done with a `M-x' command.
From the name of a major mode, add `-mode' to get the name of a command
to select that mode.  Thus, you can enter Lisp mode by executing `M-x
lisp-mode'.

   When you visit a file, Emacs usually chooses the right major mode
based on the file's name.  For example, files whose names end in `.c'
are edited in C mode.  The correspondence between file names and major
mode is controlled by the variable `auto-mode-alist'.  Its value is a
list in which each element has the form

     (REGEXP . MODE-FUNCTION)

For example, one element normally found in the list has the form
`("\\.c$" . c-mode)', and it is responsible for selecting C mode for
files whose names end in `.c'.  (Note that `\\' is needed in Lisp
syntax to include a `\' in the string, which is needed to suppress the
special meaning of `.' in regexps.)  The only practical way to change
this variable is with Lisp code.

   You can specify which major mode should be used for editing a certain
file by a special sort of text in the first nonblank line of the file.
The mode name should appear in this line both preceded and followed by
`-*-'.  Other text may appear on the line as well.  For example,

     ;-*-Lisp-*-

tells Emacs to use Lisp mode.  Such an explicit specification overrides
any defaulting based on the file name.  Note how the semicolon is used
to make Lisp treat this line as a comment.

   Another format of mode specification is

     -*-Mode: MODENAME;-*-

which allows you to specify local variables as well, like this:

     -*- mode: MODENAME; VAR: VALUE; ... -*-

*Note File Variables::, for more information about this.

   When you visit a file that does not specify a major mode to use, or
when you create a new buffer with `C-x b', the variable
`default-major-mode' specifies which major mode to use.  Normally its
value is the symbol `fundamental-mode', which specifies Fundamental
mode.  If `default-major-mode' is `nil', the major mode is taken from
the previously selected buffer.

   If you change the major mode of a buffer, you can go back to the
major mode Emacs would choose automatically: use the command `M-x
normal-mode' to do this.  This is the same function that `find-file'
calls to choose the major mode.  It also processes the file's local
variables list if any.


File: emacs,  Node: Indentation,  Next: Text,  Prev: Major Modes,  Up: Top

Indentation
***********

   This chapter describes the Emacs commands that add, remove, or
adjust indentation.

`TAB'
     Indent current line "appropriately" in a mode-dependent fashion.

`LFD'
     Perform RET followed by TAB (`newline-and-indent').

`M-^'
     Merge two lines (`delete-indentation').  This would cancel out the
     effect of LFD.

`C-M-o'
     Split line at point; text on the line after point becomes a new
     line indented to the same column that it now starts in
     (`split-line').

`M-m'
     Move (forward or back) to the first nonblank character on the
     current line (`back-to-indentation').

`C-M-\'
     Indent several lines to same column (`indent-region').

`C-x TAB'
     Shift block of lines rigidly right or left (`indent-rigidly').

`M-i'
     Indent from point to the next prespecified tab stop column
     (`tab-to-tab-stop').

`M-x indent-relative'
     Indent from point to under an indentation point in the previous
     line.

   Most programming languages have some indentation convention.  For
Lisp code, lines are indented according to their nesting in
parentheses.  The same general idea is used for C code, though many
details are different.

   Whatever the language, to indent a line, use the TAB command.  Each
major mode defines this command to perform the sort of indentation
appropriate for the particular language.  In Lisp mode, TAB aligns the
line according to its depth in parentheses.  No matter where in the
line you are when you type TAB, it aligns the line as a whole.  In C
mode, TAB implements a subtle and sophisticated indentation style that
knows about many aspects of C syntax.

   In Text mode, TAB runs the command `tab-to-tab-stop', which indents
to the next tab stop column.  You can set the tab stops with `M-x
edit-tab-stops'.

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.


File: emacs,  Node: Indentation Commands,  Next: Tab Stops,  Prev: Indentation,  Up: Indentation

Indentation Commands and Techniques
===================================

   If you just want to insert a tab character in the buffer, you can
type `C-q TAB'.

   To move over the indentation on a line, do `M-m'
(`back-to-indentation').  This command, given anywhere on a line,
positions point at the first nonblank character on the line.

   To insert an indented line before the current line, do `C-a C-o
TAB'.  To make an indented line after the current line, use `C-e LFD'.

   `C-M-o' (`split-line') moves the text from point to the end of the
line vertically down, so that the current line becomes two lines.
`C-M-o' first moves point forward over any spaces and tabs.  Then it
inserts after point a newline and enough indentation to reach the same
column point is on.  Point remains before the inserted newline; in this
regard, `C-M-o' resembles `C-o'.

   To join two lines cleanly, use the `M-^' (`delete-indentation')
command.  It deletes the indentation at the front of the current line,
and the line boundary as well, replacing them with a single space.  As
a special case (useful for Lisp code) the single space is omitted if
the characters to be joined are consecutive open parentheses or closing
parentheses, or if the junction follows another newline.  To delete
just the indentation of a line, go to the beginning of the line and use
`M-\' (`delete-horizontal-space'), which deletes all spaces and tabs
around the cursor.

   If you have a fill prefix, `M-^' deletes the fill prefix if it
appears after the newline that is deleted.  *Note Fill Prefix::.

   There are also commands for changing the indentation of several
lines at once.  `C-M-\' (`indent-region') gives each line which begins
in the region the "usual" indentation by invoking TAB at the beginning
of the line.  A numeric argument specifies the column to indent to, and
each line is shifted left or right so that its first nonblank character
appears in that column.  `C-x TAB' (`indent-rigidly') moves all of the
lines in the region right by its argument (left, for negative
arguments).  The whole group of lines moves rigidly sideways, which is
how the command gets its name.

   `M-x indent-relative' indents at point based on the previous line
(actually, the last nonempty line).  It inserts whitespace at point,
moving point, until it is underneath an indentation point in the
previous line.  An indentation point is the end of a sequence of
whitespace or the end of the line.  If point is farther right than any
indentation point in the previous line, the whitespace before point is
deleted and the first indentation point then applicable is used.  If no
indentation point is applicable even then, `indent-relative' runs
`tab-to-tab-stop' (*note Tab Stops::.).

   `indent-relative' is the definition of TAB in Indented Text mode.
*Note Text::.


File: emacs,  Node: Tab Stops,  Next: Just Spaces,  Prev: Indentation Commands,  Up: Indentation

Tab Stops
=========

   For typing in tables, you can use Text mode's definition of TAB,
`tab-to-tab-stop'.  This command inserts indentation before point,
enough to reach the next tab stop column.  If you are not in Text mode,
this command can be found on the key `M-i'.

   You can specify the tab stops used by `M-i'.  They are stored in a
variable called `tab-stop-list', as a list of column-numbers in
increasing order.

   The convenient way to set the tab stops is with `M-x edit-tab-stops',
which creates and selects a buffer containing a description of the tab
stop settings.  You can edit this buffer to specify different tab
stops, and then type `C-c C-c' to make those new tab stops take effect.
In the tab stop buffer, `C-c C-c' runs the function
`edit-tab-stops-note-changes' rather than its usual definition
`save-buffer'.  `edit-tab-stops' records which buffer was current when
you invoked it, and stores the tab stops back in that buffer; normally
all buffers share the same tab stops and changing them in one buffer
affects all, but if you happen to make `tab-stop-list' local in one
buffer then `edit-tab-stops' in that buffer will edit the local
settings.

   Here is what the text representing the tab stops looks like for
ordinary tab stops every eight columns.

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

   The first line contains a colon at each tab stop.  The remaining
lines are present just to help you see where the colons are and know
what to do.

   Note that the tab stops that control `tab-to-tab-stop' have nothing
to do with displaying tab characters in the buffer.  *Note Display
Vars::, for more information on that.


File: emacs,  Node: Just Spaces,  Prev: Tab Stops,  Up: Indentation

Tabs vs. Spaces
===============

   Emacs normally uses both tabs and spaces to indent lines.  If you
prefer, all indentation can be made from spaces only.  To request this,
set `indent-tabs-mode' to `nil'.  This is a per-buffer variable;
altering the variable affects only the current buffer, but there is a
default value which you can change as well.  *Note Locals::.

   There are also commands to convert tabs to spaces or vice versa,
always preserving the columns of all nonblank text.  `M-x tabify' scans
the region for sequences of spaces, and converts sequences of at least
three spaces to tabs if that can be done without changing indentation.
`M-x untabify' changes all tabs in the region to appropriate numbers of
spaces.


File: emacs,  Node: Text,  Next: Programs,  Prev: Indentation,  Up: Top

Commands for Human Languages
****************************

   The term "text" has two widespread meanings in our area of the
computer field.  One is data that is a sequence of characters.  Any file
that you edit with Emacs is text, in this sense of the word.  The other
meaning is more restrictive: a sequence of characters in a human
language for humans to read (possibly after processing by a text
formatter), as opposed to a program or commands for a program.

   Human languages have syntactic/stylistic conventions that can be
supported or used to advantage by editor commands: conventions involving
words, sentences, paragraphs, and capital letters.  This chapter
describes Emacs commands for all of these things.  There are also
commands for "filling", which means rearranging the lines of a
paragraph to be approximately equal in length.  The commands for moving
over and killing words, sentences and paragraphs, while intended
primarily for editing text, are also often useful for editing programs.

   Emacs has several major modes for editing human language text.  If
the file contains text pure and simple, use Text mode, which customizes
Emacs in small ways for the syntactic conventions of text.  For text
which contains embedded commands for text formatters, Emacs has other
major modes, each for a particular text formatter.  Thus, for input to
TeX, you would use TeX mode; for input to nroff, Nroff mode.

* Menu:

* Words::         Moving over and killing words.
* Sentences::     Moving over and killing sentences.
* Paragraphs::	  Moving over paragraphs.
* Pages::	  Moving over pages.
* Filling::       Filling or justifying text.
* Case::          Changing the case of text.
* Text Mode::     The major modes for editing text files.
* Outline Mode::  The major mode for editing outlines.
* TeX Mode::      The major modes for editing input to the formatter TeX.
* Nroff Mode::    The major mode for editing input to the formatter nroff.


File: emacs,  Node: Words,  Next: Sentences,  Up: Text

Words
=====

   Emacs has commands for moving over or operating on words.  By
convention, the keys for them are all Meta characters.

`M-f'
     Move forward over a word (`forward-word').

`M-b'
     Move backward over a word (`backward-word').

`M-d'
     Kill up to the end of a word (`kill-word').

`M-DEL'
     Kill back to the beginning of a word (`backward-kill-word').

`M-@'
     Mark the end of the next word (`mark-word').

`M-t'
     Transpose two words or drag a word across other words
     (`transpose-words').

   Notice how these keys form a series that parallels the
character-based `C-f', `C-b', `C-d', `C-t' and DEL.  `M-@' is related
to `C-@', which is an alias for `C-SPC'.

   The commands `M-f' (`forward-word') and `M-b' (`backward-word') move
forward and backward over words.  These Meta characters are thus
analogous to the corresponding control characters, `C-f' and `C-b',
which move over single characters in the text.  The analogy extends to
numeric arguments, which serve as repeat counts.  `M-f' with a negative
argument moves backward, and `M-b' with a negative argument moves
forward.  Forward motion stops right after the last letter of the word,
while backward motion stops right before the first letter.

   `M-d' (`kill-word') kills the word after point.  To be precise, it
kills everything from point to the place `M-f' would move to.  Thus, if
point is in the middle of a word, `M-d' kills just the part after
point.  If some punctuation comes between point and the next word, it
is killed along with the word.  (If you wish to kill only the next word
but not the punctuation before it, simply do `M-f' to get the end, and
kill the word backwards with `M-DEL'.) `M-d' takes arguments just like
`M-f'.

   `M-DEL' (`backward-kill-word') kills the word before point.  It
kills everything from point back to where `M-b' would move to.  If
point is after the space in `FOO, BAR', then `FOO, ' is killed.  (If
you wish to kill just `FOO', do `M-b M-d' instead of `M-DEL'.)

   `M-t' (`transpose-words') exchanges the word before or containing
point with the following word.  The delimiter characters between the
words do not move.  For example, `FOO, BAR' transposes into `BAR, FOO'
rather than `BAR FOO,'.  *Note Transpose::, for more on transposition
and on arguments to transposition commands.

   To operate on the next N words with an operation which applies
between point and mark, you can either set the mark at point and then
move over the words, or you can use the command `M-@' (`mark-word')
which does not move point, but sets the mark where `M-f' would move to.
`M-@' accepts a numeric argument that says how many words to scan for
the place to put the mark.

   The word commands' understanding of syntax is completely controlled
by the syntax table.  Any character can, for example, be declared to be
a word delimiter.  *Note Syntax::.


File: emacs,  Node: Sentences,  Next: Paragraphs,  Prev: Words,  Up: Text

Sentences
=========

   The Emacs commands for manipulating sentences and paragraphs are
mostly on Meta keys, so as to be like the word-handling commands.

`M-a'
     Move back to the beginning of the sentence (`backward-sentence').

`M-e'
     Move forward to the end of the sentence (`forward-sentence').

`M-k'
     Kill forward to the end of the sentence (`kill-sentence').

`C-x DEL'
     Kill back to the beginning of the sentence
     (`backward-kill-sentence').

   The commands `M-a' and `M-e' (`backward-sentence' and
`forward-sentence') move to the beginning and end of the current
sentence, respectively.  They were chosen to resemble `C-a' and `C-e',
which move to the beginning and end of a line.  Unlike them, `M-a' and
`M-e' if repeated or given numeric arguments move over successive
sentences.  Emacs assumes that you have followed the typist's
convention of putting two spaces at the end of a sentence; it considers
a sentence to end wherever there is a `.', `?' or `!' followed by the
end of a line or two spaces, with any number of `)', `]', `'', or `"'
characters allowed in between.  A sentence also begins or ends wherever
a paragraph begins or ends.

   Neither `M-a' nor `M-e' moves past the newline or spaces beyond the
sentence edge at which it is stopping.

   Just as `C-a' and `C-e' have a kill command, `C-k', to go with them,
so `M-a' and `M-e' have a corresponding kill command `M-k'
(`kill-sentence') which kills from point to the end of the sentence.
With minus one as an argument it kills back to the beginning of the
sentence.  Larger arguments serve as a repeat count.

   There is a special command, `C-x DEL' (`backward-kill-sentence') for
killing back to the beginning of a sentence, because this is useful
when you change your mind in the middle of composing text.

   The variable `sentence-end' controls recognition of the end of a
sentence.  It is a regexp that matches the last few characters of a
sentence, together with the whitespace following the sentence.  Its
normal value is

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This example is explained in the section on regexps.  *Note Regexps::.

   If you want to use just one space between sentences, you should set
`sentence-end' to this value:

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

You should also set the variable `sentence-end-double-space' to `nil'
so that the fill commands expect and leave just one space at the end of
a sentence.

