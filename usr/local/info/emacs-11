This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: List Tags,  Prev: Tags Stepping,  Up: Tags

Tag Table Inquiries
-------------------

`M-x list-tags'
     Display a list of the tags defined in a specific program file.

`M-x tags-apropos'
     Display a list of all tags matching a specified regexp.

   `M-x list-tags' reads the name of one of the files described by the
selected tag table, and displays a list of all the tags defined in that
file.  The "file name" argument is really just a string to compare
against the names recorded in the tag table; it is read as a string
rather than as a file name.  Therefore, completion and defaulting are
not available, and you must enter the string the same way it appears in
the tag table.  Do not include a directory as part of the file name
unless the file name recorded in the tag table includes a directory.

   `M-x tags-apropos' is like `apropos' for tags.  It reads a regexp,
then finds all the tags in the selected tag table whose entries match
that regexp, and displays the tag names found.

   You can also perform completion in the buffer on the name space of
tag names in the current tag tables.  *Note Symbol Completion::.


File: emacs,  Node: Emerge,  Next: C Mode,  Prev: Tags,  Up: Programs

Merging Files with Emerge
=========================

   It's not unusual for programmers to get their signals crossed and
modify the same program in two different directions.  To recover from
this confusion, you need to merge the two versions.  Emerge makes this
easier.  See also *Note Comparing Files::.

* Menu:

* Overview of Emerge::	    How to start Emerge.  Basic concepts.
* Submodes of Emerge::      Fast mode vs. Edit mode.
			      Skip Prefers mode and Auto Advance mode.
* State of Difference::	    You do the merge by specifying state A or B
			      for each difference.
* Merge Commands::	    Commands for selecting a difference,
			      changing states of differences, etc.
* Exiting Emerge::	    What to do when you've finished the merge.
* Combining in Emerge::	    How to keep both alternatives for a difference.
* Fine Points of Emerge::   Misc.


File: emacs,  Node: Overview of Emerge,  Next: Submodes of Emerge,  Up: Emerge

Overview of Emerge
------------------

   To start Emerge, run one of these four commands:

`M-x emerge-files'
     Merge two specified files.

`M-x emerge-files-with-ancestor'
     Merge two specified files, with reference to a common ancestor.

`M-x emerge-buffers'
     Merge two buffers.

`M-x emerge-buffers-with-ancestor'
     Merge two buffers with reference to a common ancestor in a third
     buffer.

   The Emerge commands compare two files or buffers, and display the
comparison in three buffers: one for each input text (the "A buffer"
and the "B buffer"), and one (the "merge buffer") where merging takes
place.  The merge buffer shows the full merged text, not just the
differences.  Wherever the two input texts differ, you can choose which
one of them to include in the merge buffer.

   The Emerge commands that take input from existing buffers use only
the accessible portions of those buffers, if they are narrowed (*note
Narrowing::.).

   If a common ancestor version is available, from which the two texts
to be merged were both derived, Emerge can use it to guess which
alternative is right.  Wherever one current version agrees with the
ancestor, Emerge presumes that the other current version is a deliberate
change which should be kept in the merged version.  Use the
`with-ancestor' commands if you want to specify a common ancestor text.
These commands read three file or buffer names--variant A, variant B,
and the common ancestor.

   After the comparison is done and the buffers are prepared, the
interactive merging starts.  You control the merging by typing special
commands in the merge buffer.  The merge buffer shows you a full merged
text, not just differences.  For each run of differences between the
input texts, you can choose which one of them to keep, or edit them both
together.

   The merge buffer uses a special major mode, Emerge mode, with
commands for making these choices.  But you can also edit the buffer
with ordinary Emacs commands.

   At any given time, the attention of Emerge is focused on one
particular difference, called the "selected" difference.  This
difference is marked off in the three buffers like this:

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

Emerge numbers all the differences sequentially and the mode line
always shows the number of the selected difference.

   Normally, the merge buffer starts out with the A version of the text.
But when the A version of a part of the buffer agrees with the common
ancestor, then the B version is preferred for that part.

   Emerge leaves the merged text in the merge buffer when you exit.  At
that point, you can save it in a file with `C-x C-w'.  If you give a
prefix argument to `emerge-files' or `emerge-files-with-ancestor', it
reads the name of the output file using the minibuffer.  (This is the
last file name those commands read.) Then exiting from Emerge saves the
merged text in the output file.

   If you abort Emerge with `C-]', the output is not saved.


File: emacs,  Node: Submodes of Emerge,  Next: State of Difference,  Prev: Overview of Emerge,  Up: Emerge

Submodes of Emerge
------------------

   You can choose between two modes for giving merge commands: Fast mode
and Edit mode.  In Fast mode, basic Emerge commands are single
characters, but ordinary Emacs commands are disabled.  This is
convenient if you use only Emerge commands.

   In Edit mode, all Emerge commands start with the prefix key `C-c
C-c', and the normal Emacs commands are also available.  This allows
editing the merge buffer, but slows down Emerge operations.

   Use `e' to switch to Edit mode, and `C-c C-c f' to switch to Fast
mode.  The mode line indicates Edit and Fast modes with `E' and `F'.

   Emerge has two additional submodes that affect how particular merge
commands work: Auto Advance mode and Skip Prefers mode.

   If Auto Advance mode is in effect, the `a' and `b' commands advance
to the next difference.  This lets you go through the merge faster as
long as you simply choose one of the alternatives from the input.  The
mode line indicates Auto Advance mode with `A'.

   If Skip Prefers mode is in effect, the `n' and `p' commands skip
over differences in states prefer-A and prefer-B.  Thus you see only
differences for which neither version is presumed "correct".  The mode
line indicates Skip Prefers mode with `S'.

   Use the command `s a' (`emerge-auto-advance-mode') to set or clear
Auto Advance mode.  Use `s s' (`emerge-skip-prefers-mode') to set or
clear Skip Prefers mode.  These commands turn on the mode with a
positive argument, turns it off with a negative or zero argument, and
toggle the mode with no argument.


File: emacs,  Node: State of Difference,  Next: Merge Commands,  Prev: Submodes of Emerge,  Up: Emerge

State of a Difference
---------------------

   In the merge buffer, a difference is marked with lines of `v' and
`^' characters.  Each difference has one of these seven states:

A
     The difference is showing the A version.  The `a' command always
     produces this state; the mode line indicates it with `A'.

B
     The difference is showing the B version.  The `b' command always
     produces this state; the mode line indicates it with `B'.

default-A
default-B
     The difference is showing the A or the B state by default, because
     you haven't made a choice.  All differences start in the default-A
     state (and thus the merge buffer is a copy of the A buffer),
     except those for which one alternative is "preferred" (see below).

     When you select a difference, its state changes from default-A or
     default-B to plain A or B.  Thus, the selected difference never has
     state default-A or default-B, and these states are never displayed
     in the mode line.

     The command `d a' chooses default-A as the default state, and `d
     b' chooses default-B.  This chosen default applies to all
     differences which you haven't selected and for which no
     alternative is preferred.  If you are moving through the merge
     sequentially, the differences you haven't selected are those
     following the selected one.  Thus, while moving sequentially, you
     can effectively make the A version the default for some sections
     of the merge buffer and the B version the default for others by
     using `d a' and `d b' at the end of each section.

prefer-A
prefer-B
     The difference is showing the A or B state because it is
     "preferred".  This means that you haven't made an explicit choice,
     but one alternative seems likely to be right because the other
     alternative agrees with the common ancestor.  Thus, where the A
     buffer agrees with the common ancestor, the B version is
     preferred, because chances are it is the one that was actually
     changed.

     These two states are displayed in the mode line as `A*' and `B*'.

combined
     The difference is showing a combination of the A and B states, as a
     result of the `x c' or `x C' commands.

     Once a difference is in this state, the `a' and `b' commands don't
     do anything to it unless you give them a prefix argument.

     The mode line displays this state as `comb'.


File: emacs,  Node: Merge Commands,  Next: Exiting Emerge,  Prev: State of Difference,  Up: Emerge

Merge Commands
--------------

   Here are the Merge commands for Fast mode; in Edit mode, precede them
with `C-c C-c':

`p'
     Select the previous difference.

`n'
     Select the next difference.

`a'
     Choose the A version of this difference.

`b'
     Choose the B version of this difference.

`j'
     Select a particular difference; specify the sequence number of that
     difference as a prefix argument.

`.'
     Select the difference containing point.  You can use this command
     in the merge buffer or in the A or B buffer.

`q'
     Quit--finish the merge.

`C-]'
     Abort--exit merging and do not save the output.

`f'
     Go into Fast mode.  (In Edit mode, this is actually `C-c C-c f'.)

`e'
     Go into Edit mode.

`l'
     Recenter (like `C-l') all three windows.

`-'
     Specify part of a prefix numeric argument.

`DIGIT'
     Also specify part of a prefix numeric argument.

`d a'
     Choose the A version as the default from here down in the merge
     buffer.

`d b'
     Choose the B version as the default from here down in the merge
     buffer.

`c a'
     Copy the A version of this difference into the kill ring.

`c b'
     Copy the B version of this difference into the kill ring.

`i a'
     Insert the A version of this difference at the point.

`i b'
     Insert the B version of this difference at the point.

`m'
     Put the point and mark around the difference region.

`^'
     Scroll all three windows down (like `M-v').

`v'
     Scroll all three windows up (like `C-v').

`<'
     Scroll all three windows left (like `C-x <').

`>'
     Scroll all three windows right (like `C-x >').

`|'
     Reset horizontal scroll on all three windows.

`x 1'
     Shrink the merge window to one line.  (Use `C-u l' to restore it
     to full size.)

`x c'
     Combine the two versions of this difference.

`x f'
     Show the files/buffers Emerge is operating on in Help window.
     (Use `C-u l' to restore windows.)

`x j'
     Join this difference with the following one.  (`C-u x j' joins
     this difference with the previous one.)

`x s'
     Split this difference into two differences.  Before you use this
     command, position point in each of the three buffers to the place
     where you want to split the difference.

`x t'
     Trim identical lines off top and bottom of the difference.  Such
     lines occur when the A and B versions are identical but differ
     from the ancestor version.


File: emacs,  Node: Exiting Emerge,  Next: Combining in Emerge,  Prev: Merge Commands,  Up: Emerge

Exiting Emerge
--------------

   The `q' command (`emerge-quit') finishes the merge, storing the
results into the output file if you specified one.  It restores the A
and B buffers to their proper contents, or kills them if they were
created by Emerge and you haven't changed them.  It also disables the
Emerge commands in the merge buffer, since executing them later could
damage the contents of the various buffers.

   `C-]' aborts the merge.  This means exiting without writing the
output file.  If you didn't specify an output file, then there is no
real difference between aborting and finishing the merge.

   If Emerge was called from another Lisp program, then its return value
is `t' for successful completion, or `nil' if you abort.


File: emacs,  Node: Combining in Emerge,  Next: Fine Points of Emerge,  Prev: Exiting Emerge,  Up: Emerge

Combining the Two Versions
--------------------------

   Sometimes you want to keep *both* alternatives for a particular
locus.  To do this, use `x c', which edits the merge buffer like this:

     #ifdef NEW
     VERSION FROM A FILE
     #else /* NEW */
     VERSION FROM B FILE
     #endif /* NEW */

While this example shows C preprocessor conditionals delimiting the two
alternative versions, you can specify the strings you want by setting
the variable `emerge-combine-versions-template' to a string of your
choice.  In the string, `%a' says where to put version A, and `%b' says
where to put version B.  The default setting, which produces the
results shown above, looks like this:

     "#ifdef NEW\n%a#else /* NEW */\n%b#endif /* NEW */\n"


File: emacs,  Node: Fine Points of Emerge,  Prev: Combining in Emerge,  Up: Emerge

Fine Points of Emerge
---------------------

   During the merge, you mustn't try to edit the A and B buffers
yourself.  Emerge modifies them temporarily, but ultimately puts them
back the way they were.

   You can have any number of merges going at once--just don't use any
one buffer as input to more than one merge at once, since the temporary
changes made in these buffers would get in each other's way.

   Starting Emerge can take a long time because it needs to compare the
files fully.  Emacs can't do anything else until `diff' finishes.
Perhaps in the future someone will change Emerge to do the comparison in
the background when the input files are large--then you could keep on
doing other things with Emacs until Emerge gets ready to accept
commands.

   After setting up the merge, Emerge runs the hook
`emerge-startup-hook' (*note Hooks::.).


File: emacs,  Node: C Mode,  Next: Fortran,  Prev: Emerge,  Up: Programs

C Mode
======

   In addition to the facilities of typical programming language major
modes (*note Program Modes::.), C mode has various special facilities.

`M-a'
`M-e'
     In C mode, `M-a' and `M-e' now move by complete C statements
     (`c-beginning-of-statement' and `c-end-of-statement').  These
     commands do ordinary, textual sentence motion when in or next to a
     comment.

`M-q'
     `M-q' in C mode runs `c-fill-paragraph', which is designed for
     filling C comments.  (We assume you don't want to fill the actual
     C code in a C program.)

`C-c C-u'
     Move back to the containing preprocessor conditional, setting the
     mark at the starting point (`c-up-conditional').

     A prefix argument acts as a repeat count.  With a negative
     argument, this command moves forward to the end of the containing
     preprocessor conditional.  When going backwards, `#elif' acts like
     `#else' followed by `#if'.  When going forwards, `#elif' is
     ignored.

`C-c C-n'
     Move forward across the next preprocessor conditional, setting the
     mark at the starting point (`c-forward-conditional').

`C-c C-p'
     Move backward across the previous preprocessor conditional,
     setting the at the starting point (`c-backward-conditional').

`M-x c-macro-expand'
     When you are debugging C code that uses macros, sometimes it is
     hard to figure out precisely how the macros expand.  The command
     `M-x c-macro-expand' runs the C preprocessor and shows you what
     expansion results from the region.  The portion of the buffer
     before the region is also included in preprocessing, for the sake
     of macros defined there, but the output from this part isn't shown.

`M-x c-backslash-region'
     Insert or align `\' characters at the ends of the lines of the
     region, except for the last such line.  This is useful after
     writing or editing a C macro definition.

     If a line already ends in `\', this command adjusts the amount of
     whitespace before it.  Otherwise, it inserts a new `\'.

   C++ mode is like C mode, except that it understands C++ comment
syntax and certain other differences between C and C++.  It also has a
command `M-x fill-c++-comment', which fills a paragraph made of C++
comment lines.

   The command `comment-region' is useful in C++ mode for commenting
out several consecutive lines, or removing the commenting out of such
lines.  (You don't need this command with C comment syntax because you
don't need to put comment delimiters on each line.)  *Note Comments::.


File: emacs,  Node: Fortran,  Next: Asm Mode,  Prev: C Mode,  Up: Programs

Fortran Mode
============

   Fortran mode provides special motion commands for Fortran statements
and subprograms, and indentation commands that understand Fortran
conventions of nesting, line numbers and continuation statements.
Fortran mode has it's own Auto Fill mode that breaks long lines into
proper Fortran continuation lines.

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.

   Built-in abbrevs optionally save typing when you insert Fortran
keywords.

   Use `M-x fortran-mode' to switch to this major mode.  This command
runs the hook `fortran-mode-hook' (*note Hooks::.).

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill minor mode for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.

   Fortran mode was contributed by Michael Prange.  It has been updated
by Stephen A. Wood who has collated the contributions and suggestions
of many users.


File: emacs,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

Motion Commands
---------------

   Fortran mode provides special commands to move by subprograms
(functions and subroutines) and by statements.  There is also a command
to put the region around one subprogram, convenient for killing it or
moving it.

`C-M-a'
     Move to beginning of subprogram
     (`beginning-of-fortran-subprogram').

`C-M-e'
     Move to end of subprogram (`end-of-fortran-subprogram').

`C-M-h'
     Put point at beginning of subprogram and mark at end
     (`mark-fortran-subprogram').

`C-c C-n'
     Move to beginning of current or next statement
     (`fortran-next-statement').

`C-c C-p'
     Move to beginning of current or previous statement
     (`fortran-previous-statement').


File: emacs,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

Fortran Indentation
-------------------

   Special commands and features are needed for indenting Fortran code
in order to make sure various syntactic entities (line numbers, comment
line indicators and continuation line flags) appear in the columns that
are required for standard Fortran.

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.


File: emacs,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

Fortran Indentation Commands
............................

`TAB'
     Indent the current line (`fortran-indent-line').

`LFD'
     Indent the current and start a new indented line
     (`fortran-indent-new-line').

`M-LFD'
     Break the current line and set up a continuation line.

`C-M-q'
     Indent all the lines of the subprogram point is in
     (`fortran-indent-subprogram').

   Fortran mode redefines TAB to reindent the current line for Fortran
(`fortran-indent-line').  This command indents Line numbers and
continuation markers to their required columns, and independently
indents the body of the statement based on its nesting in the program.

   The key `LFD' runs the command `fortran-indent-new-line', which
reindents the current line then makes and indents a new line.  This
command is useful to reindent the closing statement of `do' loops and
other blocks before starting a new line.

   The key `C-M-q' runs `fortran-indent-subprogram', a command to
reindent all the lines of the Fortran subprogram (function or
subroutine) containing point.

   The key `M-LFD' runs `fortran-split-line', which splits a line in
the appropriate fashion for Fortran.  In a non-comment line, the second
half becomes a continuation line and is indented accordingly.  In a
comment line, both halves become separate comment lines.


File: emacs,  Node: ForIndent Cont,  Next: ForIndent Num,  Prev: ForIndent Commands,  Up: Fortran Indent

Continuation Lines
..................

   Most modern Fortran compilers allow two ways of writing continuation
lines.  If the first non-space character on a line is in column 5, then
that line is a continuation of the previous line.  We call this "fixed
format".  (In GNU Emacs we always count columns from 0.)  The variable
`fortran-continuation-string' specifies what character to put on column
5.  A line that starts with a tab character followed by any digit
except `0' is also a continuation line.  We call this style of
continuation "tab format".

   Fortran mode can make either style of continuation line, but you
must specify which one you prefer.  The value of the variable
`indent-tabs-mode' controls the choice: `nil' for fixed format, and
non-`nil' for tab format.  You can tell which style is presently in
effect by the presence or absence of the string `Tab' in the mode line.

   If the text on a line starts with the conventional Fortran
continuation marker `$', or if it begins with any non-whitespace
character in column 5, Fortran mode treats it as a continuation line.
When you indent a continuation line with TAB, it converts the line to
the current continuation style.  When you split a Fortran statement
with `M-LFD', the continuation marker on the newline is created
according to the continuation style.

   The setting of continuation style affects several other aspects of
editing in Fortran mode.  In fixed format mode, the minimum column
number for the body of a statement is 6.  Lines inside of Fortran
blocks that are indented to larger column numbers always use only the
space character for whitespace.  In tab format mode, the minimum column
number for the statement body is 8, and the whitespace before column 8
must always consist of one tab character.

   When you enter Fortran mode for an existing file, it tries to deduce
the proper continuation style automatically from the file contents.
The first line that begins with either a tab character or six spaces
determines the choice.  The variable `fortran-analyze-depth' specifies
how many lines to consider (at the beginning of the file); if none of
those lines indicates a style, then the variable
`fortran-tab-mode-default' specifies the style.  If it is `nil', that
specifies fixed format, and non-`nil' specifies tab format.


File: emacs,  Node: ForIndent Num,  Next: ForIndent Conv,  Prev: ForIndent Cont,  Up: Fortran Indent

Line Numbers
............

   If a number is the first non-whitespace in the line, Fortran
indentation assumes it is a line number and moves it to columns 0
through 4.  (Columns always count from 0 in GNU Emacs.)

   Line numbers of four digits or less are normally indented one space.
The variable `fortran-line-number-indent' controls this; it specifies
the maximum indentation a line number can have.  Line numbers are
indented to right-justify them to end in column 4 unless that would
require more than this maximum indentation.  The default value of the
variable is 1.

   Simply inserting a line number is enough to indent it according to
these rules.  As each digit is inserted, the indentation is recomputed.
To turn off this feature, set the variable
`fortran-electric-line-number' to `nil'.  Then inserting line numbers
is like inserting anything else.


File: emacs,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

Syntactic Conventions
.....................

   Fortran mode assumes that you follow certain conventions that
simplify the task of understanding a Fortran program well enough to
indent it properly:

   * Two nested `do' loops never share a `continue' statement.

   * Fortran keywords such as `if', `else', `then', `do' and others are
     written without embedded whitespace or line breaks.

     Fortran compilers generally ignore whitespace outside of string
     constants, but Fortran mode does not recognize these keywords if
     they are not contiguous.  Constructs such as `else if' or `end do'
     are acceptable, but the second word should be on the same line as
     the first and not on a continuation line.

If you fail to follow these conventions, the indentation commands may
indent some lines unaesthetically.  However, a correct Fortran program
retains its meaning when reindented even if the conventions are not
followed.


File: emacs,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

Variables for Fortran Indentation
.................................

   Several additional variables control how Fortran indentation works:

`fortran-do-indent'
     Extra indentation within each level of `do' statement (default 3).

`fortran-if-indent'
     Extra indentation within each level of `if' statement (default 3).
     This value is also used for extra indentation within each level of
     the Fortran 90 `where' statement.

`fortran-structure-indent'
     Extra indentation within each level of `structure', `union', or
     `map' statements (default 3).

`fortran-continuation-indent'
     Extra indentation for bodies of continuation lines (default 5).

`fortran-check-all-num-for-matching-do'
     If this is `nil', indentation assumes that each `do' statement
     ends on a `continue' statement.  Therefore, when computing
     indentation for a statement other than `continue', it can save time
     by not checking for a `do' statement ending there.  If this is
     non-`nil', indenting any numbered statement must check for a `do'
     that ends there.  The default is `nil'.

`fortran-blink-matching-if'
     If this is `t', indenting an `endif' statement moves the cursor
     momentarily to the matching `if' statement to show where it is.
     The default is `nil'.

`fortran-minimum-statement-indent-fixed'
     Minimum indentation for fortran statements when using fixed format
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 6.

`fortran-minimum-statement-indent-tab'
     Minimum indentation for fortran statements for tab format
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 8.


File: emacs,  Node: Fortran Comments,  Next: Fortran Autofill,  Prev: Fortran Indent,  Up: Fortran

Comments
--------

   The usual Emacs comment commands assume that a comment can follow a
line of code.  In Fortran, the standard comment syntax requires an
entire line to be just a comment.  Therefore, Fortran mode replaces the
standard Emacs comment commands and defines some new variables.

   Fortran mode can also handle a nonstandard comment syntax where
comments start with `!' and can follow other text.  Because only some
Fortran compilers accept this syntax, Fortran mode will not insert such
comments unless you have said in advance to do so.  To do this, set the
variable `comment-start' to `"!"' (*note Variables::.).

`M-;'
     Align comment or insert new comment (`fortran-comment-indent').

`C-x ;'
     Applies to nonstandard `!' comments only.

`C-c ;'
     Turn all lines of the region into comments, or (with argument)
     turn them back into real code (`fortran-comment-region').

   `M-;' in Fortran mode is redefined as the command
`fortran-comment-indent'.  Like the usual `M-;' command, this
recognizes any kind of existing comment and aligns its text
appropriately; if there is no existing comment, a comment is inserted
and aligned.  But inserting and aligning comments are not the same in
Fortran mode as in other modes.

   When a new comment must be inserted, if the current line is blank, a
full-line comment is inserted.  On a non-blank line, a nonstandard `!'
comment is inserted if you have said you want to use them.  Otherwise a
full-line comment is inserted on a new line before the current line.

   Nonstandard `!' comments are aligned like comments in other
languages, but full-line comments are different.  In a standard
full-line comment, the comment delimiter itself must always appear in
column zero.  What can be aligned is the text within the comment.  You
can choose from three styles of alignment by setting the variable
`fortran-comment-indent-style' to one of these values:

`fixed'
     Align the text at a fixed column, which is the sum of
     `fortran-comment-line-extra-indent' and the minimum statement
     indentation.  This is the default.

     The minimum statement indentation is
     `fortran-minimum-statement-indent-fixed' for fixed format
     continuation line style and `fortran-minimum-statement-indent-tab'
     for tab format style.

`relative'
     Align the text as if it were a line of code, but with an additional
     `fortran-comment-line-extra-indent' columns of indentation.

`nil'
     Don't move text in full-line columns automatically at all.

   In addition, you can specify the character to be used to indent
within full-line comments by setting the variable
`fortran-comment-indent-char' to the single-character string you want
to use.

   Fortran mode introduces two variables `comment-line-start' and
`comment-line-start-skip' which play for full-line comments the same
roles played by `comment-start' and `comment-start-skip' for ordinary
text-following comments.  Normally these are set properly by Fortran
mode so you do not need to change them.

   The normal Emacs comment command `C-x ;' has not been redefined.  If
you use `!' comments, this command can be used with them.  Otherwise it
is useless in Fortran mode.

   The command `C-c ;' (`fortran-comment-region') turns all the lines
of the region into comments by inserting the string `C$$$' at the front
of each one.  With a numeric argument, it turns the region back into
live code by deleting `C$$$' from the front of each line in it.  The
string used for these comments can be controlled by setting the
variable `fortran-comment-region'.  Note that here we have an example
of a command and a variable with the same name; these two uses of the
name never conflict because in Lisp and in Emacs it is always clear
from the context which one is meant.


File: emacs,  Node: Fortran Autofill,  Next: Fortran Columns,  Prev: Fortran Comments,  Up: Fortran

Fortran Auto Fill Mode
----------------------

   Fortran Auto Fill mode is a minor mode which automatically splits
Fortran statements as you insert them when they become too wide.
Splitting a statement involves making continuation lines using
`fortran-continuation-string' (*Note ForIndent Cont::).  This splitting
happens when you type SPC, RET, or TAB, and also in the Fortran
indentation commands.

   `M-x fortran-auto-fill-mode' turns Fortran Auto Fill mode on if it
was off, or off if it was on.  This command works the same as `M-x
auto-fill-mode' does for normal Auto Fill mode (*note Filling::.).  A
positive numeric argument turns Fortran Auto Fill mode on, and a
negative argument turns it off.  You can see when Fortran Auto Fill mode
is in effect by the presence of the word `Fill' in the mode line,
inside the parentheses.  Fortran Auto Fill mode is a minor mode, turned
on or off for each buffer individually.  *Note Minor Modes::.

   Fortran Auto Fill mode breaks lines at spaces or delimiters when the
lines get longer than the desired width (the value of `fill-column').
The delimiters that Fortran Auto Fill mode may break at are `,', `'',
`+', `-', `/', `*', `=', and `)'.  The line break comes after the
delimiter if the variable `fortran-break-before-delimiters' is `nil'.
Otherwise (and by default), the break comes before the delimiter.

   By default, Fortran Auto Fill mode is not enabled.  If you want this
feature turned on permanently, add a hook function to
`fortran-mode-hook' to execute `(fortran-auto-fill-mode 1)'.  *Note
Hooks::.


File: emacs,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Autofill,  Up: Fortran

Columns
-------

`C-c C-r'
     Display a "column ruler" momentarily above the current line
     (`fortran-column-ruler').

`C-c C-w'
     Split the current window horizontally temporarily so that it is 72
     columns wide.  This may help you avoid making lines longer than
     the 72 character limit that some fortran compilers impose
     (`fortran-window-create-momentarily').

   The command `C-c C-r' (`fortran-column-ruler') shows a column ruler
momentarily above the current line.  The comment ruler is two lines of
text that show you the locations of columns with special significance in
Fortran programs.  Square brackets show the limits of the columns for
line numbers, and curly brackets show the limits of the columns for the
statement body.  Column numbers appear above them.

   Note that the column numbers count from zero, as always in GNU Emacs.
As a result, the numbers may be one less than those you are familiar
with; but the positions they indicate in the line are standard for
Fortran.

   The text used to display the column ruler depends on the value of
the variable `indent-tabs-mode'.  If `indent-tabs-mode' is `nil', then
the value of the variable `fortran-column-ruler-fixed' is used as the
column ruler.  Otherwise, the variable `fortran-column-ruler-tab' is
displayed.  By changing this variables, you can change the column ruler
display.

   For even more help, use `C-c C-w' (`fortran-window-create'), a
command which splits the current window horizontally, making a window 72
columns wide.  By editing in this window you can immediately see when
you make a line too wide to be correct Fortran.


File: emacs,  Node: Fortran Abbrev,  Prev: Fortran Columns,  Up: Fortran

Fortran Keyword Abbrevs
-----------------------

   Fortran mode provides many built-in abbrevs for common keywords and
declarations.  These are the same sort of abbrev that you can define
yourself.  To use them, you must turn on Abbrev mode.  *Note Abbrevs::.

   The built-in abbrevs are unusual in one way: they all start with a
semicolon.  You cannot normally use semicolon in an abbrev, but Fortran
mode makes this possible by changing the syntax of semicolon to "word
constituent."

   For example, one built-in Fortran abbrev is `;c' for `continue'.  If
you insert `;c' and then insert a punctuation character such as a space
or a newline, the `;c' expands automatically to `continue', provided
Abbrev mode is enabled.

   Type `;?' or `;C-h' to display a list of all the built-in Fortran
abbrevs and what they stand for.


File: emacs,  Node: Asm Mode,  Prev: Fortran,  Up: Programs

Asm Mode
========

   Asm mode is a major mode for editing files of assembler code.  It
defines these commands:

`TAB'
     `tab-to-tab-stop'.

`LFD'
     Insert a newline and then indent using `tab-to-tab-stop'.

`:'
     Insert a colon and then remove the indentation from before the
     label preceding colon.  Then do `tab-to-tab-stop'.

`;'
     Insert or align a comment.

   The variable `asm-comment-char' specifies which character starts
comments in assembler syntax.


File: emacs,  Node: Building,  Next: Abbrevs,  Prev: Programs,  Up: Top

Compiling and Testing Programs
******************************

   The previous chapter discusses the Emacs commands that are useful for
making changes in programs.  This chapter deals with commands that
assist in the larger process of developing and maintaining programs.

* Menu:

* Compilation::                   Compiling programs in languages other
                                    than Lisp (C, Pascal, etc.)
* Debuggers::	                  Running symbolic debuggers for
                                    non-Lisp programs.
* Executing Lisp::                Various modes for editing Lisp programs,
                                    with different facilities for running
                                    the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.                Executing a single Lisp expression in Emacs.
* External Lisp::                 Communicating through Emacs with a
                                    separate Lisp.


File: emacs,  Node: Compilation,  Next: Debuggers,  Up: Building

Running `make', or Compilers Generally
======================================

   Emacs can run compilers for noninteractive languages such as C and
Fortran as inferior processes, feeding the error log into an Emacs
buffer.  It can also parse the error messages and show you the source
lines where compilation errors occurred.

`M-x compile'
     Run a compiler asynchronously under Emacs, with error messages to
     `*compilation*' buffer.

`M-x grep'
     Run `grep' asynchronously under Emacs, with matching lines listed
     in the buffer named `*grep*'.

`M-x kill-compilation'
`M-x kill-grep'
     Kill the running compilation or `grep' subprocess.

`C-x `'
     Visit the locus of the next compiler error message or `grep' match.

   To run `make' or another compilation command, do `M-x compile'.
This command reads a shell command line using the minibuffer, and then
executes the command in an inferior shell, putting output in the buffer
named `*compilation*'.  The current buffer's default directory is used
as the working directory for the execution of the command; normally,
therefore, the compilation happens in this directory.

   When the shell command line is read, the minibuffer appears
containing a default command line, which is the command you used the
last time you did `M-x compile'.  If you type just RET, the same command
line is used again.  For the first `M-x compile', the default is `make
-k'.

   The default compilation command comes from the variable
`compile-command'; if the appropriate compilation command for a file is
something other than `make -k', it can be useful for the file to
specify a local value for `compile-command' (*note File Variables::.).

   Starting a compilation displays the buffer `*compilation*' in
another window but does not select it.  The buffer's mode line tells you
whether compilation is finished, with the word `run' or `exit' inside
the parentheses.  You do not have to keep this buffer visible;
compilation continues in any case.  While a compilation is going on, the
string `Compiling' appears in the mode lines of all windows.  When this
string disappears, the compilation is finished.

   To kill the compilation process, do `M-x kill-compilation'.  When
the compiler process terminates, the mode line of the `*compilation*'
buffer changes to say `signal' instead of `run'.  Starting a new
compilation also kills any running compilation, as only one can exist
at any time.  However, `M-x compile' asks for confirmation before
actually killing a compilation that is running.

   The `*compilation*' buffer uses a special major mode, Compilation
mode.  This mode provides the keys SPC and DEL to scroll by screenfuls,
and `M-n' and `M-p' to move to the next or previous error message.  You
can also use `M-{' and `M-}' to move up or down to an error message for
a different source file.  You can visit the source for any particular
error message by moving point in `*compilation*' to that error message
and typing `C-c C-c' (`compile-goto-error').

   To parse the compiler error messages sequentially, type `C-x `'
(`next-error').  The character following the `C-x' is the backquote or
"grave accent," not the single-quote.  This command is available in all
buffers, not just in `*compilation*'.  It displays the next error
message at the top of one window and source location of the error in
another window.

   The first time `C-x `' is used after the start of a compilation, it
moves to the first error's location.  Subsequent uses of `C-x `'
advance down the data set up by the first use.  When the preparsed error
messages are exhausted, the next `C-x `' checks for any more error
messages that have come in; this is useful if you start editing the
compilation errors while the compilation is still going on.  If no more
error messages have come in, `C-x `' reports an error.

   `C-u C-x `' discards the preparsed error message data and parses the
`*compilation*' buffer over again, then displaying the first error.
This way, you can process the same set of errors again.

   Instead of running a compiler, you can run `grep' and see the lines
on which matches were found.  To do this, type `M-x grep' with an
argument line that contains the same arguments you would give `grep'
when running it normally: a `grep'-style regexp (usually in
single-quotes to quote the shell's special characters) followed by file
names which may use wildcards.  The output from `grep' goes in the
`*grep*' buffer and the lines that matched can be found with `C-x `' as
if they were compilation errors.

   Note: a shell is used to run the compile command, but the shell is
told that it should be noninteractive.  This means in particular that
the shell starts up with no prompt.  If you find your usual shell
prompt making an unsightly appearance in the `*compilation*' buffer, it
means you have made a mistake in your shell's init file (`.cshrc' or
`.shrc' or ...) by setting the prompt unconditionally.  The shell init
file should set the prompt only if there already is a prompt.  In
`csh', here is how to do it:

     if ($?prompt) set prompt = ...

   Compilation Minor mode lets you parse error messages in any buffer,
not just a normal compilation output buffer.  Type `M-x
compilation-minor-mode' to enable the minor mode.  This defines the key
`C-c C-c' to find the source code for the error message at point, just
as in the Compilation major mode.  In an rlogin buffer (*note Remote
Host::.), this automatically accesses remote source files by FTP (*note
File Names::.).

   The features of Compilation mode are also available in a minor mode
called Compilation Minor mode.


File: emacs,  Node: Debuggers,  Next: Executing Lisp,  Prev: Compilation,  Up: Building

Running Debuggers Under Emacs
=============================

   The GUD (Grand Unified Debugger) library provides an interface to
various symbolic debuggers from within Emacs.  We recommend the debugger
GDB, which is free software, but you can also run DBX, SDB or XDB if you
have them.

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Keybindings for common commands.
* GUD Customization::	Defining your own commands for GUD.


File: emacs,  Node: Starting GUD,  Next: Debugger Operation,  Up: Debuggers

Starting GUD
------------

   There are four commands for starting a debugger, each corresponding
to a particular debugger program.

`M-x gdb RET FILE RET'
     Run GDB as a subprocess of Emacs.  This command creates a buffer
     for input and output to GDB, and switches to it.  If a GDB buffer
     already exists, it just switches to that buffer.

`M-x dbx RET FILE RET'
     Similar, but run DBX instead of GDB.

`M-x xdb RET FILE RET'
     Similar, but run XDB instead of GDB.  Use the variable
     `gud-xdb-directories' to specify directories to search for source
     files.

`M-x sdb RET FILE RET'
     Similar, but run SDB instead of GDB.

     Some versions of SDB do not mention source file names in their
     messages.  When you use them, you need to have a valid tags table
     (*note Tags::.) in order for GUD to find functions in the source
     code.  If you have not visited a tags table or the tags table
     doesn't list one of the functions, you get a message saying `The
     sdb support requires a valid tags table to work'.  If this
     happens, generate a valid tags table in the working directory and
     try again.

   You can only run one debugger process at a time.

   Each of these commands takes one argument: a command line to invoke
the debugger.  In the simplest case, specify just the name of the
executable file you want to debug.  You may also use options that the
debugger supports.  However, shell wild cards and variables are not
allowed.  GUD assumes that the first argument not preceded by a `-' is
the executable file name.


File: emacs,  Node: Debugger Operation,  Next: Commands of GUD,  Prev: Starting GUD,  Up: Debuggers

Debugger Operation
------------------

   When you run a debugger with GUD, the debugger uses an Emacs buffer
for its ordinary input and output.  This is called the GUD buffer.  The
debugger uses other Emacs buffers to display the source files of the
program.  An arrow (`=>') in one of these buffers indicates the current
execution line.  Moving point in this buffer does not move the arrow.

   You can start editing these source files at any time in the buffers
that were made to display them.  The arrow is not part of the file's
text; it appears only on the screen.  If you do modify a source file,
keep in mind that inserting or deleting lines will throw off the arrow's
positioning; GUD has no way of figuring out which line corresponded
before your changes to the line number in a debugger message.  Also,
you'll typically have to recompile and restart the program for your
changes to be reflected in the debugger's tables.

   If you wish, you can control your debugger process entirely through
the debugger buffer, which uses a variant of Shell mode.  All the usual
commands for your debugger are available, and you can use the Shell mode
history commands to repeat them.


File: emacs,  Node: Commands of GUD,  Next: GUD Customization,  Prev: Debugger Operation,  Up: Debuggers

Commands of GUD
---------------

   The GUD interaction buffer uses a variant of Shell mode, so the
commands of Shell mode are available (*note Shell Mode::.).

   GUD provides a command available in all buffers for setting
breakpoints.  This command is defined globally because you need to use
it in the source files' buffers.

`C-x SPC'
     Set a breakpoint on the line that point is on.

   Here are the other special commands provided by GUD.  The keys
starting with `C-c' are available only in the GUD interaction buffer.
The bindings that start with `C-x C-a' are available in the GUD buffer
and also in source files.

`TAB'
     With GDB, complete a symbol name (`gud-gdb-complete-command').
     This key is available only in the GUD interaction buffer.

`C-c C-l'
`C-x C-a C-l'
     Display in another window the last line referred to in the GUD
     buffer (that is, the line indicated in the last location message).
     This runs the command `gud-refresh'.

`C-c C-s'
`C-x C-a C-s'
     Execute a single line of code (`gud-step').  If the code contains
     a function call, execution stops after entering the called
     function.

`C-c C-n'
`C-x C-a C-n'
     Execute a single line of code, stepping across entire function
     calls at full speed (`gud-next').

`C-c C-i'
`C-x C-a C-i'
     Execute a single machine instruction (`gud-stepi').

`C-c C-r'
`C-x C-a C-r'
     Continue execution until the next breakpoint, or other event that
     would normally stop the program (`gud-cont').

`C-c C-d'
`C-x C-a C-d'
     Delete the breakpoint(s) on the current source line, if any
     (`gud-remove').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

`C-c C-t'
`C-x C-a C-t'
     Set a temporary breakpoint on the current source line, if any.  If
     you use this command in the GUD interaction buffer, it applies to
     the line where the program last stopped.

   The above commands are common to all supported debuggers.  If you are
using GDB or (some versions of) DBX, these additional commands are
available:

`C-c <'
`C-x C-a <'
     Select the next enclosing stack frame (`gud-up').  This is
     equivalent to the `up' command.

`C-c >'
`C-x C-a >'
     Select the next inner stack frame (`gud-down').  This is
     equivalent to the `down' command.

   If you are using GDB, two additional keybindings are available:

`C-c C-f'
`C-x C-a C-f'
     Run the program until the selected stack frame returns (or until it
     stops for some other reason).

   These commands interpret a prefix argument as a repeat count, when
that makes sense.

