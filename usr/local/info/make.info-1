This is Info file make.info, produced by Makeinfo-1.54 from the input
file ./make.texinfo.

   This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

   This is Edition 0.45, last updated 11 May 1994, of `The GNU Make
Manual', for `make', Version 3.71 Beta.

   Copyright (C) 1988, '89, '90, '91, '92, '93, '94 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: make.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

Make
****

   The GNU `make' utility automatically determines which pieces of a
large program need to be recompiled, and issues the commands to
recompile them.

   This is Edition 0.45 of the `GNU Make Manual', last updated 11 May
1994 for `make' Version 3.71 Beta.

   This manual describes `make' and contains the following chapters:

* Menu:

* Overview::                    Overview of `make'.
* Introduction::                An introduction to `make'.
* Makefiles::                   Makefiles tell `make' what to do.
* Rules::                       Rules describe when a file must be remade.
* Commands::                    Commands say how to remake a file.
* Using Variables::             You can use variables to avoid repetition.
* Conditionals::                Use or ignore parts of the makefile based
                                 on the values of variables.
* Functions::                   Many powerful ways to manipulate text.
* make Invocation: Running.     How to invoke `make' on the command line.
* Implicit Rules::              Use implicit rules to treat many files alike,
                                 based on their file names.
* Archives::                    How `make' can update library archives.
* Features::                    Features GNU `make' has over other `make's.
* Missing::                     What GNU `make' lacks from other `make's.
* Makefile Conventions::        Conventions for makefiles in GNU programs.
* Quick Reference::             A quick reference for experienced users.
* Complex Makefile::            A real example of a straightforward,
                                 but nontrivial, makefile.
* Concept Index::               Index of Concepts
* Name Index::                  Index of Functions, Variables, & Directives

 -- The Detailed Node Listing --

Overview of `make'

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs

An Introduction to Makefiles

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Dependency::       Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory

Writing Makefiles

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                 with another makefile.

Writing Rules

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or dependencies to mark other
                                  targets as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the dependencies according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Dependencies::      How to automatically generate rules giving
                                 dependencies from the source files themselves.

Using Wildcard Characters in File Names

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.

Searching Directories for Dependencies

* General Search::              Specifying a search path that applies
                                  to every dependency.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.

Static Pattern Rules

* Static Usage::                The syntax of static pattern rules.
* Static versus Implicit::      When are they better than implicit rules?

Writing the Commands in Rules

* Echoing::                     How to control when commands are echoed.
* Execution::                   How commands are executed.
* Parallel::                    How commands can be executed in parallel.
* Errors::                      What happens after a command execution error.
* Interrupts::                  What happens when a command is interrupted.
* Recursion::                   Invoking `make' from makefiles.
* Sequences::                   Defining canned sequences of commands.
* Empty Commands::              Defining useful, do-nothing commands.

Recursive Use of `make'

* MAKE Variable::               The special effects of using `$(MAKE)'.
* Variables/Recursion::         How to communicate variables to a sub-`make'.
* Options/Recursion::           How to communicate options to a sub-`make'.
* -w Option::                   How the `-w' or `--print-directory' option
                                 helps debug use of recursive `make' commands.

How to Use Variables

* Reference::                   How to use the value of a variable.
* Flavors::                     Variables come in two flavors.
* Advanced::                    Advanced features for referencing a variable.
* Values::                      All the ways variables get their values.
* Setting::                     How to set a variable in the makefile.
* Appending::                   How to append more text to the old value
                                  of a variable.
* Override Directive::          How to set a variable in the makefile even if
                                  the user has set it with a command argument.
* Defining::                    An alternate way to set a variable
                                  to a verbatim string.
* Environment::                 Variable values can come from the environment.

Advanced Features for Reference to Variables

* Substitution Refs::           Referencing a variable with
                                  substitutions on the value.
* Computed Names::              Computing the name of the variable to refer to.

Conditional Parts of Makefiles

* Conditional Example::         Example of a conditional
* Conditional Syntax::          The syntax of conditionals.
* Testing Flags::               Conditionals that test flags.

Functions for Transforming Text

* Syntax of Functions::         How to write a function call.
* Text Functions::              General-purpose text manipulation functions.
* Filename Functions::          Functions for manipulating file names.
* Foreach Function::            Repeat some text with controlled variation.
* Origin Function::             Find where a variable got its value.
* Shell Function::              Substitute the output of a shell command.

How to Run `make'

* Makefile Arguments::          How to specify which makefile to use.
* Goals::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* Instead of Execution::        How to use mode flags to specify what
                                  kind of thing to do with the commands
                                  in the makefile other than simply
                                  execute them.
* Avoiding Compilation::        How to avoid recompiling certain files.
* Overriding::                  How to override a variable to specify
                                  an alternate compiler and other things.
* Testing::                     How to proceed past some errors, to
                                  test compilation.
* Options Summary::             Summary of Options

Using Implicit Rules

* Using Implicit::              How to use an existing implicit rule
                                  to get the commands for updating a file.
* Catalogue of Rules::          A list of built-in implicit rules.
* Implicit Variables::          How to change what predefined rules do.
* Chained Rules::               How to use a chain of implicit rules.
* Pattern Rules::               How to define new implicit rules.
* Last Resort::                 How to defining commands for rules
                                  which cannot find any.
* Suffix Rules::                The old-fashioned style of implicit rule.
* Search Algorithm::            The precise algorithm for applying
                                  implicit rules.

Defining and Redefining Pattern Rules

* Pattern Intro::               An introduction to pattern rules.
* Pattern Examples::            Examples of pattern rules.
* Automatic::                   How to use automatic variables in the
                                  commands of implicit rules.
* Pattern Match::               How patterns match.
* Match-Anything Rules::        Precautions you should take prior to
                                  defining rules that can match any
                                  target file whatever.
* Canceling Rules::             How to override or cancel built-in rules.

Using `make' to Update Archive Files

* Archive Members::             Archive members as targets.
* Archive Update::              The implicit rule for archive member targets.
* Archive Suffix Rules::        You can write a special kind of suffix rule
                                  for updating archives.

Implicit Rule for Archive Member Targets

* Archive Symbols::             How to update archive symbol directories.


File: make.info,  Node: Overview,  Next: Introduction,  Prev: Top,  Up: Top

Overview of `make'
******************

   The `make' utility automatically determines which pieces of a large
program need to be recompiled, and issues commands to recompile them.
This manual describes GNU `make', which was implemented by Richard
Stallman and Roland McGrath.  GNU `make' conforms to section 6.2 of
`IEEE Standard 1003.2-1992' (POSIX.2).

   Our examples show C programs, since they are most common, but you
can use `make' with any programming language whose compiler can be run
with a shell command.  Indeed, `make' is not limited to programs.  You
can use it to describe any task where some files must be updated
automatically from others whenever the others change.

* Menu:

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs


File: make.info,  Node: Preparing,  Next: Reading,  Up: Overview

Preparing and Running Make
==========================

   To prepare to use `make', you must write a file called the
"makefile" that describes the relationships among files in your program
and provides commands for updating each file.  In a program, typically,
the executable file is updated from object files, which are in turn
made by compiling source files.

   Once a suitable makefile exists, each time you change some source
files, this simple shell command:

     make

suffices to perform all necessary recompilations.  The `make' program
uses the makefile data base and the last-modification times of the
files to decide which of the files need to be updated.  For each of
those files, it issues the commands recorded in the data base.

   You can provide command line arguments to `make' to control which
files should be recompiled, or how.  *Note How to Run `make': Running.


File: make.info,  Node: Reading,  Next: Bugs,  Prev: Preparing,  Up: Overview

How to Read This Manual
=======================

   If you are new to `make', or are looking for a general introduction,
read the first few sections of each chapter, skipping the later
sections.  In each chapter, the first few sections contain introductory
or general information and the later sections contain specialized or
technical information.  The exception is the second chapter, *Note An
Introduction to Makefiles: Introduction, all of which is introductory.

   If you are familiar with other `make' programs, see *Note Features
of GNU `make': Features, which lists the enhancements GNU `make' has,
and *Note Incompatibilities and Missing Features: Missing, which
explains the few things GNU `make' lacks that others have.

   For a quick summary, see *Note Options Summary::, *Note Quick
Reference::, and *Note Special Targets::.


File: make.info,  Node: Bugs,  Prev: Reading,  Up: Overview

Problems and Bugs
=================

   If you have problems with GNU `make' or think you've found a bug,
please report it to the developers; we cannot promise to do anything but
we might well want to fix it.

   Before reporting a bug, make sure you've actually found a real bug.
Carefully reread the documentation and see if it really says you can do
what you're trying to do.  If it's not clear whether you should be able
to do something or not, report that too; it's a bug in the
documentation!

   Before reporting a bug or trying to fix it yourself, try to isolate
it to the smallest possible makefile that reproduces the problem.  Then
send us the makefile and the exact results `make' gave you.  Also say
what you expected to occur; this will help us decide whether the
problem was really in the documentation.

   Once you've got a precise problem, please send electronic mail either
through the Internet or via UUCP:

     Internet address:
         bug-gnu-utils@prep.ai.mit.edu
     
     UUCP path:
         mit-eddie!prep.ai.mit.edu!bug-gnu-utils

Please include the version number of `make' you are using.  You can get
this information with the command `make --version'.  Be sure also to
include the type of machine and operating system you are using.  If
possible, include the contents of the file `config.h' that is generated
by the configuration process.

   Non-bug suggestions are always welcome as well.  If you have
questions about things that are unclear in the documentation or are
just obscure features, send a message to the bug reporting address.  We
cannot guarantee you'll get help with your problem, but many seasoned
`make' users read the mailing list and they will probably try to help
you out.  The maintainers sometimes answer such questions as well, when
time permits.


File: make.info,  Node: Introduction,  Next: Makefiles,  Prev: Overview,  Up: Top

An Introduction to Makefiles
****************************

   You need a file called a "makefile" to tell `make' what to do.  Most
often, the makefile tells `make' how to compile and link a program.

   In this chapter, we will discuss a simple makefile that describes
how to compile and link a text editor which consists of eight C source
files and three header files.  The makefile can also tell `make' how to
run miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).  To see a more complex example
of a makefile, see *Note Complex Makefile::.

   When `make' recompiles the editor, each changed C source file must
be recompiled.  If a header file has changed, each C source file that
includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.

* Menu:

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Dependency::       Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory


File: make.info,  Node: Rule Introduction,  Next: Simple Makefile,  Up: Introduction

What a Rule Looks Like
======================

   A simple makefile consists of "rules" with the following shape:

     TARGET ... : DEPENDENCIES ...
             COMMAND
             ...
             ...

   A "target" is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the name of an action to carry out, such as `clean' (*note
Phony Targets::.).

   A "dependency" is a file that is used as input to create the target.
A target often depends on several files.

   A "command" is an action that `make' carries out.  A rule may have
more than one command, each on its own line.  *Please note:* you need
to put a tab character at the beginning of every command line!  This is
an obscurity that catches the unwary.

   Usually a command is in a rule with dependencies and serves to
create a target file if any of the dependencies change.  However, the
rule that specifies commands for the target need not have dependencies.
For example, the rule containing the delete command associated with the
target `clean' does not have dependencies.

   A "rule", then, explains how and when to remake certain files which
are the targets of the particular rule.  `make' carries out the
commands on the dependencies to create or update the target.  A rule
can also explain how and when to carry out an action.  *Note Writing
Rules: Rules.

   A makefile may contain other text besides rules, but a simple
makefile need only contain rules.  Rules may look somewhat more
complicated than shown in this template, but all fit the pattern more
or less.


File: make.info,  Node: Simple Makefile,  Next: How Make Works,  Prev: Rule Introduction,  Up: Introduction

A Simple Makefile
=================

   Here is a straightforward makefile that describes the way an
executable file called `edit' depends on eight object files which, in
turn, depend on eight C source and three header files.

   In this example, all the C files include `defs.h', but only those
defining editing commands include `command.h', and only low level files
that change the editor buffer include `buffer.h'.

     edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o
     
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

We split each long line into two lines using backslash-newline; this is
like using one long line, but is easier to read.

   To use this makefile to create the executable file called `edit',
type:

     make

   To use this makefile to delete the executable file and all the object
files from the directory, type:

     make clean

   In the example makefile, the targets include the executable file
`edit', and the object files `main.o' and `kbd.o'.  The dependencies
are files such as `main.c' and `defs.h'.  In fact, each `.o' file is
both a target and a dependency.  Commands include `cc -c main.c' and
`cc -c kbd.c'.

   When a target is a file, it needs to be recompiled or relinked if any
of its dependencies change.  In addition, any dependencies that are
themselves automatically generated should be updated first.  In this
example, `edit' depends on each of the eight object files; the object
file `main.o' depends on the source file `main.c' and on the header
file `defs.h'.

   A shell command follows each line that contains a target and
dependencies.  These shell commands say how to update the target file.
A tab character must come at the beginning of every command line to
distinguish commands lines from other lines in the makefile.  (Bear in
mind that `make' does not know anything about how the commands work.
It is up to you to supply commands that will update the target file
properly.  All `make' does is execute the commands in the rule you have
specified when the target file needs to be updated.)

   The target `clean' is not a file, but merely the name of an action.
Since you normally do not want to carry out the actions in this rule,
`clean' is not a dependency of any other rule.  Consequently, `make'
never does anything with it unless you tell it specifically.  Note that
this rule not only is not a dependency, it also does not have any
dependencies, so the only purpose of the rule is to run the specified
commands.  Targets that do not refer to files but are just actions are
called "phony targets".  *Note Phony Targets::, for information about
this kind of target.  *Note Errors in Commands: Errors, to see how to
cause `make' to ignore errors from `rm' or any other command.


File: make.info,  Node: How Make Works,  Next: Variables Simplify,  Prev: Simple Makefile,  Up: Introduction

How `make' Processes a Makefile
===============================

   By default, `make' starts with the first rule (not counting rules
whose target names start with `.').  This is called the "default goal".
("Goals" are the targets that `make' strives ultimately to update.
*Note Arguments to Specify the Goals: Goals.)

   In the simple example of the previous section, the default goal is to
update the executable program `edit'; therefore, we put that rule first.

   Thus, when you give the command:

     make

`make' reads the makefile in the current directory and begins by
processing the first rule.  In the example, this rule is for relinking
`edit'; but before `make' can fully process this rule, it must process
the rules for the files that `edit' depends on, which in this case are
the object files.  Each of these files is processed according to its
own rule.  These rules say to update each `.o' file by compiling its
source file.  The recompilation must be done if the source file, or any
of the header files named as dependencies, is more recent than the
object file, or if the object file does not exist.

   The other rules are processed because their targets appear as
dependencies of the goal.  If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell `make' to do so (with a command such as `make clean').

   Before recompiling an object file, `make' considers updating its
dependencies, the source file and header files.  This makefile does not
specify anything to be done for them--the `.c' and `.h' files are not
the targets of any rules--so `make' does nothing for these files.  But
`make' would update automatically generated C programs, such as those
made by Bison or Yacc, by their own rules at this time.

   After recompiling whichever object files need it, `make' decides
whether to relink `edit'.  This must be done if the file `edit' does
not exist, or if any of the object files are newer than it.  If an
object file was just recompiled, it is now newer than `edit', so `edit'
is relinked.

   Thus, if we change the file `insert.c' and run `make', `make' will
compile that file to update `insert.o', and then link `edit'.  If we
change the file `command.h' and run `make', `make' will recompile the
object files `kbd.o', `command.o' and `files.o' and then link the file
`edit'.


File: make.info,  Node: Variables Simplify,  Next: make Deduces,  Prev: How Make Works,  Up: Introduction

Variables Make Makefiles Simpler
================================

   In our example, we had to list all the object files twice in the
rule for `edit' (repeated here):

     edit : main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

   Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can
eliminate the risk and simplify the makefile by using a variable.
"Variables" allow a text string to be defined once and substituted in
multiple places later (*note How to Use Variables: Using Variables.).

   It is standard practice for every makefile to have a variable named
`objects', `OBJECTS', `objs', `OBJS', `obj', or `OBJ' which is a list
of all object file names.  We would define such a variable `objects'
with a line like this in the makefile:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we can
substitute the variable's value by writing `$(objects)' (*note How to
Use Variables: Using Variables.).

   Here is how the complete simple makefile looks when you use a
variable for the object files:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o
     
     edit : $(objects)
             cc -o edit $(objects)
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit $(objects)


File: make.info,  Node: make Deduces,  Next: Combine By Dependency,  Prev: Variables Simplify,  Up: Introduction

Letting `make' Deduce the Commands
==================================

   It is not necessary to spell out the commands for compiling the
individual C source files, because `make' can figure them out: it has an
"implicit rule" for updating a `.o' file from a correspondingly named
`.c' file using a `cc -c' command.  For example, it will use the
command `cc -c main.c -o main.o' to compile `main.c' into `main.o'.  We
can therefore omit the commands from the rules for the object files.
*Note Using Implicit Rules: Implicit Rules.

   When a `.c' file is used automatically in this way, it is also
automatically added to the list of dependencies.  We can therefore omit
the `.c' files from the dependencies, provided we omit the commands.

   Here is the entire example, with both of these changes, and a
variable `objects' as suggested above:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o
     
     edit : $(objects)
             cc -o edit $(objects)
     
     main.o : defs.h
     kbd.o : defs.h command.h
     command.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.h
     
     .PHONY : clean
     clean :
             -rm edit $(objects)

This is how we would write the makefile in actual practice.  (The
complications associated with `clean' are described elsewhere.  See
*Note Phony Targets::, and *Note Errors in Commands: Errors.)

   Because implicit rules are so convenient, they are important.  You
will see them used frequently.


File: make.info,  Node: Combine By Dependency,  Next: Cleanup,  Prev: make Deduces,  Up: Introduction

Another Style of Makefile
=========================

   When the objects of a makefile are created only by implicit rules, an
alternative style of makefile is possible.  In this style of makefile,
you group entries by their dependencies instead of by their targets.
Here is what one looks like:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o
     
     edit : $(objects)
             cc -o edit $(objects)
     
     $(objects) : defs.h
     kbd.o command.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

Here `defs.h' is given as a dependency of all the object files;
`command.h' and `buffer.h' are dependencies of the specific object
files listed for them.

   Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one place.


File: make.info,  Node: Cleanup,  Prev: Combine By Dependency,  Up: Introduction

Rules for Cleaning the Directory
================================

   Compiling a program is not the only thing you might want to write
rules for.  Makefiles commonly tell how to do a few other things besides
compiling a program: for example, how to delete all the object files
and executables so that the directory is `clean'.

   Here is how we could write a `make' rule for cleaning our example
editor:

     clean:
             rm edit $(objects)

   In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations.  We would do
this:

     .PHONY : clean
     clean :
             -rm edit $(objects)

This prevents `make' from getting confused by an actual file called
`clean' and causes it to continue in spite of errors from `rm'.  (See
*Note Phony Targets::, and *Note Errors in Commands: Errors.)

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefile, we want the rule for `edit', which recompiles the
editor, to remain the default goal.

   Since `clean' is not a dependency of `edit', this rule will not run
at all if we give the command `make' with no arguments.  In order to
make the rule run, we have to type `make clean'.  *Note How to Run
`make': Running.


File: make.info,  Node: Makefiles,  Next: Rules,  Prev: Introduction,  Up: Top

Writing Makefiles
*****************

   The information that tells `make' how to recompile a system comes
from reading a data base called the "makefile".

* Menu:

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                 with another makefile.


File: make.info,  Node: Makefile Contents,  Next: Makefile Names,  Up: Makefiles

What Makefiles Contain
======================

   Makefiles contain five kinds of things: "explicit rules", "implicit
rules", "variable definitions", "directives", and "comments".  Rules,
variables, and directives are described at length in later chapters.

   * An "explicit rule" says when and how to remake one or more files,
     called the rule's targets.  It lists the other files that the
     targets "depend on", and may also give commands to use to create
     or update the targets.  *Note Writing Rules: Rules.

   * An "implicit rule" says when and how to remake a class of files
     based on their names.  It describes how a target may depend on a
     file with a name similar to the target and gives commands to
     create or update such a target.  *Note Using Implicit Rules:
     Implicit Rules.

   * A "variable definition" is a line that specifies a text string
     value for a variable that can be substituted into the text later.
     The simple makefile example shows a variable definition for
     `objects' as a list of all object files (*note Variables Make
     Makefiles Simpler: Variables Simplify.).

   * A "directive" is a command for `make' to do something special while
     reading the makefile.  These include:

        * Reading another makefile (*note Including Other Makefiles:
          Include.).

        * Deciding (based on the values of variables) whether to use or
          ignore a part of the makefile (*note Conditional Parts of
          Makefiles: Conditionals.).

        * Defining a variable from a verbatim string containing
          multiple lines (*note Defining Variables Verbatim: Defining.).

   * `#' in a line of a makefile starts a "comment".  It and the rest of
     the line are ignored, except that a trailing backslash not escaped
     by another backslash will continue the comment across multiple
     lines.  Comments may appear on any of the lines in the makefile,
     except within a `define' directive, and perhaps within commands
     (where the shell decides what is a comment).  A line containing
     just a comment (with perhaps spaces before it) is effectively
     blank, and is ignored.


File: make.info,  Node: Makefile Names,  Next: Include,  Prev: Makefile Contents,  Up: Makefiles

What Name to Give Your Makefile
===============================

   By default, when `make' looks for the makefile, it tries the
following names, in order: `GNUmakefile', `makefile' and `Makefile'.

   Normally you should call your makefile either `makefile' or
`Makefile'.  (We recommend `Makefile' because it appears prominently
near the beginning of a directory listing, right near other important
files such as `README'.)  The first name checked, `GNUmakefile', is not
recommended for most makefiles.  You should use this name if you have a
makefile that is specific to GNU `make', and will not be understood by
other versions of `make'.  Other `make' programs look for `makefile' and
`Makefile', but not `GNUmakefile'.

   If `make' finds none of these names, it does not use any makefile.
Then you must specify a goal with a command argument, and `make' will
attempt to figure out how to remake it using only its built-in implicit
rules.  *Note Using Implicit Rules: Implicit Rules.

   If you want to use a nonstandard name for your makefile, you can
specify the makefile name with the `-f' or `--file' option.  The
arguments `-f NAME' or `--file=NAME' tell `make' to read the file NAME
as the makefile.  If you use more than one `-f' or `--file' option, you
can specify several makefiles.  All the makefiles are effectively
concatenated in the order specified.  The default makefile names
`GNUmakefile', `makefile' and `Makefile' are not checked automatically
if you specify `-f' or `--file'.


File: make.info,  Node: Include,  Next: MAKEFILES Variable,  Prev: Makefile Names,  Up: Makefiles

Including Other Makefiles
=========================

   The `include' directive tells `make' to suspend reading the current
makefile and read one or more other makefiles before continuing.  The
directive is a line in the makefile that looks like this:

     include FILENAMES...

FILENAMES can contain shell file name patterns.

   Extra spaces are allowed and ignored at the beginning of the line,
but a tab is not allowed.  (If the line begins with a tab, it will be
considered a command line.)  Whitespace is required between `include'
and the file names, and between file names; extra whitespace is ignored
there and at the end of the directive.  A comment starting with `#' is
allowed at the end of the line.  If the file names contain any variable
or function references, they are expanded.  *Note How to Use Variables:
Using Variables.

   For example, if you have three `.mk' files, `a.mk', `b.mk', and
`c.mk', and `$(bar)' expands to `bish bash', then the following
expression

     include foo *.mk $(bar)

   is equivalent to

     include foo a.mk b.mk c.mk bish bash

   When `make' processes an `include' directive, it suspends reading of
the containing makefile and reads from each listed file in turn.  When
that is finished, `make' resumes reading the makefile in which the
directive appears.

   One occasion for using `include' directives is when several programs,
handled by individual makefiles in various directories, need to use a
common set of variable definitions (*note Setting Variables: Setting.)
or pattern rules (*note Defining and Redefining Pattern Rules: Pattern
Rules.).

   Another such occasion is when you want to generate dependencies from
source files automatically; the dependencies can be put in a file that
is included by the main makefile.  This practice is generally cleaner
than that of somehow appending the dependencies to the end of the main
makefile as has been traditionally done with other versions of `make'.
*Note Automatic Dependencies::.

   If the specified name does not start with a slash, and the file is
not found in the current directory, several other directories are
searched.  First, any directories you have specified with the `-I' or
`--include-dir' option are searched (*note Summary of Options: Options
Summary.).  Then the following directories (if they exist) are
searched, in this order: `PREFIX/include' (normally
`/usr/local/include') `/usr/gnu/include', `/usr/local/include',
`/usr/include'.

   If an included makefile cannot be found in any of these directories,
a warning message is generated, but it is not an immediately fatal
error; processing of the makefile containing the `include' continues.
Once it has finished reading makefiles, `make' will try to remake any
that are out of date or don't exist.  *Note How Makefiles Are Remade:
Remaking Makefiles.  Only after it has tried to find a way to remake a
makefile and failed, will `make' diagnose the missing makefile as a
fatal error.

   If you want `make' to simply ignore a makefile which does not exist
and cannot be remade, with no error message, use the `-include'
directive instead of `include', like this:

     -include FILENAMES...

   This is acts like `include' in every way except that there is no
error (not even a warning) if any of the FILENAMES do not exist.


File: make.info,  Node: MAKEFILES Variable,  Next: Remaking Makefiles,  Prev: Include,  Up: Makefiles

The Variable `MAKEFILES'
========================

   If the environment variable `MAKEFILES' is defined, `make' considers
its value as a list of names (separated by whitespace) of additional
makefiles to be read before the others.  This works much like the
`include' directive: various directories are searched for those files
(*note Including Other Makefiles: Include.).  In addition, the default
goal is never taken from one of these makefiles and it is not an error
if the files listed in `MAKEFILES' are not found.

   The main use of `MAKEFILES' is in communication between recursive
invocations of `make' (*note Recursive Use of `make': Recursion.).  It
usually is not desirable to set the environment variable before a
top-level invocation of `make', because it is usually better not to
mess with a makefile from outside.  However, if you are running `make'
without a specific makefile, a makefile in `MAKEFILES' can do useful
things to help the built-in implicit rules work better, such as
defining search paths (*note Directory Search::.).

   Some users are tempted to set `MAKEFILES' in the environment
automatically on login, and program makefiles to expect this to be done.
This is a very bad idea, because such makefiles will fail to work if
run by anyone else.  It is much better to write explicit `include'
directives in the makefiles.  *Note Including Other Makefiles: Include.


File: make.info,  Node: Remaking Makefiles,  Next: Overriding Makefiles,  Prev: MAKEFILES Variable,  Up: Makefiles

How Makefiles Are Remade
========================

   Sometimes makefiles can be remade from other files, such as RCS or
SCCS files.  If a makefile can be remade from other files, you probably
want `make' to get an up-to-date version of the makefile to read in.

   To this end, after reading in all makefiles, `make' will consider
each as a goal target and attempt to update it.  If a makefile has a
rule which says how to update it (found either in that very makefile or
in another one) or if an implicit rule applies to it (*note Using
Implicit Rules: Implicit Rules.), it will be updated if necessary.
After all makefiles have been checked, if any have actually been
changed, `make' starts with a clean slate and reads all the makefiles
over again.  (It will also attempt to update each of them over again,
but normally this will not change them again, since they are already up
to date.)

   If the makefiles specify a double-colon rule to remake a file with
commands but no dependencies, that file will always be remade (*note
Double-Colon::.).  In the case of makefiles, a makefile that has a
double-colon rule with commands but no dependencies will be remade every
time `make' is run, and then again after `make' starts over and reads
the makefiles in again.  This would cause an infinite loop: `make'
would constantly remake the makefile, and never do anything else.  So,
to avoid this, `make' will *not* attempt to remake makefiles which are
specified as double-colon targets but have no dependencies.

   If you do not specify any makefiles to be read with `-f' or `--file'
options, `make' will try the default makefile names; *note What Name to
Give Your Makefile: Makefile Names..  Unlike makefiles explicitly
requested with `-f' or `--file' options, `make' is not certain that
these makefiles should exist.  However, if a default makefile does not
exist but can be created by running `make' rules, you probably want the
rules to be run so that the makefile can be used.

   Therefore, if none of the default makefiles exists, `make' will try
to make each of them in the same order in which they are searched for
(*note What Name to Give Your Makefile: Makefile Names.) until it
succeeds in making one, or it runs out of names to try.  Note that it
is not an error if `make' cannot find or make any makefile; a makefile
is not always necessary.

   When you use the `-t' or `--touch' option (*note Instead of
Executing the Commands: Instead of Execution.), you would not want to
use an out-of-date makefile to decide which targets to touch.  So the
`-t' option has no effect on updating makefiles; they are really
updated even if `-t' is specified.  Likewise, `-q' (or `--question')
and `-n' (or `--just-print') do not prevent updating of makefiles,
because an out-of-date makefile would result in the wrong output for
other targets.  Thus, `make -f mfile -n foo' will update `mfile', read
it in, and then print the commands to update `foo' and its dependencies
without running them.  The commands printed for `foo' will be those
specified in the updated contents of `mfile'.

   However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by specifying the makefiles as
goals in the command line as well as specifying them as makefiles.
When the makefile name is specified explicitly as a goal, the options
`-t' and so on do apply to them.

   Thus, `make -f mfile -n mfile foo' would read the makefile `mfile',
print the commands needed to update it without actually running them,
and then print the commands needed to update `foo' without running
them.  The commands for `foo' will be those specified by the existing
contents of `mfile'.


File: make.info,  Node: Overriding Makefiles,  Prev: Remaking Makefiles,  Up: Makefiles

Overriding Part of Another Makefile
===================================

   Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the `include' directive to include
one in the other, and add more targets or variable definitions.
However, if the two makefiles give different commands for the same
target, `make' will not let you just do this.  But there is another way.

   In the containing makefile (the one that wants to include the other),
you can use a match-anything pattern rule to say that to remake any
target that cannot be made from the information in the containing
makefile, `make' should look in another makefile.  *Note Pattern
Rules::, for more information on pattern rules.

   For example, if you have a makefile called `Makefile' that says how
to make the target `foo' (and other targets), you can write a makefile
called `GNUmakefile' that contains:

     foo:
             frobnicate > foo
     
     %: force
             @$(MAKE) -f Makefile $@
     force: ;

   If you say `make foo', `make' will find `GNUmakefile', read it, and
see that to make `foo', it needs to run the command `frobnicate > foo'.
If you say `make bar', `make' will find no way to make `bar' in
`GNUmakefile', so it will use the commands from the pattern rule: `make
-f Makefile bar'.  If `Makefile' provides a rule for updating `bar',
`make' will apply the rule.  And likewise for any other target that
`GNUmakefile' does not say how to make.

   The way this works is that the pattern rule has a pattern of just
`%', so it matches any target whatever.  The rule specifies a
dependency `force', to guarantee that the commands will be run even if
the target file already exists.  We give `force' target empty commands
to prevent `make' from searching for an implicit rule to build
it--otherwise it would apply the same match-anything rule to `force'
itself and create a dependency loop!


File: make.info,  Node: Rules,  Next: Commands,  Prev: Makefiles,  Up: Top

Writing Rules
*************

   A "rule" appears in the makefile and says when and how to remake
certain files, called the rule's "targets" (most often only one per
rule).  It lists the other files that are the "dependencies" of the
target, and "commands" to use to create or update the target.

   The order of rules is not significant, except for determining the
"default goal": the target for `make' to consider, if you do not
otherwise specify one.  The default goal is the target of the first
rule in the first makefile.  If the first rule has multiple targets,
only the first target is taken as the default.  There are two
exceptions: a target starting with a period is not a default unless it
contains one or more slashes, `/', as well; and, a target that defines
a pattern rule has no effect on the default goal.  (*Note Defining and
Redefining Pattern Rules: Pattern Rules.)

   Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs described
by the makefile (often with a target called `all').  *Note Arguments to
Specify the Goals: Goals.

* Menu:

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or dependencies to mark other
                                  targets as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the dependencies according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Dependencies::      How to automatically generate rules giving
                                 dependencies from the source files themselves.

