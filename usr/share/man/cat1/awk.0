


MAWK(1)                        1992                       MAWK(1)


NNAAMMEE
       mawk - pattern scanning and text processing language


SSYYNNOOPPSSIISS
       mmaawwkk  [-WW  _o_p_t_i_o_n] [-FF _v_a_l_u_e] [-vv _v_a_r=_v_a_l_u_e] [--] 'program
       text' [file ...]
       mmaawwkk [-WW _o_p_t_i_o_n] [-FF _v_a_l_u_e] [-vv  _v_a_r=_v_a_l_u_e]  [-ff  _p_r_o_g_r_a_m-
       _f_i_l_e] [--] [file ...]


DDEESSCCRRIIPPTTIIOONN
       mmaawwkk  is  an interpreter for the AWK Programming Language.
       The AWK language is useful for manipulation of data files,
       text  retrieval  and  processing,  and for prototyping and
       experimenting with algorithms.  mmaawwkk is a _n_e_w _a_w_k  meaning
       it   implements  the  AWK  language  as  defined  in  Aho,
       Kernighan and Weinberger, _T_h_e  _A_W_K  _P_r_o_g_r_a_m_m_i_n_g  _L_a_n_g_u_a_g_e,
       Addison-Wesley  Publishing,  1988.  (Hereafter referred to
       as the AWK book.)   mmaawwkk  conforms  to  the  Posix  1003.2
       (draft 11.2) definition of the AWK language which contains
       a few features not described in the AWK  book,   and  mmaawwkk
       provides a small number of extensions.

       An AWK program is a sequence of _p_a_t_t_e_r_n {_a_c_t_i_o_n} pairs and
       function definitions.  Short programs are entered  on  the
       command line usually enclosed in ' ' to avoid shell inter-
       pretation.  Longer programs can be read  in  from  a  file
       with  the -f option.  Data  input is read from the list of
       files on the command line or from standard input when  the
       list is empty.  The input is broken into records as deter-
       mined by the record separator variable, RRSS.  Initially, RRSS
       = "\n" and records are synonymous with lines.  Each record
       is compared against each _p_a_t_t_e_r_n and if  it  matches,  the
       program text for {_a_c_t_i_o_n} is executed.


OOPPTTIIOONNSS
       -FF
                                                                  _v_a_l_u_e                                                   sets
                                                                  the
                                                                  field
                                                                  sep-
                                                                  a-
                                                                  ra-
                                                                  tor,
                                                                  FFSS,
                                                                  to
                                                                  _v_a_l_u_e.


       -ff
                                                                  _f_i_l_e                                                    Pro-
                                                                  gram



22                             Jan                              1





MAWK(1)                        1992                       MAWK(1)


                                                                  text
                                                                  is
                                                                  read
                                                                  from
                                                                  _f_i_l_e
                                                                  instead
                                                                  of
                                                                  from
                                                                  the
                                                                  com-
                                                                  mand
                                                                  line.
                                                                  Mul-
                                                                  ti-
                                                                  ple
                                                                  -f
                                                                  options
                                                                  are
                                                                  allowed.


       -vv
                                                                  _v_a_r=_v_a_l_u_e                                               assigns
                                                                  _v_a_l_u_e
                                                                  to
                                                                  pro-
                                                                  gram
                                                                  vari-
                                                                  able
                                                                  _v_a_r.


       --                                                         indi-
                                                                  cates
                                                                  the
                                                                  unam-
                                                                  bigu-
                                                                  ous
                                                                  end
                                                                  of
                                                                  options.

       The above options will be available with any Posix compat-
       ible  implementation  of  AWK, and implementation specific
       options are prefaced with -W.  mmaawwkk provides three:


       -WW
                                                                  version                                                 mmaawwkk
                                                                  writes
                                                                  its
                                                                  ver-
                                                                  sion
                                                                  and



22                             Jan                              2





MAWK(1)                        1992                       MAWK(1)


                                                                  copy-
                                                                  right
                                                                  to
                                                                  std-
                                                                  out
                                                                  and
                                                                  com-
                                                                  piled
                                                                  lim-
                                                                  its
                                                                  to
                                                                  stderr
                                                                  and
                                                                  exits
                                                                  0.

       -WW
                                                                  dump                                                    writes
                                                                  an
                                                                  assem-
                                                                  bler
                                                                  like
                                                                  list-
                                                                  ing
                                                                  of
                                                                  the
                                                                  inter-
                                                                  nal
                                                                  rep-
                                                                  re-
                                                                  sen-
                                                                  ta-
                                                                  tion
                                                                  of
                                                                  the
                                                                  pro-
                                                                  gram
                                                                  to
                                                                  stderr.

       -WW
                                                                  sprintf=_n_u_m                                             adjusts
                                                                  the
                                                                  size
                                                                  of
                                                                  mmaawwkk''ss
                                                                  inter-
                                                                  nal
                                                                  sprintf
                                                                  buffer
                                                                  to
                                                                  _n_u_m
                                                                  bytes.
                                                                  More



22                             Jan                              3





MAWK(1)                        1992                       MAWK(1)


                                                                  than
                                                                  rare
                                                                  use
                                                                  of
                                                                  this
                                                                  option
                                                                  indi-
                                                                  cates
                                                                  mmaawwkk
                                                                  should
                                                                  be
                                                                  recom-
                                                                  piled.

       -WW
                                                                  posix_space                                             forces
                                                                  mmaawwkk
                                                                  not
                                                                  to
                                                                  con-
                                                                  sider
                                                                  '\n'
                                                                  to
                                                                  be
                                                                  space.


TTHHEE AAWWKK LLAANNGGUUAAGGEE
   11.. PPrrooggrraamm ssttrruuccttuurree
       An AWK program is a sequence of _p_a_t_t_e_r_n {_a_c_t_i_o_n} pairs and
       user function definitions.

       A pattern can be:
              BBEEGGIINN
              EENNDD
              expression
              expression , expression

       One, but not both, of _p_a_t_t_e_r_n  {_a_c_t_i_o_n}  can  be  omitted.
       If  {_a_c_t_i_o_n}  is  omitted  it is implicitly { print }.  If
       _p_a_t_t_e_r_n is omitted, then it is implicitly matched.   BBEEGGIINN
       and EENNDD patterns require an action.

       Statements  are  terminated  by  newlines,  semi-colons or
       both.  Groups of statements such as actions or loop bodies
       are  blocked via { ... } as in C.  The last statement in a
       block doesn't need a  terminator.   Blank  lines  have  no
       meaning;  an  empty  statement  is terminated with a semi-
       colon. Long statements can be continued with a  backslash,
       \.   A statement can be broken without a backslash after a
       comma, left brace, &&, ||, ddoo, eellssee, the right parenthesis
       of  an iiff, wwhhiillee or ffoorr statement, and the right parenthe-
       sis of a function definition.  A comment starts with # and
       extends to, but does not include the end of line.



22                             Jan                              4





MAWK(1)                        1992                       MAWK(1)


       The  following  statements  control  program  flow  inside
       blocks.

              iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t

              iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t eellssee _s_t_a_t_e_m_e_n_t

              wwhhiillee ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t

              ddoo _s_t_a_t_e_m_e_n_t wwhhiillee ( _e_x_p_r )

              ffoorr ( _o_p_t__e_x_p_r ; _o_p_t__e_x_p_r ; _o_p_t__e_x_p_r ) _s_t_a_t_e_m_e_n_t

              ffoorr ( _v_a_r iinn _a_r_r_a_y ) _s_t_a_t_e_m_e_n_t

              ccoonnttiinnuuee

              bbrreeaakk

   22.. DDaattaa ttyyppeess,, ccoonnvveerrssiioonn aanndd ccoommppaarriissoonn
       There are  two  basic  data  types,  numeric  and  string.
       Numeric  constants  can  be  integer like -2, decimal like
       1.08, or in scientific notation  like  -1.1e4  or  .28E-3.
       All  numbers  are  represented internally and all computa-
       tions are done in floating point arithmetic.  So for exam-
       ple, the expression 0.2e2 == 20 is true and true is repre-
       sented as 1.0.

       String constants are enclosed in double quotes.

            "This is a string with a newline at the end.\n"

       Strings can be continued across a line by escaping (\) the
       newline.  The following escape sequences are recognized.

            \\        \
            \"        "
            \a        alert, ascii 7
            \b        backspace, ascii 8
            \t        tab, ascii 9
            \n        newline, ascii 10
            \v        vertical tab, ascii 11
            \f        formfeed, ascii 12
            \r        carriage return, ascii 13
            \ddd      1, 2 or 3 octal digits for ascii ddd
            \xhh      1 or 2 hex digits for ascii  hh

       If  you  escape  any other character \c, you get \c, i.e.,
       mmaawwkk ignores the escape.

       There are really three basic data types; the third is _n_u_m-
       _b_e_r _a_n_d _s_t_r_i_n_g which has both a numeric value and a string
       value at the same time.  User defined variables come  into
       existence  when  first  referenced  and are initialized to



22                             Jan                              5





MAWK(1)                        1992                       MAWK(1)


       _n_u_l_l, a number and string value which has numeric value  0
       and  string value "".  Non-trivial number and string typed
       data come from input and are typically stored  in  fields.
       (See section 4).

       The type of an expression is determined by its context and
       automatic type conversion occurs if needed.  For  example,
       to evaluate the statements

            y = x + 2  ;  z = x  "hello"

       The  value stored in variable y will be typed numeric.  If
       x is not numeric, the value taken from x is  converted  to
       numeric  before  it  is  added  to 2 and stored in y.  The
       value stored in variable z will be typed string,  and  the
       value  of  x  will be converted to string if necessary and
       concatenated with "hello".  (Of course, the value and type
       stored  in x is not changed by any conversions.)  A string
       expression is  converted  to  numeric  using  its  longest
       numeric  prefix  as with _a_t_o_f(3).  A numeric expression is
       converted   to   string    by    replacing    _e_x_p_r    with
       sspprriinnttff((CCOONNVVFFMMTT,  _e_x_p_r), unless _e_x_p_r can be represented on
       the host machine as an exact integer then it is  converted
       to sspprriinnttff("%d", _e_x_p_r).  SSpprriinnttff(()) is an AWK built-in that
       duplicates the functionality of _s_p_r_i_n_t_f(3), and CCOONNVVFFMMTT is
       a built-in variable used for internal conversion from num-
       ber to string and initialized to  "%.6g".   Explicit  type
       conversions can be forced, _e_x_p_r "" is string and _e_x_p_r+0 is
       numeric.

       To evaluate, _e_x_p_r1 rreell--oopp  _e_x_p_r2,  if  both  operands  are
       numeric  or  number  and  string  then  the  comparison is
       numeric; if both operands are  string  the  comparison  is
       string.   If exactly one operand is string and after trim-
       ming spaces and tabs from the front and back the remaining
       string  is  entirely  numeric  in form, then the string is
       converted to number and the comparison is numeric;  other-
       wise,  the  numeric operand is converted to string and the
       comparison is string.   The  result  of  a  comparison  is
       numeric, 0 or 1.

       In  boolean  contexts  such  as,  iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t, a
       string expression evaluates true if and only if it is  not
       the  empty  string  "";  numeric values if and only if not
       numerically zero.

   33.. RReegguullaarr eexxpprreessssiioonnss
       In the AWK language, records, fields and strings are often
       tested for matching a _r_e_g_u_l_a_r _e_x_p_r_e_s_s_i_o_n.  Regular expres-
       sions are enclosed in slashes, and

            _e_x_p_r ~ /_r/

       is an AWK expression that evaluates to 1 if _e_x_p_r "matches"



22                             Jan                              6





MAWK(1)                        1992                       MAWK(1)


       _r,  which  means  a  substring  of  _e_x_p_r  is in the set of
       strings defined by _r.  With no match the expression evalu-
       ates to 0; replacing ~ with the "not match" operator, !~ ,
       reverses the meaning.  As  pattern-action pairs,

            /_r/ { _a_c_t_i_o_n }   and   $$00 ~ /_r/ { _a_c_t_i_o_n }

       are the same, and for each input record  that  matches  _r,
       _a_c_t_i_o_n  is  executed.   In  fact, /_r/ is an AWK expression
       that is equivalent to ($$00 ~ /_r/) anywhere except  when  on
       the  right  side of a match operator or passed as an argu-
       ment to a built-in function that expects a regular expres-
       sion argument.

       AWK  uses  extended  regular expressions as with _e_g_r_e_p(1).
       The regular expression metacharacters,  i.e.,  those  with
       special meaning in regular expressions are

             ^ $ . [ ] | ( ) * + ?

       Regular  expressions  are built up from characters as fol-
       lows:

              _c            matches any non-metacharacter _c.

              \_c           matches a  character  defined  by  the
                           same  escape  sequences used in string
                           constants or the literal  character  _c
                           if \_c is not an escape sequence.

              .            matches  any character (including new-
                           line).

              ^            matches the front of a string.

              $            matches the back of a string.

              [c1c2c3...]  matches any  character  in  the  class
                           c1c2c3... .  An interval of characters
                           is denoted c1-c2 inside a class [...].

              [^c1c2c3...] matches any character not in the class
                           c1c2c3...

       Regular  expressions  are  built  up  from  other  regular
       expressions as follows:

              _r1_r2   matches  _r1 followed immediately by _r2 (con-
                     catenation).

              _r1 | _r2
                     matches _r1 or _r2 (alternation).

              _r*     matches _r repeated zero or more times.



22                             Jan                              7





MAWK(1)                        1992                       MAWK(1)


              _r+     matches _r repeated one or more times.

              _r?     matches _r zero or once.

              (_r)    matches _r, providing grouping.

       The increasing precedence  of  operators  is  alternation,
       concatenation and unary (*, + or ?).

       For example,

            /^[_a-zA-Z][_a-zA-Z0-9]*$/  and
            /^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

       are  matched  by AWK identifiers and AWK numeric constants
       respectively.  Note that . has to be escaped to be  recog-
       nized  as a decimal point, and that metacharacters are not
       special inside character classes.

       Any expression can be used on the right hand side of the ~
       or  !~  operators  or  passed to a built-in that expects a
       regular expression.  If needed, it is converted to string,
       and  then  interpreted as a regular expression.  For exam-
       ple,

            BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }

            $0 ~ "^" identifier

       prints all lines that start with an AWK identifier.

       mmaawwkk recognizes the empty regular  expression,  //,  which
       matches  the  empty  string  and  hence  is matched by any
       string at the front, back  and  between  every  character.
       For example,

            echo  abc | mawk { gsub(//, "X") ; print }
            XaXbXcX


   44.. RReeccoorrddss aanndd ffiieellddss
       Records are read in one at a time, and stored in the _f_i_e_l_d
       variable $$00.  The record is split into  _f_i_e_l_d_s  which  are
       stored  in  $$11, $$22, ..., $$NNFF.  The built-in variable NNFF is
       set to the number of fields, and NNRR  and  FFNNRR  are  incre-
       mented by 1.  Fields above $$NNFF are set to "".

       Assignment  to  $$00  causes  the fields and NNFF to be recom-
       puted.  Assignment to NNFF or to a field  causes  $$00  to  be
       reconstructed  by concatenating the $$ii''ss separated by OOFFSS.
       Assignment  to  a  field  with  index  greater  than   NNFF,
       increases NNFF and causes $$00 to be reconstructed.

       Data  input  stored in fields is string, unless the entire



22                             Jan                              8





MAWK(1)                        1992                       MAWK(1)


       field has numeric form and then the  type  is  number  and
       string.  For example,

            echo 24 24E |
            mawk '{ print($1>100, $1>"100", $2>100, $2>"100") }'
            0 0 1 1

       $$00  and  $$22  are  string and $$11 is number and string.  The
       first and second comparisons are numeric and the last  two
       are  string.  In the second "100" is converted to 100, and
       in the third 100 is converted to "100".

   55.. EExxpprreessssiioonnss aanndd ooppeerraattoorrss
       The expression syntax is similar to  C.   Primary  expres-
       sions  are numeric constants, string constants, variables,
       fields, arrays and functions.  The identifier for a  vari-
       able, array or function can be a sequence of letters, dig-
       its and underscores, that does not  start  with  a  digit.
       Variables  are  not declared; they exist when first refer-
       enced and are initialized to _n_u_l_l.

       New expressions are composed with the following  operators
       in order of increasing precedence.

              _a_s_s_i_g_n_m_e_n_t          =  +=  -=  *=  /=  %=  ^=
              _c_o_n_d_i_t_i_o_n_a_l         ?  :
              _l_o_g_i_c_a_l _o_r          ||
              _l_o_g_i_c_a_l _a_n_d         &&
              _a_r_r_a_y _m_e_m_b_e_r_s_h_i_p    iinn
              _m_a_t_c_h_i_n_g       ~   !~
              _r_e_l_a_t_i_o_n_a_l          <  >   <=  >=  ==  !=
              _c_o_n_c_a_t_e_n_a_t_i_o_n       (no explicit operator)
              _a_d_d _o_p_s             +  -
              _m_u_l _o_p_s             *  /  %
              _u_n_a_r_y               +  -
              _l_o_g_i_c_a_l _n_o_t         !
              _e_x_p_o_n_e_n_t_i_a_t_i_o_n      ^
              _i_n_c _a_n_d _d_e_c         ++ -- (both post and pre)
              _f_i_e_l_d               $

       Assignment, conditional and exponentiation associate right
       to left; the other operators associate left to right.  Any
       expression can be parenthesized.

   66.. AArrrraayyss
       Awk  provides  one-dimensional arrays.  Array elements are
       expressed as _a_r_r_a_y[_e_x_p_r].  _E_x_p_r is internally converted to
       string type, so, for example, A[1] and A["1"] are the same
       element and the actual index is "1".   Arrays  indexed  by
       strings are called associative arrays.  Initially an array
       is empty; elements exist when first accessed.  An  expres-
       sion,  _e_x_p_r iinn _a_r_r_a_y evaluates to 1 if _a_r_r_a_y[_e_x_p_r] exists,
       else to 0.




22                             Jan                              9





MAWK(1)                        1992                       MAWK(1)


       There is a form of the ffoorr statement that loops over  each
       index of an array.

            ffoorr ( _v_a_r iinn _a_r_r_a_y ) _s_t_a_t_e_m_e_n_t

       sets  _v_a_r  to  each index of _a_r_r_a_y and executes _s_t_a_t_e_m_e_n_t.
       The order that _v_a_r transverses the indices of _a_r_r_a_y is not
       defined.

       The  statement, ddeelleettee _a_r_r_a_y[_e_x_p_r], causes _a_r_r_a_y[_e_x_p_r] not
       to exist.

       Multidimensional arrays are synthesized with concatenation
       using the built-in variable SSUUBBSSEEPP.  _a_r_r_a_y[_e_x_p_r1,_e_x_p_r2] is
       equivalent to _a_r_r_a_y[_e_x_p_r1 SSUUBBSSEEPP _e_x_p_r2].   Testing  for  a
       multidimensional  element uses a parenthesized index, such
       as

            if ( (i, j) in A )  print A[i, j]


   77.. BBuuiillttiinn--vvaarriiaabblleess
       The  following  variables  are  built-in  and  initialized
       before program execution.

              AARRGGCC      number of command line arguments.

              AARRGGVV      array    of   command   line   arguments,
                        0..ARGC-1.

              CCOONNVVFFMMTT   format for internal conversion of numbers
                        to string, initially = "%.6g".

              EENNVVIIRROONN   array  indexed  by environment variables.
                        An  environment  string,   _v_a_r=_v_a_l_u_e   is
                        stored as EENNVVIIRROONN[_v_a_r] = _v_a_l_u_e.

              FFIILLEENNAAMMEE  name of the current input file.

              FFNNRR       current record number in FFIILLEENNAAMMEE.

              FFSS        splits  records  into fields as a regular
                        expression.

              NNFF        number of fields in the current record.

              NNRR        current record number in the total  input
                        stream.

              OOFFMMTT      format  for printing numbers; initially =
                        "%.6g".

              OOFFSS       inserted between fields on  output,  ini-
                        tially = " ".



22                             Jan                             10





MAWK(1)                        1992                       MAWK(1)


              OORRSS       terminates  each  record  on output, ini-
                        tially = "\n".

              RRLLEENNGGTTHH   length set by the last call to the built-
                        in function, mmaattcchh(()).

              RRSS        input record separator, initially = "\n".

              RRSSTTAARRTT    index set by the last call to mmaattcchh(()).

              SSUUBBSSEEPP    used to build multiple array  subscripts,
                        initially = "\034".

   88.. BBuuiilltt--iinn ffuunnccttiioonnss
       String functions

              gsub(_r,_s,_t)  gsub(_r,_s)
                     Global  substitution, every match of regular
                     expression _r in variable _t  is  replaced  by
                     string  _s.   The  number  of replacements is
                     returned.  If _t is omitted, $$00 is used.   An
                     & in the replacement string _s is replaced by
                     the matched substring of _t.  \& puts a  lit-
                     eral & in the replacement string.

              index(_s,_t)
                     If  _t is a substring of _s, then the position
                     where  _t  starts  is  returned,  else  0  is
                     returned.   The  first  character of _s is in
                     position 1.

              length(_s)  length()
                     Returns the length of string _s;  without  an
                     argument, returns the length of $$00.

              match(_s,_r)
                     Returns the index of the first longest match
                     of  regular  expression  _r  in   string   _s.
                     Returns  0  if  no match.  As a side effect,
                     RRSSTTAARRTT is set to the return value.   RRLLEENNGGTTHH
                     is  set  to the length of the match or -1 if
                     no match.  If the empty string  is  matched,
                     RRLLEENNGGTTHH  is  set  to 0, and 1 is returned if
                     the match is at the front,  and  length(_s)+1
                     is returned if the match is at the back.

              split(_s,_A,_r)  split(_s,_A)
                     String  _s  is  split  into fields by regular
                     expression _r and the fields are loaded  into
                     array  _A.  The number of fields is returned.
                     See section 11 below for more detail.  If  _r
                     is omitted, FFSS is used.





22                             Jan                             11





MAWK(1)                        1992                       MAWK(1)


              sprintf(_f_o_r_m_a_t,_e_x_p_r-_l_i_s_t)
                     Returns  a string constructed from _e_x_p_r-_l_i_s_t
                     according to _f_o_r_m_a_t.  See the description of
                     printf() below.

              sub(_r,_s,_t)  sub(_r,_s)
                     Single  substitution,  same as gsub() except
                     at most one substitution.

              substr(_s,_i,_n)  substr(_s,_i)
                     Returns the substring of string _s,  starting
                     at  index  _i, of length _n.  If _n is omitted,
                     the suffix of _s, starting at _i is  returned.

              tolower(_s)
                     Returns  a  copy  of  _s  with all upper case
                     characters converted to lower case.

              toupper(_s)
                     Returns a copy of  _s  with  all  lower  case
                     characters converted to upper case.

       Arithmetic functions

              atan2(_y,_x)     Arctan of _y/_x between - and .

              cos(_x)         Cosine function, _x in radians.

              exp(_x)         Exponential function.

              int(_x)         Returns _x truncated towards zero.

              log(_x)         Natural logarithm.

              rand()         Returns a random number between zero and one.

              sin(_x)         Sine function, _x in radians.

              sqrt(_x)        Returns square root of _x.

              srand(_e_x_p_r)  srand()
                     Seeds the random number generator, using the
                     clock if _e_x_p_r is omitted,  and  returns  the
                     value  of the previous seed.  mmaawwkk seeds the
                     random number generator from  the  clock  at
                     startup  so  there  is  no real need to call
                     srand().  Srand(_e_x_p_r) is useful for  repeat-
                     ing pseudo random sequences.

   99.. IInnppuutt aanndd oouuttppuutt
       There are two output statements, pprriinntt and pprriinnttff.

              print  writes $$00  OORRSS to standard output.




22                             Jan                             12





MAWK(1)                        1992                       MAWK(1)


              print _e_x_p_r1, _e_x_p_r2, ..., _e_x_p_rn
                     writes  _e_x_p_r1 OOFFSS _e_x_p_r2 OOFFSS ... _e_x_p_rn OORRSS to
                     standard output.   Numeric  expressions  are
                     converted to string with OOFFMMTT.

              printf _f_o_r_m_a_t, _e_x_p_r-_l_i_s_t
                     duplicates  the  printf  C  library function
                     writing to standard  output.   The  complete
                     ANSI  C format specifications are recognized
                     with conversions %c, %d, %e, %E, %f, %g, %G,
                     %i,  %o,  %s, %u, %x, %X and %%, and conver-
                     sion qualifiers h and l.

       The argument list to print or  printf  can  optionally  be
       enclosed in parentheses.  Print formats numbers using OOFFMMTT
       or "%d" for exact integers.  "%c" with a numeric  argument
       prints  the  corresponding  8 bit character, with a string
       argument it prints the first character of the string.  The
       output  of print and printf can be redirected to a file or
       command by appending > _f_i_l_e, >> _f_i_l_e or | _c_o_m_m_a_n_d  to  the
       end  of  the  print  statement.  Redirection opens _f_i_l_e or
       _c_o_m_m_a_n_d only once, subsequent redirections append  to  the
       already  open  stream.  By convention, mmaawwkk associates the
       filename "/dev/stderr" with stderr which allows print  and
       printf to be redirected to stderr.

       The input function ggeettlliinnee has the following variations.

              getline
                     reads  into  $$00,  updates the fields, NNFF, NNRR
                     and FFNNRR.

              getline < _f_i_l_e
                     reads into $$00 from _f_i_l_e, updates the  fields
                     and NNFF.

              getline _v_a_r
                     reads  the  next record into _v_a_r, updates NNRR
                     and FFNNRR.

              getline _v_a_r < _f_i_l_e
                     reads the next record of _f_i_l_e into _v_a_r.

               _c_o_m_m_a_n_d | getline
                     pipes a record  from  _c_o_m_m_a_n_d  into  $$00  and
                     updates the fields and NNFF.

               _c_o_m_m_a_n_d | getline _v_a_r
                     pipes a record from _c_o_m_m_a_n_d into _v_a_r.

       Getline  returns  0 on end-of-file, -1 on error, otherwise
       1.

       Commands on the end of pipes are executed by /bin/sh.



22                             Jan                             13





MAWK(1)                        1992                       MAWK(1)


       The function cclloossee(_e_x_p_r) closes the file or  pipe  associ-
       ated  with _e_x_p_r.  Close returns 0 if _e_x_p_r is an open file,
       the exit status if _e_x_p_r is a piped command, and -1  other-
       wise.   Close()  is used to reread a file or command, make
       sure the other end of an output pipe is finished  or  con-
       serve file resources.

       The function ssyysstteemm(_e_x_p_r) uses /bin/sh to execute _e_x_p_r and
       returns the exit status of the command _e_x_p_r.  Changes made
       to  the  EENNVVIIRROONN array are not passed to commands executed
       with ssyysstteemm or pipes.

   1100.. UUsseerr ddeeffiinneedd ffuunnccttiioonnss
       The syntax for a user defined function is

            ffuunnccttiioonn name( _a_r_g_s ) { _s_t_a_t_e_m_e_n_t_s }

       The function body can contain a return statement

            rreettuurrnn _o_p_t__e_x_p_r

       A return statement is not required.  Function calls may be
       nested  or recursive.  Functions are passed expressions by
       value and arrays by reference.  Extra arguments  serve  as
       local variables and are initialized to _n_u_l_l.  For example,
       csplit(_s,_A) puts each character of  _s  into  array  _A  and
       returns the length of _s.

            function csplit(s, A,    n, i)
            {
              n = length(s)
              for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
              return n
            }

       Putting  extra  space  between  passed arguments and local
       variables is conventional.  Functions  can  be  referenced
       before they are defined, but the function name and the '('
       of the arguments must touch to avoid confusion  with  con-
       catenation.

   1111.. SSpplliittttiinngg ssttrriinnggss,, rreeccoorrddss aanndd ffiilleess
       Awk  programs use the same algorithm to split strings into
       arrays with split(), and records into fields on FFSS.   mmaawwkk
       uses  essentially  the  same algorithm to split files into
       records on RRSS.

       Split(_e_x_p_r,_A,_s_e_p) works as follows:

              (1)    If _s_e_p is omitted, it  is  replaced  by  FFSS.
                     _S_e_p  can be an expression or regular expres-
                     sion.  If it is an expression of  non-string
                     type, it is converted to string.




22                             Jan                             14





MAWK(1)                        1992                       MAWK(1)


              (2)    If  _s_e_p = " " (a single space), then <SPACE>
                     is trimmed from the front and back of  _e_x_p_r,
                     and   _s_e_p  becomes  <SPACE>.   mmaawwkk  defines
                     <SPACE>   as    the    regular    expression
                     /[ \t\n]+/.   Otherwise  _s_e_p is treated as a
                     regular  expression,   except   that   meta-
                     characters  are  ignored  for  a  string  of
                     length  1,  e.g.,  split(x,  A,   "*")   and
                     split(x, A, /\*/) are the same.

              (3)    If  _e_x_p_r  is  not string, it is converted to
                     string.  If _e_x_p_r is then  the  empty  string
                     "",  split()  returns  0 and _A is unchanged.
                     Otherwise, all non-overlapping, non-null and
                     longest  matches  of  _s_e_p  in _e_x_p_r, separate
                     _e_x_p_r into fields which are  loaded  into  _A.
                     The  fields  are  placed in A[1], A[2], ...,
                     A[n] and split() returns n,  the  number  of
                     fields  which  is the number of matches plus
                     one.  Data placed in _A that looks numeric is
                     typed number and string.

       Splitting  records  into  fields works the same except the
       pieces are loaded into $$11, $$22,..., $$NNFF.  If $$00  is  empty,
       NNFF is set to 0 and all $$ii to "".

       mmaawwkk  splits files into records by the same algorithm, but
       with the slight difference that RRSS is really a  terminator
       instead of a separator.  (OORRSS is really a terminator too).

              E.g., if FFSS = ":+" and $$00 = "a::b:" , then NNFF  =  3
              and  $$11 = "a", $$22 = "b" and $$33 = "", but if "a::b:"
              is the contents of an input file  and  RRSS  =  ":+",
              then there are two records "a" and "b".

       RRSS = " " is not special.

   1122.. MMuullttii--lliinnee rreeccoorrddss
       Since  mmaawwkk  interprets RRSS as a regular expression, multi-
       line records are easy.  Setting RRSS = "\n\n+", makes one or
       more  blank  lines  separate  records.   If  FFSS = " " (the
       default), then single newlines, by the rules  for  <SPACE>
       above,  become space and single newlines are field separa-
       tors.

              For example,  if  a  file  is  "a b\nc\n\n",  RRSS  =
              "\n\n+"  and  FFSS  =  " ",  then there is one record
              "a b\nc"  with  three  fields  "a",  "b"  and  "c".
              Changing FFSS = "\n", gives two fields "a b" and "c";
              changing FFSS = "", gives one field identical to  the
              record.

       If  you  want  lines  with spaces or tabs to be considered
       blank, set RRSS = "\n([ \t]*\n)+".  For  compatibility  with



22                             Jan                             15





MAWK(1)                        1992                       MAWK(1)


       other  awks,  setting  RRSS  =  "" has the same effect as if
       blank lines are stripped from the front and back of  files
       and then records are determined as if RRSS = "\n\n+".  Posix
       requires that "\n" always separates records when RRSS  =  ""
       regardless of the value of FFSS.  mmaawwkk does not support this
       convention, because defining  "\n"  as  <SPACE>  makes  it
       unnecessary.

       Most  of  the  time  when  you  change  RRSS  for multi-line
       records, you will also want to change OORRSS to "\n\n" so the
       record spacing is preserved on output.

   1133.. PPrrooggrraamm eexxeeccuuttiioonn
       This  section  describes  the  order of program execution.
       First AARRGGCC is set to the  total  number  of  command  line
       arguments  passed  to  the execution phase of the program.
       AARRGGVV[[00]] is set the name of the AWK interpreter and AARRGGVV[[11]]
       ...   AARRGGVV[[AARRGGCC--11]]  holds the remaining command line argu-
       ments exclusive of options and program source.  For  exam-
       ple with

            mawk  -f  prog  v=1  A  t=hello  B

       AARRGGCC = 5 with AARRGGVV[[00]] = "mawk", AARRGGVV[[11]] = "v=1", AARRGGVV[[22]] =
       "A", AARRGGVV[[33]] = "t=hello" and AARRGGVV[[44]] = "B".

       Next, each BBEEGGIINN block is executed in order.  If the  pro-
       gram  consists  entirely  of  BBEEGGIINN blocks, then execution
       terminates, else an input stream is opened  and  execution
       continues.   If  AARRGGCC equals 1, the input stream is set to
       stdin,  else   the  command  line  arguments  AARRGGVV[[11]]  ...
       AARRGGVV[[AARRGGCC--11]] are examined for a file argument.

       The  command  line  arguments divide into three sets: file
       arguments, assignment arguments and empty strings "".   An
       assignment  has  the  form _v_a_r=_s_t_r_i_n_g.  When an AARRGGVV[[ii]] is
       examined as a possible file argument, if it is empty it is
       skipped;  if  it is an assignment argument, the assignment
       to _v_a_r takes place and ii skips to the next argument;  else
       AARRGGVV[[ii]]  is opened for input.  If it fails to open, execu-
       tion terminates with exit code  1.   If  no  command  line
       argument  is a file argument, then input comes from stdin.
       Getline in a BBEEGGIINN action opens  input.   "-"  as  a  file
       argument denotes stdin.

       Once  an input stream is open, each input record is tested
       against each _p_a_t_t_e_r_n, and if it  matches,  the  associated
       _a_c_t_i_o_n  is  executed.  An expression pattern matches if it
       is boolean true (see the end of section 2).  A BBEEGGIINN  pat-
       tern  matches  before  any input has been read, and an EENNDD
       pattern matches after all input has been  read.   A  range
       pattern,  _e_x_p_r1,_e_x_p_r2  ,  matches every record between the
       match of _e_x_p_r1 and the match _e_x_p_r2 inclusively.




22                             Jan                             16





MAWK(1)                        1992                       MAWK(1)


       When end of file occurs on the input stream, the remaining
       command  line  arguments are examined for a file argument,
       and if there is one it is opened, else the EENNDD _p_a_t_t_e_r_n  is
       considered matched and all EENNDD _a_c_t_i_o_n_s are executed.

       In  the  example, the assignment v=1 takes place after the
       BBEEGGIINN _a_c_t_i_o_n_s are executed, and the data placed  in  v  is
       typed  number and string.  Input is then read from file A.
       On end of file A, t is set to the string "hello", and B is
       opened  for  input.  On end of file B, the EENNDD _a_c_t_i_o_n_s are
       executed.

       Program flow at the _p_a_t_t_e_r_n {_a_c_t_i_o_n} level can be  changed
       with the

            nneexxtt   and
            eexxiitt  _o_p_t__e_x_p_r

       statements.  A nneexxtt statement causes the next input record
       to be read and pattern testing to restart with  the  first
       _p_a_t_t_e_r_n  {_a_c_t_i_o_n}  pair in the program.  An eexxiitt statement
       causes immediate execution of the EENNDD actions  or  program
       termination  if there are none or if the eexxiitt occurs in an
       EENNDD action.  The _o_p_t__e_x_p_r sets the exit value of the  pro-
       gram  unless  overridden  by  a  later  eexxiitt or subsequent
       error.


EEXXAAMMPPLLEESS
       1. emulate cat.

            { print }

       2. emulate wc.

            { chars += length($0) + 1  # add one for the \n
              words += NF
            }

            END{ print NR, words, chars }

       3. count the number of unique "real words".

            BEGIN { FS = "[^A-Za-z]+" }

            { for(i = 1 ; i <= NF ; i++)  word[$i] = "" }

            END { delete word[""]
                  for ( i in word )  cnt++
                  print cnt
            }

       4. sum the second field of every record based on the first
       field.



22                             Jan                             17





MAWK(1)                        1992                       MAWK(1)


            $1 ~ /credit|gain/ { sum += $2 }
            $1 ~ /debit|loss/  { sum -= $2 }

            END { print sum }

       5. sort a file, comparing as string

            { line[NR] = $0 "" }  # make sure of comparison type
                            # in case some lines look numeric

            END {  isort(line, NR)
              for(i = 1 ; i <= NR ; i++) print line[i]
            }

            #insertion sort of A[1..n]
            function isort( A, n,    i, j, hold)
            {
              for( i = 2 ; i <= n ; i++)
              {
                hold = A[j = i]
                while ( A[j-1] > hold )
                { j-- ; A[j+1] = A[j] }
                A[j] = hold
              }
              # sentinel A[0] = "" will be created if needed
            }



CCOOMMPPAATTIIBBIILLIITTYY IISSSSUUEESS
       The  Posix  1003.2(draft  11.2) definition of the AWK lan-
       guage is AWK as described in  the  AWK  book  with  a  few
       extensions that appeared in SystemVR4 nawk. The extensions
       are:

              New functions: toupper() and tolower().

              New variables: ENVIRON[] and CONVFMT.

              ANSI C conversion specifications for  printf()  and
              sprintf().

              New  command  options:   -v  var=value, multiple -f
              options and implementation options as arguments  to
              -W.

       Posix  AWK  is  oriented  to  operate on files a line at a
       time.  RRSS can be changed from "\n" to another single char-
       acter, but it is hard to find any use for this - there are
       no examples in the AWK book.   By  convention,  RRSS  =  "",
       makes  one  or more blank lines separate records, allowing
       multi-line records.  When RRSS = "", "\n" is always a  field
       separator regardless of the value in FFSS.




22                             Jan                             18





MAWK(1)                        1992                       MAWK(1)


       mmaawwkk, on the other hand, allows RRSS to be a regular expres-
       sion.  When "\n" appears in  records,  it  is  treated  as
       space, and FFSS always determines fields.

       Removing  the  line  at a time paradigm can make some pro-
       grams simpler and  can  often  improve  performance.   For
       example, redoing example 3 from above,

            BEGIN { RS = "[^A-Za-z]+" }

            { word[ $0 ] = "" }

            END { delete  word[ "" ]
              for( i in word )  cnt++
              print cnt
            }

       counts  the  number  of unique words by making each word a
       record.  On moderate size files, mmaawwkk  executes  twice  as
       fast, because of the simplified inner loop.

       The  following  program  replaces each comment by a single
       space in a C program file,

            BEGIN {
              RS = "/\*([^*]|\*+[^/*])*\*+/"
                 # comment is record separator
              ORS = " "
              getline  hold
              }

              { print hold ; hold = $0 }

              END { printf "%s" , hold }

       Buffering one record is needed to  avoid  terminating  the
       last record with a space.

       With mmaawwkk, the following are all equivalent,

            x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

       The  strings get scanned twice, once as string and once as
       regular expression.  On the string scan, mmaawwkk ignores  the
       escape  on  non-escape characters while the AWK book advo-
       cates \_c be recognized as _c which necessitates the  double
       escaping  of meta-characters in strings.  Posix explicitly
       declines to define the  behavior  which  passively  forces
       programs  that must run under a variety of awks to use the
       more portable but less readable, double escape.

       Posix AWK does  not  recognize  "/dev/stderr"  or  \x  hex
       escape  sequences  in strings.  Unlike ANSI C, mmaawwkk limits
       the number of digits that follows \x to two.



22                             Jan                             19





MAWK(1)                        1992                       MAWK(1)


       Finally, here is how mmaawwkk handles  exceptional  cases  not
       discussed  in  the  AWK  book  or  the Posix draft.  It is
       unsafe to assume consistency across awks and safe to  skip
       to the next section.

              substr(s,  i, n) returns the characters of s in the
              intersection of the closed interval [1,  length(s)]
              and  the  half-open  interval  [i, i+n).  When this
              intersection  is  empty,  the   empty   string   is
              returned;  so  substr("ABC",  1,  0)  = "" and sub-
              str("ABC", -4, 6) = "A".

              Every string, including the empty  string,  matches
              the  empty  string  at the front so, s ~ // and s ~
              "", are always 1 as is match(s,  //)  and  match(s,
              "").  The last two set RRLLEENNGGTTHH to 0.

              index(s,  t)  is  always  the  same as match(s, t1)
              where t1 is  the  same  as  t  with  metacharacters
              escaped.   Hence  consistency  with  match requires
              that index(s, "") always returns 1.  Also the  con-
              dition,  index(s,t)  !=  0  if and only t is a sub-
              string of s, requires index("","") = 1.

              If getline encounters end  of  file,  getline  var,
              leaves  var  unchanged.  Similarly, on entry to the
              EENNDD actions, $$00, the fields and NNFF have their value
              unaltered from the last record.


SSEEEE AALLSSOO
       _e_g_r_e_p (1)

       Aho,  Kernighan  and  Weinberger, _T_h_e _A_W_K _P_r_o_g_r_a_m_m_i_n_g _L_a_n-
       _g_u_a_g_e, Addison-Wesley Publishing, 1988,  (the  AWK  book),
       defines  the language, opening with a tutorial and advanc-
       ing to many interesting programs that delve into issues of
       software  design  and  analysis relevant to programming in
       any language.

       _T_h_e _G_A_W_K _M_a_n_u_a_l, The Free Software Foundation, 1991, is  a
       tutorial  and language reference that does not attempt the
       depth of the AWK book and assumes  the  reader  may  be  a
       novice  programmer.   The  section on AWK arrays is excel-
       lent.  It also discusses Posix requirements for AWK.



BBUUGGSS
       mmaawwkk cannot handle ascii NUL \0  in  the  source  or  data
       files.   You  can output NUL using printf with %c, and any
       other 8 bit character is acceptable input.

       mmaawwkk implements printf() and sprintf() using the C library



22                             Jan                             20





MAWK(1)                        1992                       MAWK(1)


       functions,  printf and sprintf, so full ANSI compatibility
       requires an ANSI C library.  In practice this means the  h
       conversion  qualifier  may  not  be  available.  Also mmaawwkk
       inherits any bugs or limitations of the library functions.

       Implementors  of  the AWK language have shown a consistent
       lack of imagination when naming their programs.


AAUUTTHHOORR
       Mike Brennan (brennan@boeing.com).














































22                             Jan                             21


