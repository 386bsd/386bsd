


TCPDUMP(1)                     1989                    TCPDUMP(1)


NNAAMMEE
       tcpdump - dump traffic on a network

SSYYNNOOPPSSIISS
       ttccppdduummpp [ --ddeeffllnnNNOOppqqSSttvvxx ] [ --cc _c_o_u_n_t ] [ --FF _f_i_l_e ]
               [ --ii _i_n_t_e_r_f_a_c_e ] [ --rr _f_i_l_e ] [ --ss _s_n_a_p_l_e_n ]
               [ --ww _f_i_l_e ] _e_x_p_r_e_s_s_i_o_n

DDEESSCCRRIIPPTTIIOONN
       _T_c_p_d_u_m_p  prints  out  the  headers of packets on a network
       interface that match the boolean _e_x_p_r_e_s_s_i_o_n.  UUnnddeerr SSuunnOOSS::
       You must be root to invoke _t_c_p_d_u_m_p or it must be installed
       setuid to root.  UUnnddeerr UUllttrriixx:: Any user can invoke _t_c_p_d_u_m_p
       once the super-user has enabled promiscuous-mode operation
       using _p_f_c_o_n_f_i_g(8).  UUnnddeerr BBSSDD:: Access is controlled by the
       permissions on /_d_e_v/_b_p_f_0, etc.

OOPPTTIIOONNSS
       --cc     Exit after receiving _c_o_u_n_t packets.

       --dd     Dump  the compiled packet-matching code to standard
              output and stop.

       --ee     Print the link-level header on each dump line.

       --ff     Print  `foreign'  internet  addresses   numerically
              rather  than  symbolically (this option is intended
              to get around serious  brain  damage  in  Sun's  yp
              server  - usually it hangs forever translating non-
              local internet numbers).

       --FF     Use _f_i_l_e as input for the  filter  expression.   An
              additional  expression given on the command line is
              ignored.

       --ii     Listen  on  _i_n_t_e_r_f_a_c_e.   If  unspecified,   _t_c_p_d_u_m_p
              searches  the  system interface list for the lowest
              numbered,  configured   up   interface   (excluding
              loopback).    Ties   are  broken  by  choosing  the
              earliest match.

       --ll     Make stdout line buffered.  Useful if you  want  to
              see the data while capturing it.  E.g.,
              ``tcpdump  -l  |  tee  dat''  or  ``tcpdump  -l   >
              dat  &  tail  -f  dat''.

       --nn     Don't convert addresses (i.e., host addresses, port
              numbers, etc.) to names.

       --NN     Don't  print  domain  name  qualification  of  host
              names.  E.g., if you give this  flag  then  _t_c_p_d_u_m_p
              will print ``nic'' instead of ``nic.ddn.mil''.

       --OO     Do  not  run  the  packet-matching  code optimizer.



Jun                             25                              1





TCPDUMP(1)                     1989                    TCPDUMP(1)


              This is useful only if you suspect  a  bug  in  the
              optimizer.

       --pp     _D_o_n'_t  put  the  interface  into  promiscuous mode.
              Note that the interface might be in promiscuous for
              some other reason; hence, `-p' cannot be used as an
              abbreviation  for  `ether   host   {localhost}   or
              broadcast'.

       --qq     Quick   (quiet?)   output.    Print  less  protocol
              information so output lines are shorter.

       --rr     Read packets from _f_i_l_e (which was created with  the
              -w  option).   Standard  input  is  used if _f_i_l_e is
              ``-''.

       --ss     Snarf _s_n_a_p_l_e_n bytes of data from each packet rather
              than  the  default  of 68 (with NIT, the minimum is
              actually 96).  68 bytes is adequate for  IP,  ICMP,
              TCP  and  UDP but may truncate protocol information
              from name  server  and  NFS  packets  (see  below).
              Packets truncated because of a limited snapshot are
              indicated in the output  with  ``[|_p_r_o_t_o]'',  where
              _p_r_o_t_o  is  the  name of the protocol level at which
              the  truncation  has  occured.   Note  that  taking
              larger  snapshots both increases the amount of time
              it  takes  to  process  packets  and,  effectively,
              decreases the amount of packet buffering.  This may
              cause packets to be lost.  You should limit _s_n_a_p_l_e_n
              to  the  smallest  number  that  will  capture  the
              protocol information you're interested in.

       --SS     Print absolute, rather than relative, TCP  sequence
              numbers.

       --tt     _D_o_n'_t print a timestamp on each dump line.

       --tttt    Print an unformatted timestamp on each dump line.

       --vv     (Slightly  more)  verbose output.  For example, the
              time to live and type of service information in  an
              IP packet is printed.

       --ww     Write  the  raw packets to _f_i_l_e rather than parsing
              and printing them out.  They can later  be  printed
              with  the  -r  option.   Standard output is used if
              _f_i_l_e is ``-''.

       --xx     Print each packet (minus its link level header)  in
              hex.   The  smaller of the entire packet or _s_n_a_p_l_e_n
              bytes will be printed.

        _e_x_p_r_e_s_s_i_o_n
              selects  which  packets  will  be  dumped.   If  no



Jun                             25                              2





TCPDUMP(1)                     1989                    TCPDUMP(1)


              _e_x_p_r_e_s_s_i_o_n is given, all packets on the net will be
              dumped.   Otherwise,   only   packets   for   which
              _e_x_p_r_e_s_s_i_o_n is `true' will be dumped.

              The  _e_x_p_r_e_s_s_i_o_n consists of one or more _p_r_i_m_i_t_i_v_e_s.
              Primitives  usually  consist  of  an  _i_d  (name  or
              number)  preceded by one or more qualifiers.  There
              are three different kinds of qualifier:

              _t_y_p_e   qualifiers say what kind  of  thing  the  id
                     name  or  number  refers to.  Possible types
                     are hhoosstt, nneett and ppoorrtt.  E.g.,  `host  foo',
                     `net 128.3', `port 20'.  If there is no type
                     qualifier, hhoosstt is assumed.

              _d_i_r    qualifiers  specify  a  particular   tranfer
                     direction   to  and/or  from  _i_d.   Possible
                     directions are ssrrcc, ddsstt, ssrrcc oorr ddsstt and  ssrrcc
                     aanndd  ddsstt.  E.g., `src foo', `dst net 128.3',
                     `src or dst port ftp-data'.  If there is  no
                     dir qualifier, ssrrcc oorr ddsstt is assumed.

              _p_r_o_t_o  qualifiers   restrict   the   match   to   a
                     particular protocol.  Possible  protos  are:
                     eetthheerr,  iipp,  aarrpp,  rraarrpp, ttccpp and uuddpp.  E.g.,
                     `ether src foo', `arp net 128.3', `tcp  port
                     21'.   If  there  is no proto qualifier, all
                     protocols  consistent  with  the  type   are
                     assumed.   E.g., `src foo' means `(ip or arp
                     or rarp) src foo' (except the latter is  not
                     legal  syntax),  `net bar' means `(ip or arp
                     or rarp) net bar' and `port 53' means  `(tcp
                     or udp) port 53'.

              In  addition  to  the above, there are some special
              `primitive' keywords that don't follow the pattern:
              ggaatteewwaayy,  bbrrooaaddccaasstt,  lleessss,  ggrreeaatteerr and arithmetic
              expressions.  All of these are described below.

              More complex filter expressions  are  built  up  by
              using   the  words  aanndd,  oorr  and  nnoott  to  combine
              primitives.  E.g., `host foo and not port  ftp  and
              not  port  ftp-data'.   To  save  typing, identical
              qualifier lists can be  omitted.   E.g.,  `tcp  dst
              port ftp or ftp-data or domain' is exactly the same
              as `tcp dst port ftp or tcp dst  port  ftp-data  or
              tcp dst port domain'.

              Allowable primitives are:

              ddsstt hhoosstt _h_o_s_t
                     True  if  the  IP  destination  field of the
                     packet is  _h_o_s_t,  which  may  be  either  an
                     address or a name.



Jun                             25                              3





TCPDUMP(1)                     1989                    TCPDUMP(1)


              ssrrcc hhoosstt _h_o_s_t
                     True if the IP source field of the packet is
                     _h_o_s_t.

              hhoosstt _h_o_s_t
                     True if either the IP source or  destination
                     of  the  packet  is  _h_o_s_t.  Any of the above
                     host expressions can be prepended  with  the
                     keywords, iipp, aarrpp, or rraarrpp as in:
                          iipp hhoosstt _h_o_s_t
                     which is equivalent to:
                          eetthheerr pprroottoo \_i_p aanndd hhoosstt _h_o_s_t
                     If   _h_o_s_t   is   a  name  with  multiple  IP
                     addresses, each address will be checked  for
                     a match.

              eetthheerr ddsstt _e_h_o_s_t
                     True  if the ethernet destination address is
                     _e_h_o_s_t.  _E_h_o_s_t may  be  either  a  name  from
                     /etc/ethers  or a number (see _e_t_h_e_r_s(3N) for
                     numeric format).

              eetthheerr ssrrcc _e_h_o_s_t
                     True  if  the  ethernet  source  address  is
                     _e_h_o_s_t.

              eetthheerr hhoosstt _e_h_o_s_t
                     True   if  either  the  ethernet  source  or
                     destination address is _e_h_o_s_t.

              ggaatteewwaayy _h_o_s_t
                     True if the packet used _h_o_s_t as  a  gateway.
                     I.e.,  the  ethernet  source  or destination
                     address was _h_o_s_t but neither the  IP  source
                     nor  the IP destination was _h_o_s_t.  _H_o_s_t must
                     be  a  name  and  must  be  found  in   both
                     /etc/hosts  and /etc/ethers.  (An equivalent
                     expression is
                          eetthheerr hhoosstt _e_h_o_s_t aanndd nnoott hhoosstt _h_o_s_t
                     which can  be  used  with  either  names  or
                     numbers for _h_o_s_t / _e_h_o_s_t.)

              ddsstt nneett _n_e_t
                     True  if  the  IP destination address of the
                     packet has a network number  of  _n_e_t,  which
                     may be either an address or a name.

              ssrrcc nneett _n_e_t
                     True  if the IP source address of the packet
                     has a network number of _n_e_t.

              nneett _n_e_t
                     True if either the IP source or  destination
                     address  of  the packet has a network number



Jun                             25                              4





TCPDUMP(1)                     1989                    TCPDUMP(1)


                     of _n_e_t.

              ddsstt ppoorrtt _p_o_r_t
                     True if the packet is ip/tcp or  ip/udp  and
                     has  a  destination port value of _p_o_r_t.  The
                     _p_o_r_t can be a  number  or  a  name  used  in
                     /etc/services (see _t_c_p(4P) and _u_d_p(4P)).  If
                     a name is used, both  the  port  number  and
                     protocol   are  checked.   If  a  number  or
                     ambiguous name is used, only the port number
                     is  checked  (e.g.,  ddsstt ppoorrtt 551133 will print
                     both tcp/login traffic and udp/who  traffic,
                     and  ppoorrtt  ddoommaaiinn will print both tcp/domain
                     and udp/domain traffic).

              ssrrcc ppoorrtt _p_o_r_t
                     True if the packet has a source  port  value
                     of _p_o_r_t.

              ppoorrtt _p_o_r_t
                     True  if  either  the  source or destination
                     port of the packet  is  _p_o_r_t.   Any  of  the
                     above port expressions can be prepended with
                     the keywords, ttccpp or uuddpp, as in:
                          ttccpp ssrrcc ppoorrtt _p_o_r_t
                     which matches only tcp packets.

              lleessss _l_e_n_g_t_h
                     True if the packet has a length less than or
                     equal to _l_e_n_g_t_h.  This is equivalent to:
                          lleenn <<== _l_e_n_g_t_h..

              ggrreeaatteerr _l_e_n_g_t_h
                     True if the packet has a length greater than
                     or equal to _l_e_n_g_t_h.  This is equivalent to:
                          lleenn >>== _l_e_n_g_t_h..

              iipp pprroottoo _p_r_o_t_o_c_o_l
                     True if the packet  is  an  ip  packet  (see
                     _i_p(4P)) of protocol type _p_r_o_t_o_c_o_l.  _P_r_o_t_o_c_o_l
                     can be a number or one of  the  names  _i_c_m_p,
                     _u_d_p,  _n_d, or _t_c_p.  Note that the identifiers
                     _t_c_p, _u_d_p, and _i_c_m_p  are  also  keywords  and
                     must  be escaped via backslash (\), which is
                     \\ in the C-shell.

              bbrrooaaddccaasstt
                     True if the packet is a broadcast packet.

              eetthheerr pprroottoo _p_r_o_t_o_c_o_l
                     True  if  the  packet  is  of   ether   type
                     _p_r_o_t_o_c_o_l.   _P_r_o_t_o_c_o_l  can  be  a number or a
                     name like _i_p,  _a_r_p,  or  _r_a_r_p.   Note  these
                     identifiers  are  also  keywords and must be



Jun                             25                              5





TCPDUMP(1)                     1989                    TCPDUMP(1)


                     escaped via backslash (\).

              iipp, aarrpp, rraarrpp
                     Abbreviations for:
                          eetthheerr pprroottoo _p
                     where _p is one of the above protocols.

              ttccpp, uuddpp, iiccmmpp
                     Abbreviations for:
                          iipp pprroottoo _p
                     where _p is one of the above protocols.

              _e_x_p_r _r_e_l_o_p _e_x_p_r
                     True if the relation holds, where  _r_e_l_o_p  is
                     one  of  >, <, >=, <=, =, !=, and _e_x_p_r is an
                     arithmetic expression  composed  of  integer
                     constants  (expressed in standard C syntax),
                     the normal binary operators [+, -, *, /,  &,
                     |],  a  length  operator, and special packet
                     data accessors.  To access data  inside  the
                     packet, use the following syntax:
                          _p_r_o_t_o [[ _e_x_p_r :: _s_i_z_e ]]
                     _P_r_o_t_o  is  one of eetthheerr,, iipp,, aarrpp,, rraarrpp,, ttccpp,,
                     uuddpp,, or iiccmmpp,  and  indicates  the  protocol
                     layer  for  the  index  operation.  The byte
                     offset, relative to the  indicated  protocol
                     layer,  is  given by _e_x_p_r.  _S_i_z_e is optional
                     and indicates the number  of  bytes  in  the
                     field  of  interest;  it  can be either one,
                     two, or four,  and  defaults  to  one.   The
                     length  operator,  indicated  by the keyword
                     lleenn, gives the length of the packet.

                     For example, `eetthheerr[[00]] && 11 !!== 00' catches all
                     multicast  traffic.  The expression `iipp[[00]] &&
                     00xxff  !!==  55'  catches  all  IP  packets  with
                     options.  The expression `iipp[[22::22]] && 00xx11ffffff ==
                     00' catches only unfragmented  datagrams  and
                     frag  zero  of  fragmented  datagrams.  This
                     check is implicitly applied to the  ttccpp  and
                     uuddpp index opertations.  For instance, ttccpp[[00]]
                     always means  the  first  byte  of  the  TCP
                     _h_e_a_d_e_r, and never means the first byte of an
                     intervening fragment.

              Primitives may be combined using:

                     A  parenthesized  group  of  primitives  and
                     operators  (parentheses  are  special to the
                     Shell and must be escaped).

                     Negation (`!!' or `nnoott').

                     Concatenation (`aanndd').



Jun                             25                              6





TCPDUMP(1)                     1989                    TCPDUMP(1)


                     Alternation (`oorr').

              Negation has highest precedence.   Alternation  and
              concatenation  have  equal precedence and associate
              left to right.  Note that explicit aanndd tokens,  not
              juxtaposition,  are now required for concatenation.

              If an identifier is given without  a  keyword,  the
              most recent keyword is assumed.  For example,
                   nnoott hhoosstt vvss aanndd aaccee
              is short for
                   nnoott hhoosstt vvss aanndd hhoosstt aaccee
              which should not be confused with
                   nnoott (( hhoosstt vvss oorr aaccee ))

              Expression  arguments  can  be passed to tcpdump as
              either a single argument or as multiple  arguments,
              whichever  is  more  convenient.  Generally, if the
              expression contains  Shell  metacharacters,  it  is
              easier  to  pass  it  as a single, quoted argument.
              Multiple arguments  are  concatenated  with  spaces
              before being parsed.

EEXXAAMMPPLLEESS
       To  print  all  packets  arriving  at  or  departing  from
       _s_u_n_d_o_w_n:
              ttccppdduummpp hhoosstt ssuunnddoowwnn

       To print traffic between _h_e_l_i_o_s and either _h_o_t or _a_c_e:
              ttccppdduummpp hhoosstt hheelliiooss aanndd \\(( hhoott oorr aaccee \\))

       To print all IP packets between _a_c_e and  any  host  except
       _h_e_l_i_o_s:
              ttccppdduummpp iipp hhoosstt aaccee aanndd nnoott hheelliiooss

       To  print  all  traffic  between  local hosts and hosts at
       Berkeley:
              ttccppdduummpp nneett uuccbb--eetthheerr

       To print all ftp traffic through  internet  gateway  _s_n_u_p:
       (note  that  the expression is quoted to prevent the shell
       from (mis-)interpreting the parentheses):
              ttccppdduummpp ''ggaatteewwaayy ssnnuupp aanndd ((ppoorrtt ffttpp oorr ffttpp--ddaattaa))''

       To print traffic neither sourced  from  nor  destined  for
       local  hosts  (if you gateway to one other net, this stuff
       should never make it onto your local net).
              ttccppdduummpp iipp aanndd nnoott nneett _l_o_c_a_l_n_e_t

       To print the start  and  end  packets  (the  SYN  and  FIN
       packets)  of  each  TCP  conversation that involves a non-
       local host.
              ttccppdduummpp ''ttccpp[[1133]] && 33 !!== 00 aanndd nnoott ssrrcc aanndd ddsstt nneett _l_o_c_a_l_n_e_t''




Jun                             25                              7





TCPDUMP(1)                     1989                    TCPDUMP(1)


       To print IP packets longer than  576  bytes  sent  through
       gateway _s_n_u_p:
              ttccppdduummpp ''ggaatteewwaayy ssnnuupp aanndd iipp[[22::22]] >> 557766''

       To  print  IP broadcast or multicast packets that were _n_o_t
       sent via ethernet broadcast or multicast:
              ttccppdduummpp ''eetthheerr[[00]] && 11 == 00 aanndd iipp[[1166]] >>== 222244''

       To  print   all   ICMP   packets   that   are   not   echo
       requests/replies (i.e., not ping packets):
              ttccppdduummpp ''iiccmmpp[[00]] !!== 88 aanndd iiccmmpp[[00]] !!== 00""

OOUUTTPPUUTT FFOORRMMAATT
       The   output   of  _t_c_p_d_u_m_p  is  protocol  dependent.   The
       following gives a brief description and examples  of  most
       of the formats.

       LLiinnkk LLeevveell HHeeaaddeerrss

       If  the  '-e'  option  is  given, the link level header is
       printed out.  On ethernets,  the  source  and  destination
       addresses, protocol, and packet length are printed.

       (_N._B.:  _T_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s _f_a_m_i_l_i_a_r_i_t_y _w_i_t_h
       _t_h_e _S_L_I_P _c_o_m_p_r_e_s_s_i_o_n _a_l_g_o_r_i_t_h_m _d_e_s_c_r_i_b_e_d _i_n _R_F_C-_1_1_4_4.)

       On SLIP links, a direction indicator (``I''  for  inbound,
       ``O''   for   outbound),   packet  type,  and  compression
       information are printed out.  The packet type  is  printed
       first.   The  three  types  are  _i_p,  _u_t_c_p,  and _c_t_c_p.  No
       further link information is printed for _i_p  packets.   For
       TCP   packets,   the   connection  identifier  is  printed
       following the type.  If  the  packet  is  compressed,  its
       encoded  header  is  printed  out.   The special cases are
       printed out as **SS++_n and **SSAA++_n, where _n is  the  amount  by
       which the sequence number (or sequence number and ack) has
       changed.  If it is  not  a  special  case,  zero  or  more
       changes  are  printed.  A change is indicated by U (urgent
       pointer), W (window), A (ack), S (sequence number), and  I
       (packet  ID),  followed  by  a  delta (+n or -n), or a new
       value (=n).  Finally, the amount of data in the packet and
       compressed header length are printed.

       For   example,   the  following  line  shows  an  outbound
       compressed  TCP  packet,  with  an   implicit   connection
       identifier;  the ack has changed by 6, the sequence number
       by 49, and the packet ID by 6; there are 3 bytes  of  data
       and 6 bytes of compressed header:
              OO ccttccpp ** AA++66 SS++4499 II++66 33 ((66))

       AARRPP//RRAARRPP PPaacckkeettss

       Arp/rarp   output  shows  the  type  of  request  and  its
       arguments.  The format is intended to be self explanatory.



Jun                             25                              8





TCPDUMP(1)                     1989                    TCPDUMP(1)


       Here is a short sample taken from the start of an `rlogin'
       from host _r_t_s_g to host _c_s_a_m:
              aarrpp wwhhoo--hhaass ccssaamm tteellll rrttssgg
              aarrpp rreeppllyy ccssaamm iiss--aatt CCSSAAMM
       The first line says that rtsg sent an  arp  packet  asking
       for  the  ethernet  address  of  internet host csam.  Csam
       replies  with  its  ethernet  address  (in  this  example,
       ethernet  addresses  are in caps and internet addresses in
       lower case).

       This would look less redundant if we had done ttccppdduummpp --nn:
              aarrpp wwhhoo--hhaass 112288..33..225544..66 tteellll 112288..33..225544..6688
              aarrpp rreeppllyy 112288..33..225544..66 iiss--aatt 0022::0077::0011::0000::0011::cc44

       If we had done ttccppdduummpp --ee, the fact that the first  packet
       is  broadcast  and  the  second is point-to-point would be
       visible:
              RRTTSSGG BBrrooaaddccaasstt 00880066  6644:: aarrpp wwhhoo--hhaass ccssaamm tteellll rrttssgg
              CCSSAAMM RRTTSSGG 00880066  6644:: aarrpp rreeppllyy ccssaamm iiss--aatt CCSSAAMM
       For the first packet this says the ethernet source address
       is  RTSG,  the  destination  is the broadcast address, the
       type field contained hex 0806  (type  ETHER_ARP)  and  the
       total length was 64 bytes.

       TTCCPP PPaacckkeettss

       (_N._B.:_T_h_e  _f_o_l_l_o_w_i_n_g  _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s _f_a_m_i_l_i_a_r_i_t_y _w_i_t_h
       _t_h_e _T_C_P _p_r_o_t_o_c_o_l _d_e_s_c_r_i_b_e_d _i_n _R_F_C-_7_9_3.   _I_f  _y_o_u  _a_r_e  _n_o_t
       _f_a_m_i_l_i_a_r  _w_i_t_h  _t_h_e _p_r_o_t_o_c_o_l, _n_e_i_t_h_e_r _t_h_i_s _d_e_s_c_r_i_p_t_i_o_n _n_o_r
       _t_c_p_d_u_m_p _w_i_l_l _b_e _o_f _m_u_c_h _u_s_e _t_o _y_o_u.)

       The general format of a tcp protocol line is:
              _s_r_c > _d_s_t: _f_l_a_g_s _d_a_t_a-_s_e_q_n_o _a_c_k _w_i_n_d_o_w _u_r_g_e_n_t _o_p_t_i_o_n_s
       _S_r_c and _d_s_t are the source and  destination  IP  addresses
       and  ports.   _F_l_a_g_s  are  some  combination  of S (SYN), F
       (FIN), P (PUSH) or R (RST) or a  single  `.'  (no  flags).
       _D_a_t_a-_s_e_q_n_o describes the portion of sequence space covered
       by the data in this packet (see example  below).   _A_c_k  is
       sequence  number  of  the  next  data  expected  the other
       direction on this connection.  _W_i_n_d_o_w  is  the  number  of
       bytes   of   receive  buffer  space  available  the  other
       direction on this  connection.   _U_r_g  indicates  there  is
       `urgent'  data  in  the  packet.   _O_p_t_i_o_n_s are tcp options
       enclosed in angle brackets (e.g., <mss 1024>).

       _S_r_c, _d_s_t and _f_l_a_g_s are always present.  The  other  fields
       depend on the contents of the packet's tcp protocol header
       and are output only if appropriate.

       Here is the opening portion of an rlogin from host _r_t_s_g to
       host _c_s_a_m.
              rrttssgg..11002233 >> ccssaamm..llooggiinn:: SS 776688551122::776688551122((00)) wwiinn 44009966 <<mmssss 11002244>>
              ccssaamm..llooggiinn >> rrttssgg..11002233:: SS 994477664488::994477664488((00)) aacckk 776688551133 wwiinn 44009966 <<mmssss 11002244>>
              rrttssgg..11002233 >> ccssaamm..llooggiinn:: .. aacckk 11 wwiinn 44009966



Jun                             25                              9





TCPDUMP(1)                     1989                    TCPDUMP(1)


              rrttssgg..11002233 >> ccssaamm..llooggiinn:: PP 11::22((11)) aacckk 11 wwiinn 44009966
              ccssaamm..llooggiinn >> rrttssgg..11002233:: .. aacckk 22 wwiinn 44009966
              rrttssgg..11002233 >> ccssaamm..llooggiinn:: PP 22::2211((1199)) aacckk 11 wwiinn 44009966
              ccssaamm..llooggiinn >> rrttssgg..11002233:: PP 11::22((11)) aacckk 2211 wwiinn 44007777
              ccssaamm..llooggiinn >> rrttssgg..11002233:: PP 22::33((11)) aacckk 2211 wwiinn 44007777 uurrgg 11
              ccssaamm..llooggiinn >> rrttssgg..11002233:: PP 33::44((11)) aacckk 2211 wwiinn 44007777 uurrgg 11
       The  first  line  says  that  tcp port 1023 on rtsg sent a
       packet to port _l_o_g_i_n on csam.  The SS  indicates  that  the
       _S_Y_N  flag  was set.  The packet sequence number was 768512
       and   it   contained   no   data.    (The   notation    is
       `first:last(nbytes)'  which  means `sequence numbers _f_i_r_s_t
       up to but not including _l_a_s_t which is _n_b_y_t_e_s bytes of user
       data'.)   There  was  no  piggy-backed  ack, the available
       receive window was 4096 bytes and there was a max-segment-
       size option requesting an mss of 1024 bytes.

       Csam  replies  with  a similar packet except it includes a
       piggy-backed ack for rtsg's SYN.  Rtsg  then  acks  csam's
       SYN.   The  `.'  means  no  flags  were  set.   The packet
       contained no data so there is  no  data  sequence  number.
       Note  that the ack sequence number is a small integer (1).
       The first time  ttccppdduummpp  sees  a  tcp  `conversation',  it
       prints the sequence number from the packet.  On subsequent
       packets of the conversation, the  difference  between  the
       current packet's sequence number and this initial sequence
       number is printed.  This means that sequence numbers after
       the first can be interpreted as relative byte positions in
       the conversation's data stream (with the first  data  byte
       each  direction  being  `1').   `-S'  will  override  this
       feature, causing  the  original  sequence  numbers  to  be
       output.

       On the 6th line, rtsg sends csam 19 bytes of data (bytes 2
       through 20 in the rtsg -> csam side of the  conversation).
       The PUSH flag is set in the packet.  On the 7th line, csam
       says it's received  data  sent  by  rtsg  up  to  but  not
       including  byte  21.   Most  of  this  data  is apparently
       sitting in the socket buffer since csam's  receive  window
       has  gotten 19 bytes smaller.  Csam also sends one byte of
       data to rtsg in this packet.  On the 8th  and  9th  lines,
       csam sends two bytes of urgent, pushed data to rtsg.

       UUDDPP PPaacckkeettss

       UDP format is illustrated by this rwho packet:
              aaccttiinniiddee..wwhhoo >> bbrrooaaddccaasstt..wwhhoo:: uuddpp 8844
       This  says  that  port  _w_h_o  on  host  _a_c_t_i_n_i_d_e sent a udp
       datagram to port  _w_h_o  on  host  _b_r_o_a_d_c_a_s_t,  the  Internet
       broadcast  address.  The packet contained 84 bytes of user
       data.

       Some UDP services  are  recognized  (from  the  source  or
       destination  port  number)  and  the higher level protocol
       information printed.  In particular, Domain  Name  service



Jun                             25                             10





TCPDUMP(1)                     1989                    TCPDUMP(1)


       requests  (RFC-1034/1035)  and Sun RPC calls (RFC-1050) to
       NFS.

       UUDDPP NNaammee SSeerrvveerr RReeqquueessttss

       (_N._B.:_T_h_e _f_o_l_l_o_w_i_n_g _d_e_s_c_r_i_p_t_i_o_n _a_s_s_u_m_e_s  _f_a_m_i_l_i_a_r_i_t_y  _w_i_t_h
       _t_h_e _D_o_m_a_i_n _S_e_r_v_i_c_e _p_r_o_t_o_c_o_l _d_e_s_c_r_i_b_e_d _i_n _R_F_C-_1_0_3_5.  _I_f _y_o_u
       _a_r_e  _n_o_t  _f_a_m_i_l_i_a_r  _w_i_t_h  _t_h_e  _p_r_o_t_o_c_o_l,   _t_h_e   _f_o_l_l_o_w_i_n_g
       _d_e_s_c_r_i_p_t_i_o_n _w_i_l_l _a_p_p_e_a_r _t_o _b_e _w_r_i_t_t_e_n _i_n _g_r_e_e_k.)

       Name server requests are formatted as
              _s_r_c > _d_s_t: _i_d _o_p? _f_l_a_g_s _q_t_y_p_e _q_c_l_a_s_s _n_a_m_e (_l_e_n)
              hh22ooppoolloo..11553388 >> hheelliiooss..ddoommaaiinn:: 33++ AA?? uuccbbvvaaxx..bbeerrkkeelleeyy..eedduu.. ((3377))
       Host  _h_2_o_p_o_l_o  asked  the  domain  server on _h_e_l_i_o_s for an
       address  record  (qtype=A)  associated   with   the   name
       _u_c_b_v_a_x._b_e_r_k_e_l_e_y._e_d_u.   The  query  id  was  `3'.   The `+'
       indicates the _r_e_c_u_r_s_i_o_n _d_e_s_i_r_e_d flag was set.   The  query
       length was 37 bytes, not including the UDP and IP protocol
       headers.  The query operation was the normal  one,  _Q_u_e_r_y,
       so  the op field was omitted.  If the op had been anything
       else, it would have been printed between the `3'  and  the
       `+'.   Similarly, the qclass was the normal one, _C__I_N, and
       omitted.   Any  other  qclass  would  have  been   printed
       immediately after the `A'.

       A few anomalies are checked and may result in extra fields
       enclosed in square  brackets:   If  a  query  contains  an
       answer,   name   server  or  authority  section,  _a_n_c_o_u_n_t,
       _n_s_c_o_u_n_t, or _a_r_c_o_u_n_t  are  printed  as  `[_na]',  `[_nn]'  or
       `[_nau]'  where  _n is the appropriate count.  If any of the
       response bits are set (AA, RA or  rcode)  or  any  of  the
       `must  be  zero'  bits  are  set  in  bytes two and three,
       `[b2&3=_x]' is printed, where _x is the hex value of  header
       bytes two and three.

       UUDDPP NNaammee SSeerrvveerr RReessppoonnsseess

       Name server responses are formatted as
              _s_r_c > _d_s_t:  _i_d _o_p _r_c_o_d_e _f_l_a_g_s _a/_n/_a_u _t_y_p_e _c_l_a_s_s _d_a_t_a (_l_e_n)
              hheelliiooss..ddoommaaiinn >> hh22ooppoolloo..11553388:: 33 33//33//77 AA 112288..3322..113377..33 ((227733))
              hheelliiooss..ddoommaaiinn >> hh22ooppoolloo..11553377:: 22 NNXXDDoommaaiinn** 00//11//00 ((9977))
       In  the  first example, _h_e_l_i_o_s responds to query id 3 from
       _h_2_o_p_o_l_o with 3 answer records, 3 name server records and 7
       authority  records.   The  first  answer  record is type A
       (address) and its data is internet  address  128.32.137.3.
       The  total  size  of the response was 273 bytes, excluding
       UDP and IP headers.  The  op  (Query)  and  response  code
       (NoError)  were  omitted, as was the class (C_IN) of the A
       record.

       In the second example, _h_e_l_i_o_s responds to query 2  with  a
       response  code  of  non-existent domain (NXDomain) with no
       answers, one name server and no  authority  records.   The
       `*'  indicates  that the _a_u_t_h_o_r_i_t_a_t_i_v_e _a_n_s_w_e_r bit was set.



Jun                             25                             11





TCPDUMP(1)                     1989                    TCPDUMP(1)


       Since there were no answers, no type, class or  data  were
       printed.

       Other flag characters that might appear are `-' (recursion
       available, RA, _n_o_t set) and `|'  (truncated  message,  TC,
       set).   If  the `question' section doesn't contain exactly
       one entry, `[_nq]' is printed.

       Note that name server requests and responses  tend  to  be
       large  and the default _s_n_a_p_l_e_n of 96 bytes may not capture
       enough of the  packet  to  print.   Use  the  --ss  flag  to
       increase  the snaplen if you need to seriously investigate
       name server traffic.  `--ss 112288' has worked well for me.


       NNFFSS RReeqquueessttss

       Sun NFS (Network File System)  requests  and  replies  are
       printed as:
              _s_r_c._x_i_d > _d_s_t._n_f_s: _l_e_n _o_p _a_r_g_s
              _s_r_c._n_f_s > _d_s_t._x_i_d: _r_e_p_l_y _s_t_a_t _l_e_n
              vvss..ee22776666 >> hheelliiooss..nnffss:: 113366 rreeaaddddiirr ffhh 66..55119977 88119922 bbyytteess @@ 00
              hheelliiooss..nnffss >> vvss..ee22776666:: rreeppllyy ookk 338844
              vvss..ee22776677 >> hheelliiooss..nnffss:: 113366 llooookkuupp ffhh 66..55119977 ``RRCCSS''
       In  the  first  line,  host _v_s sends a transaction with id
       _e_2_7_6_6 to _h_e_l_i_o_s (note that the number  following  the  src
       host  is  a  transaction  id,  _n_o_t  the source port).  The
       request was 136 bytes, excluding the UDP and  IP  headers.
       The  operation  was  a  _r_e_a_d_d_i_r  (read  directory) on file
       handle (_f_h) 6.5197.  8192  bytes  are  read,  starting  at
       offset  0.   _H_e_l_i_o_s  replies  `ok' with 384 bytes of data.
       (The design of Sun's RPC protocol makes  it  difficult  to
       interpret replies.  I don't bother.)

       In the third line, _v_s asks _h_e_l_i_o_s to lookup the name `_R_C_S'
       in directory file 6.5197.   Note  that  the  data  printed
       depends  on the operation type.  The format is intended to
       be  self  explanatory  (at  least,  to  me)  if  read   in
       conjunction with an NFS protocol spec.

       Note  that NFS requests are very large and the above won't
       be printed unless _s_n_a_p_l_e_n is increased.  I use `--ss 119922' to
       watch NFS traffic.


       KKIIPP AApppplleettaallkk ((DDDDPP iinn UUDDPP))

       Appletalk  DDP  packets  encapsulated in UDP datagrams are
       de-encapsulated and dumped as DDP packets (i.e.,  all  the
       UDP   header   information   is   discarded).    The  file
       /_e_t_c/_a_t_a_l_k._n_a_m_e_s is used to translate  appletalk  net  and
       node numbers to names.  Lines in this file have the form
              _n_u_m_b_e_r    _n_a_m_e




Jun                             25                             12





TCPDUMP(1)                     1989                    TCPDUMP(1)


              11..225544          eetthheerr
              1166..11      iiccssdd--nneett
              11..225544..111100 aaccee
       The  first two lines give the names of appletalk networks.
       The third line gives the name of a particular host (a host
       is distinguished from a net by the 3rd octet in the number
       - a net number _m_u_s_t have two octets and a host number _m_u_s_t
       have  three  octets.)   The  number  and  name  should  be
       separated   by   whitespace   (blanks   or   tabs).    The
       /_e_t_c/_a_t_a_l_k._n_a_m_e_s  file  may contain blank lines or comment
       lines (lines starting with a `#').

       Appletalk addresses are printed in the form
              _n_e_t._h_o_s_t._p_o_r_t

              114444..11..220099..22 >> iiccssdd--nneett..111122..222200
              ooffffiiccee..22 >> iiccssdd--nneett..111122..222200
              jjssssmmaagg..114499..223355 >> iiccssdd--nneett..22
       (If the /_e_t_c/_a_t_a_l_k._n_a_m_e_s doesn't exist or doesn't  contain
       an entry for some appletalk host/net number, addresses are
       printed in numeric form.)  In the first example, NBP  (DDP
       port  2)  on  net 144.1 node 209 is sending to whatever is
       listening on port 220 of net icsd node  112.   The  second
       line  is  the same except the full name of the source node
       is known (`office').  The third line is a send  from  port
       235  on  net  jssmag node 149 to broadcast on the icsd-net
       NBP  port  (note  that  the  broadcast  address  (255)  is
       indicated  by  a  net  name with no host number - for this
       reason it's a good idea to keep node names and  net  names
       distinct in /etc/atalk.names).

       NBP (name binding protocol) and ATP (Appletalk transaction
       protocol) packets have their contents interpreted.   Other
       protocols  just  dump  the  protocol name (or number if no
       name is registered for the protocol) and packet size.

       NNBBPP ppaacckkeettss are formatted like the following examples:
              iiccssdd--nneett..111122..222200 >> jjssssmmaagg..22:: nnbbpp--llkkuupp 119900:: ""==::LLaasseerrWWrriitteerr@@**""
              jjssssmmaagg..220099..22 >> iiccssdd--nneett..111122..222200:: nnbbpp--rreeppllyy 119900:: ""RRMM11114400::LLaasseerrWWrriitteerr@@**"" 225500
              tteecchhppiitt..22 >> iiccssdd--nneett..111122..222200:: nnbbpp--rreeppllyy 119900:: ""tteecchhppiitt::LLaasseerrWWrriitteerr@@**"" 118866
       The first line is a name lookup request  for  laserwriters
       sent  by  net  icsd  host 112 and broadcast on net jssmag.
       The nbp id for the lookup is 190.  The second line shows a
       reply for this request (note that it has the same id) from
       host jssmag.209 saying that it has a laserwriter  resource
       named  "RM1140" registered on port 250.  The third line is
       another reply to the same request saying host techpit  has
       laserwriter "techpit" registered on port 186.

       AATTPP  ppaacckkeett  formatting  is  demonstrated by the following
       example:
              jjssssmmaagg..220099..116655 >> hheelliiooss..113322:: aattpp--rreeqq  1122226666<<00--77>> 00xxaaee003300000011
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::00 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::11 ((551122)) 00xxaaee004400000000



Jun                             25                             13





TCPDUMP(1)                     1989                    TCPDUMP(1)


              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::22 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::33 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::44 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::55 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::66 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp**1122226666::77 ((551122)) 00xxaaee004400000000
              jjssssmmaagg..220099..116655 >> hheelliiooss..113322:: aattpp--rreeqq  1122226666<<33,,55>> 00xxaaee003300000011
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::33 ((551122)) 00xxaaee004400000000
              hheelliiooss..113322 >> jjssssmmaagg..220099..116655:: aattpp--rreesspp 1122226666::55 ((551122)) 00xxaaee004400000000
              jjssssmmaagg..220099..116655 >> hheelliiooss..113322:: aattpp--rreell  1122226666<<00--77>> 00xxaaee003300000011
              jjssssmmaagg..220099..113333 >> hheelliiooss..113322:: aattpp--rreeqq** 1122226677<<00--77>> 00xxaaee003300000022
       Jssmag.209 initiates transaction id 12266 with host helios
       by  requesting  up  to  8  packets (the `<0-7>').  The hex
       number at the  end  of  the  line  is  the  value  of  the
       `userdata' field in the request.

       Helios  responds  with  8  512-byte packets.  The `:digit'
       following the transaction id  gives  the  packet  sequence
       number  in the transaction and the number in parens is the
       amount of data in the packet, excluding  the  atp  header.
       The `*' on packet 7 indicates that the EOM bit was set.

       Jssmag.209   then   requests   that   packets  3  &  5  be
       retransmitted.   Helios  resends  them   then   jssmag.209
       releases  the  transaction.  Finally, jssmag.209 initiates
       the next request.  The `*' on the request  indicates  that
       XO (`exactly once') was _n_o_t set.


       IIPP FFrraaggmmeennttaattiioonn

       Fragmented Internet datagrams are printed as
              ((ffrraagg _i_d::_s_i_z_e@@_o_f_f_s_e_t++))
              ((ffrraagg _i_d::_s_i_z_e@@_o_f_f_s_e_t))
       (The  first  form indicates there are more fragments.  The
       second indicates this is the last fragment.)

       _I_d is the fragment id (in hex).  _S_i_z_e is the fragment size
       (in  bytes)  excluding  the  IP  header.   _O_f_f_s_e_t  is this
       fragment's offset (in bytes) in the original datagram.

       The fragment information is output for each fragment.  The
       first  fragment  contains the higher level protocol header
       and the frag info is  printed  after  the  protocol  info.
       Fragments after the first contain no higher level protocol
       header and the frag info is printed after the  source  and
       destination  addresses.   For  example, here is part of an
       ftp  from  arizona.edu  to  lbl-rtsg.arpa  over  a   CSNET
       connection   that   doesn't  appear  to  handle  576  byte
       datagrams:
              aarriizzoonnaa..ffttpp--ddaattaa >> rrttssgg..11117700:: .. 11002244::11333322((330088)) aacckk 11 wwiinn 44009966 ((ffrraagg 559955aa::332288@@00++))
              aarriizzoonnaa >> rrttssgg:: ((ffrraagg 559955aa::220044@@332288))
              rrttssgg..11117700 >> aarriizzoonnaa..ffttpp--ddaattaa:: .. aacckk 11553366 wwiinn 22556600
       There are  a  couple  of  things  to  note  here:   First,



Jun                             25                             14





TCPDUMP(1)                     1989                    TCPDUMP(1)


       addresses  in  the  2nd  line  don't include port numbers.
       This is because the TCP protocol information is all in the
       first  fragment  and  we  have  no  idea  what the port or
       sequence numbers are when we print  the  later  fragments.
       Second,  the tcp sequence information in the first line is
       printed as if there were 308 bytes of user data  when,  in
       fact,  there  are 512 bytes (308 in the first frag and 204
       in the second).  If you  are  looking  for  holes  in  the
       sequence  space  or  trying to match up acks with packets,
       this can fool you.

       A packet with the IP _d_o_n'_t _f_r_a_g_m_e_n_t flag is marked with  a
       trailing ((DDFF)).

       TTiimmeessttaammppss

       By  default, all output lines are preceded by a timestamp.
       The timestamp is the current clock time in the form
              _h_h:_m_m:_s_s._f_r_a_c
       and is as accurate as the kernel's clock (e.g., +-10ms  on
       a  Sun-3).   The  timestamp  reflects  the time the kernel
       first saw the packet.  No attempt is made to  account  for
       the  time  lag between when the ethernet interface removed
       the packet from the wire and when the kernel serviced  the
       `new  packet' interrupt (of course, with Sun's lousy clock
       resolution this time lag is negligible.)

SSEEEE AALLSSOO
       traffic(1C), nit(4P), bpf(4)

AAUUTTHHOORRSS
       Van   Jacobson   (van@helios.ee.lbl.gov),   Craig    Leres
       (leres@helios.ee.lbl.gov)      and      Steven     McCanne
       (mccanne@helios.ee.lbl.gov),  all  of  Lawrence   Berkeley
       Laboratory, University of California, Berkeley, CA.

BBUUGGSS
       The  clock resolution on most Suns is pathetic (20ms).  If
       you want to use the timestamp  to  generate  some  of  the
       important    performance    distributions   (like   packet
       interarrival time)  it's  best  to  watch  something  that
       generates  packets  slowly  (like  an Arpanet gateway or a
       MicroVax running VMS).

       NIT doesn't let you watch your own outbound  traffic,  BPF
       will.  We recommend that you use the latter.

       _t_c_p_d_u_m_p  for  Ultrix requires Ultrix version 4.0 or later;
       the kernel has to have been built  with  the  _p_a_c_k_e_t_f_i_l_t_e_r
       pseudo-device  driver  (see  _p_a_c_k_e_t_f_i_l_t_e_r(4)).  As of this
       writing, Ultrix does not let you  watch  either  your  own
       outbound or inbound traffic.

       Under  SunOS 4.1, the packet capture code (or Streams NIT)



Jun                             25                             15





TCPDUMP(1)                     1989                    TCPDUMP(1)


       is not what you'd call efficient.   Don't  plan  on  doing
       much with your Sun while you're monitoring a busy network.

       On Sun systems prior to release 3.2, NIT  is  very  buggy.
       If run on an old system, tcpdump may crash the machine.

       Some attempt should be made to reassemble IP fragments or,
       at least to compute the right length for the higher  level
       protocol.

       Name  server inverse queries are not dumped correctly: The
       (empty) question section is printed rather than real query
       in  the answer section.  Some believe that inverse queries
       are themselves  a  bug  and  prefer  to  fix  the  program
       generating them rather than tcpdump.

       Apple  Ethertalk  DDP packets could be dumped as easily as
       KIP DDP packets but aren't.  Even if we were  inclined  to
       do  anything  to promote the use of Ethertalk (we aren't),
       LBL doesn't allow Ethertalk on any of its networks so we'd
       would have no way of testing this code.

       A packet trace that crosses a daylight savings time change
       will give skewed time stamps (the time change is ignored).

































Jun                             25                             16


