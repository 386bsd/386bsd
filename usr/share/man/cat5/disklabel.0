DISKLABEL(5)              386BSD Programmer's Manual              DISKLABEL(5)

NNAAMMEE
     ddiisskkllaabbeell - disk pack label

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ddiisskkllaabbeell..hh>>

DDEESSCCRRIIPPTTIIOONN
     Each disk or disk pack on a system may contain a disk label which pro-
     vides detailed information about the geometry of the disk and the parti-
     tions into which the disk is divided.  It should be initialized when the
     disk is formatted, and may be changed later with the disklabel(8) pro-
     gram.  This information is used by the system disk driver and by the
     bootstrap program to determine how to program the drive and where to find
     the filesystems on the disk partitions.  Additional information is used
     by the filesystem in order to use the disk most efficiently and to locate
     important filesystem information.  The description of each partition con-
     tains an identifier for the partition type (standard filesystem, swap
     area, etc.).  The filesystem updates the in-core copy of the label if it
     contains incomplete information about the filesystem.

     The label is located in sector number LABELSECTOR of the drive, usually
     sector 0 where it may be found without any information about the disk ge-
     ometry.  It is at an offset LABELOFFSET from the beginning of the sector,
     to allow room for the initial bootstrap.  The disk sector containing the
     label is normally made read-only so that it is not accidentally overwrit-
     ten by pack-to-pack copies or swap operations; the DIOCWLABEL ioctl(2),
     which is done as needed by the disklabel program.

     A copy of the in-core label for a disk can be obtained with the
     DIOCGDINFO ioctl;  this works with a file descriptor for a block or char-
     acter (``raw'') device for any partition of the disk.  The in-core copy
     of the label is set by the DIOCSDINFO ioctl.  The offset of a partition
     cannot generally be changed while it is open, nor can it be made smaller
     while it is open.  One exception is that any change is allowed if no la-
     bel was found on the disk, and the driver was able to construct only a
     skeletal label without partition information.  Finally, the DIOCWDINFO
     ioctl operation sets the in-core label and then updates the on-disk la-
     bel; there must be an existing label on the disk for this operation to
     succeed.  Thus, the initial label for a disk or disk pack must be in-
     stalled by writing to the raw disk.  All of these operations are normally
     done using disklabel.

     The format of the disk label, as specified in is

     /*
     * Disk description table, see disktab(5)
     */
     #define DISKTAB         "/etc/disktab"

     /*
     * Each disk has a label which includes information about the hardware
     * disk geometry, filesystem partitions, and drive specific information.
     * The label is in block 0 or 1, possibly offset from the beginning
     * to leave room for a bootstrap, etc.
     */

     #define LABELSECTOR     0       /* sector containing label */
     #define LABELOFFSET     64      /* offset of label in sector */
     #define DISKMAGIC       ((u_long) 0x82564557)   /* The disk magic number */
     #ifndef MAXPARTITIONS
     #define MAXPARTITIONS   8
     #endif

     #ifndef LOCORE
     struct disklabel {
             u_long  d_magic;        /* the magic number */
             short   d_type;         /* drive type */
             short   d_subtype;      /* controller/d_type specific */
             char    d_typename[16]; /* type name, e.g. "eagle" */
             /*
             * d_packname contains the pack identifier and is returned when
             * the disklabel is read off the disk or in-core copy.
             * d_boot0 and d_boot1 are the (optional) names of the
             * primary (block 0) and secondary (block 1-15) bootstraps
             * as found in /usr/mdec.  These are returned when using
             * getdiskbyname(3)
             to retrieve the values from /etc/disktab.
             */
     #if defined(KERNEL) || defined(STANDALONE)
             char    d_packname[16];         /* pack identifier */
     #else
             union {
                     char    un_d_packname[16];      /* pack identifier */
                     struct {
                             char *un_d_boot0;       /* primary bootstrap name */
                             char *un_d_boot1;       /* secondary bootstrap name */
                     } un_b;
             } d_un;

     #define d_packname      d_un.un_d_packname
     #define d_boot0         d_un.un_b.un_d_boot0
     #define d_boot1         d_un.un_b.un_d_boot1
     #endif  /* ! KERNEL or STANDALONE */

             /* disk geometry: */
             u_long  d_secsize;      /* # of bytes per sector */
             u_long  d_nsectors;     /* # of data sectors per track */
             u_long  d_ntracks;      /* # of tracks per cylinder */
             u_long  d_ncylinders;   /* # of data cylinders per unit */
             u_long  d_secpercyl;    /* # of data sectors per cylinder */
             u_long  d_secperunit;   /* # of data sectors per unit */
             /*
             * Spares (bad sector replacements) below
             * are not counted in d_nsectors or d_secpercyl.
             * Spare sectors are assumed to be physical sectors
             * which occupy space at the end of each track and/or cylinder.
             */
             u_short d_sparespertrack;       /* # of spare sectors per track */
             u_short d_sparespercyl; /* # of spare sectors per cylinder */
             /*
             * Alternate cylinders include maintenance, replacement,
             * configuration description areas, etc.
             */
             u_long  d_acylinders;   /* # of alt. cylinders per unit */

                     /* hardware characteristics: */
             /*
             * d_interleave, d_trackskew and d_cylskew describe perturbations
             * in the media format used to compensate for a slow controller.
             * Interleave is physical sector interleave, set up by the formatter
             * or controller when formatting.  When interleaving is in use,
             * logically adjacent sectors are not physically contiguous,
             * but instead are separated by some number of sectors.
             * It is specified as the ratio of physical sectors traversed
             * per logical sector.  Thus an interleave of 1:1 implies contiguous
             * layout, while 2:1 implies that logical sector 0 is separated
             * by one sector from logical sector 1.
             * d_trackskew is the offset of sector 0 on track N
             * relative to sector 0 on track N-1 on the same cylinder.
             * Finally, d_cylskew is the offset of sector 0 on cylinder N
             * relative to sector 0 on cylinder N-1.
             */
             u_short d_rpm;  /* rotational speed */
             u_short d_interleave;   /* hardware sector interleave */
             u_short d_trackskew;    /* sector 0 skew, per track */
             u_short d_cylskew;      /* sector 0 skew, per cylinder */
             u_long  d_headswitch;   /* head switch time, usec */
             u_long  d_trkseek;      /* track-to-track seek, usec */
             u_long  d_flags;        /* generic flags */
     #define NDDATA 5
             u_long  d_drivedata[NDDATA];    /* drive-type specific information */
     #define NSPARE 5
             u_long  d_spare[NSPARE];        /* reserved for future use */
             u_long  d_magic2;       /* the magic number (again) */
             u_short d_checksum;     /* xor of data incl. partitions */

             /* filesystem and partition information: */
             u_short d_npartitions;  /* number of partitions in following */
             u_long  d_bbsize;       /* size of boot area at sn0, bytes */
             u_long  d_sbsize;       /* max size of fs superblock, bytes */
             struct  partition {     /* the partition table */
                     u_long  p_size; /* number of sectors in partition */
                     u_long  p_offset;       /* starting sector */
                     u_long  p_fsize;        /* filesystem basic fragment size */
                     u_char  p_fstype;       /* filesystem type, see below */
                     u_char  p_frag; /* filesystem fragments per block */
                     u_short p_cpg;  /* filesystem cylinders per group */
             } d_partitions[MAXPARTITIONS];  /* actually may be more */
     };

     /* d_type values: */
     #define DTYPE_SMD       1       /* SMD, XSMD; VAX hp/up */
     #define DTYPE_MSCP      2       /* MSCP */
     #define DTYPE_DEC       3       /* other DEC (rk, rl) */
     #define DTYPE_SCSI      4       /* SCSI */
     #define DTYPE_ESDI      5       /* ESDI interface */
     #define DTYPE_ST506     6       /* ST506 etc. */
     #define DTYPE_FLOPPY    10      /* floppy */

     #ifdef DKTYPENAMES
     static char *dktypenames[] = {
             "unknown",
             "SMD",
             "MSCP",
             "old DEC",
             "SCSI",
             "ESDI",
             "type 6",
             "type 7",
             "type 8",
             "type 9",
             "floppy",
             0
     };
     #define DKMAXTYPES      (sizeof(dktypenames) / sizeof(dktypenames[0]) - 1)
     #endif

     /*
     * Filesystem type and version.
     * Used to interpret other filesystem-specific
     * per-partition information.
     */
     #define FS_UNUSED       0       /* unused */
     #define FS_SWAP         1       /* swap */
     #define FS_V6           2       /* Sixth Edition */
     #define FS_V7           3       /* Seventh Edition */
     #define FS_SYSV         4       /* System V */
     #define FS_V71K         5       /* V7 with 1K blocks (4.1, 2.9) */
     #define FS_V8           6       /* Eighth Edition, 4K blocks */
     #define FS_BSDFFS       7       /* 4.2BSD fast file system */

     #ifdef  DKTYPENAMES
     static char *fstypenames[] = {
             "unused",
             "swap",
             "Version 6",
             "Version 7",
             "System V",
             "4.1BSD",
             "Eighth Edition",
             "4.2BSD",
             0
     };
     #define FSMAXTYPES      (sizeof(fstypenames) / sizeof(fstypenames[0]) - 1)
     #endif

     /*
     * flags shared by various drives:
     */
     #define D_REMOVABLE     0x01    /* removable media */
     #define D_ECC           0x02    /* supports ECC */
     #define D_BADSECT       0x04    /* supports bad sector forw. */
     #define D_RAMDISK       0x08    /* disk emulator */
     #define D_CHAIN         0x10    /* can do back-back transfers */

     /*
     * Drive data for SMD.
     */

     #define d_smdflags      d_drivedata[0]
     #define D_SSE           0x1     /* supports skip sectoring */
     #define d_mindist       d_drivedata[1]
     #define d_maxdist       d_drivedata[2]
     #define d_sdist         d_drivedata[3]

     /*
     * Drive data for ST506.
     */
     #define d_precompcyl    d_drivedata[0]
     #define d_gap3          d_drivedata[1]  /* used only when formatting */

     #ifndef LOCORE
     /*
     * Structure used to perform a format
     * or other raw operation, returning data
     * and/or register values.
     * Register identification and format
     * are device- and driver-dependent.
     */
     struct format_op {
             char    *df_buf;
             int     df_count;       /* value-result */
             daddr_t df_startblk;
             int     df_reg[8];      /* result */
     };

     /*
     * Structure used internally to retrieve
     * information about a partition on a disk.
     */
     struct partinfo {
             struct  disklabel *disklab;
             struct  partition *part;
     };

     /*
     * Disk-specific ioctls.
     */
             /* get and set disklabel; DIOCGPART used internally */
     #define DIOCGDINFO   _IOR('d', 101, struct disklabel) /* get */
     #define DIOCSDINFO   _IOW('d', 102, struct disklabel) /* set */
     #define DIOCWDINFO   _IOW('d', 103, struct disklabel) /* set, update disk */
     #define DIOCGPART    _IOW('d', 104, struct partinfo)  /* get partition */

     /* do format operation, read or write */
     #define DIOCRFORMAT     _IOWR('d', 105, struct format_op)
     #define DIOCWFORMAT     _IOWR('d', 106, struct format_op)

     #define DIOCSSTEP       _IOW('d', 107, int) /* set step rate */
     #define DIOCSRETRIES    _IOW('d', 108, int) /* set # of retries */
     #define DIOCWLABEL      _IOW('d', 109, int) /* write en/disable label */

     #define DIOCSBAD        _IOW('d', 110, struct dkbad) /* set kernel dkbad */

     #endif LOCORE

SSEEEE AALLSSOO
     disktab(5),  disklabel(8)

HHIISSTTOORRYY
     The ddiisskkllaabbeell file format is currently under development.

BSD Experimental                 May 10, 1991                                6



































