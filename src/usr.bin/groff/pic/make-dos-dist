#! /bin/sh

# This creates a compressed (14 bits) tar file that can be copied to a DOS
# machine, unpacked and compiled with Borland C++ 2.0.

# This is for groff version 1.04.  It will probably need work for
# other versions.

# The grammar is yacced here, because I don't have a yacc on my DOS
# machine.  The resulting .tab.c file is split up; I found the
# compiler ran out of memory otherwise.  The sed command that does the
# splitting assumes you're using the SunOS 4.1.1 yacc.
# (Bison-generated parsers need alloca() which Borland C++ does not
# have.) You'll need to tweak it for other yaccs: in particular you'll
# need to change the `tabs' variable, so that it matches the names of
# the external arrays of ints generated by your version yacc: it is
# these that are split off into another file.  You may also need to
# change tabtype to `short' if the tables are arrays of shorts.

picdir=`pwd`
tarfile=pic_tar
tabs="yyexca yyact yypact yypgo yyr1 yyr2 yychk yydef"
tabtype=int
file1=pic_tab1.c
file2=pic_tab2.c

rm -fr temp
mkdir temp
cd temp


yacc -d $picdir/pic.y

for tab in $tabs; do echo "/$tabtype $tab\\[]/i\\
extern $tabtype $tab[];
/$tabtype $tab\\[]/,/;/{
w $file2
d
}"; done >split.sed

sed -f split.sed y.tab.c >$file1

rm -f split.sed y.tab.c

mv y.tab.h pic_tab.h

libfiles="change_lf.c cset.c cset.h errarg.c errarg.h error.c error.h \
fatal.c filename.c version.c lf.c lib.h lineno.c new.c string.c \
stringclass.h progname.c strerror.c strsave.c ptable.c ptable.h"

picfiles="common.c common.h lex.c main.c object.c object.h output.h \
pic.h position.h tex.c text.h troff.c"

for file in $picfiles
do
	sed -e '/^#include/s/pic\.tab\.h/pic_tab.h/' $picdir/$file >$file
done

for file in $libfiles; do cp $picdir/../lib/$file $file; done

mv stringclass.h stringcl.h
mv change_lf.c changelf.c

cat >makefile <<'EOF'
# Makefile for pic with Borland C++ 2.0.
CC=bcc -P -V
OLDCC=bcc -V
MODEL=l
WARN=
DEBUG=
MAP=-M
CFLAGS=-m$(MODEL) $(WARN) $(DEBUG) -I. -DSWITCHAR
LDFLAGS=-m$(MODEL) $(DEBUG) $(MAP)

OBJS=changelf.obj \
common.obj \
cset.obj \
errarg.obj \
error.obj \
fatal.obj \
filename.obj \
lex.obj \
lf.obj \
lineno.obj \
main.obj \
new.obj \
object.obj \
pic_tab1.obj \
pic_tab2.obj \
progname.obj \
ptable.obj \
string.obj \
strsave.obj \
tex.obj \
troff.obj \
version.obj \
getopt.obj \
strerror.obj

PROG=pic

.c.obj:
	$(CC) -c $(CFLAGS) {$< }

$(PROG).exe: $(OBJS)
	$(CC) $(LDFLAGS) -e$(PROG) @&&!
$(OBJS)
!

strerror.obj: strerror.c
	$(OLDCC) -c $(CFLAGS) strerror.c

getopt.obj: getopt.c
	$(OLDCC) -c $(CFLAGS) getopt.c

# Enable auto-dependency checking.
.autodepend
EOF

cat >osfcn.h <<'EOF'
#include <io.h>

extern "C" {
     int getopt(int, char **, const char *);
     extern int optind;
     extern int opterr;
}
EOF

cat >getopt.c <<'EOF'
/* getopt() for those systems that don't have it. */
/* Derived from comp.sources.unix/volume3/att_getopt. */

#include <stdio.h>
#include <string.h>

#ifdef SWITCHAR
#include <dos.h>
#endif

int	opterr = 1;
int	optind = 1;
int	optopt;
char *optarg;

#ifndef OPTION_CHAR
#define OPTION_CHAR '-'
#endif

int getopt(argc, argv, opts)
int argc;
char **argv;
char *opts;
{
#ifdef SWITCHAR
	union REGS regs;
	static char switchar = '\0';
#endif
	static int sp = 1;
	register int c;
	register char *cp;
	char *message;
#ifdef SWITCHAR
	if (switchar == '\0') {
		regs.x.ax = 0x3700;
		intdos(&regs, &regs);
		if (!regs.x.cflag)
			switchar = regs.h.dl;
		else
			switchar = '/';
	}
#endif
	if (sp == 1) {
		if (optind >= argc)
			return EOF;
		if ((
#ifdef SWITCHAR
			argv[optind][0] != switchar &&
#endif
			argv[optind][0] != OPTION_CHAR) || argv[optind][1] == '\0') {
#ifdef REORDER_ARGS
			int i;
			for (i = optind; i < argc; i++)
				if ((
#ifdef SWITCHAR
					 argv[i][0] == switchar ||
#endif
					 argv[i][0] == OPTION_CHAR) && argv[i][1] != '\0')
					break;
			if (i < argc) {
				c = argv[i][1];
#ifdef CASE_INSENSITIVE_OPTIONS
				if (isupper(c))
					c = tolower(c);
#endif
				if (c != ':' && c != OPTION_CHAR && (cp = strchr(opts, c)) != NULL
					&& cp[1] == ':' && argv[i][2] == 0 && i < argc - 1) {
					int j;
					char *temp1 = argv[i];
					char *temp2 = argv[i+1];
					for (j = i - 1; j >= optind; j--)
						argv[j+2] = argv[j];
					argv[optind] = temp1;
					argv[optind+1] = temp2;
				}
				else {
					int j;
					char *temp = argv[i];
					for (j = i - 1; j >= optind; j--)
						argv[j+1] = argv[j];
					argv[optind] = temp;
				}
			}
			else
#endif
				return EOF;
		}
		if ((argv[optind][0] == OPTION_CHAR && argv[optind][1] == OPTION_CHAR
				  && argv[optind][2] == '\0')
#ifdef SWITCHAR
			|| (argv[optind][0] == switchar && argv[optind][1] == switchar
				&& argv[optind][2] == '\0')
#endif
			) {
			optind++;
			return(EOF);
		}
	}
	optopt = c = argv[optind][sp];
#ifdef CASE_INSENSITIVE_OPTIONS
	if (isascii(c) && isupper(c))
		optopt = c = tolower(c);
#endif
	if (c == ':' || (cp = strchr(opts, c)) == NULL) {
		if (argv[optind][++sp] == '\0') {
			optind++;
			sp = 1;
		}
		message = ": illegal option -- ";
		goto bad;
	}
	if (*++cp == ':') {
		if (argv[optind][sp+1] != '\0')
			optarg = &argv[optind++][sp+1];
		else if (++optind >= argc) {
			sp = 1;
			message = ": option requires an argument -- ";
			goto bad;
		}
		else
			optarg = argv[optind++];
		sp = 1;
	} 
	else {
		if (argv[optind][++sp] == '\0') {
			sp = 1;
			optind++;
		}
		optarg = NULL;
	}
	return c;
bad:
	if (opterr) {
		fputs(argv[0], stderr);
		fputs(message, stderr);
		fputc(optopt, stderr);
		fputc('\n', stderr);
	}
	return '?';
}

/*
Local Variables:
c-indent-level: 4
c-continued-statement-offset: 4
c-brace-offset: 4
c-argdecl-indent: 4
c-label-offset: -4
tab-width: 4
End:
*/
EOF

for file in *; do sed -e 's/$//' $file >temp; mv temp $file; done

tar cf ../$tarfile *
cd ..
compress -b14 $tarfile
rm -fr temp

echo Now move $tarfile.Z to a MSDOS machine with Borland C++ 2.0,
echo unpack and compile with make -S.
